<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/augu1sto/eb3eaf548f9c/"/>
      <url>/augu1sto/eb3eaf548f9c/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 123 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test-12</title>
      <link href="/augu1sto/aba77dc25685/"/>
      <url>/augu1sto/aba77dc25685/</url>
      
        <content type="html"><![CDATA[<h1>hello world</h1><p>123</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【公告】重新建站ING...</title>
      <link href="/augu1sto/e31c317e1400/"/>
      <url>/augu1sto/e31c317e1400/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间一直没有更新博客，有很多原因，不过最近在用Obsidian同步技术笔记，很方便就是了。</p><p>实习过程中，用vue写了个小的项目<a href="https://augu1sto.gitee.io/projects/smartncc/doc">demo</a> ，没有完善好，但暂时不打算继续做了。</p><p>不过打算用vuepress重新建站，自己写主题，加上一些生活的板块（沉迷咖啡制作ing）还有工具箱等内容。说不定会迁移到其他网址。</p><blockquote><p>update: 重新部署的过程中说我有一篇文章有违规内容（以前怎么没有? fine，网站迁移倒计时</p></blockquote><p>近期还是会将以前的笔记整理整理并且复习复习，看心情可能会发上来（）</p><p>以上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Array.prototype.unshift方法详解</title>
      <link href="/augu1sto/45f675fda3f8/"/>
      <url>/augu1sto/45f675fda3f8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言<a class="header-anchor" href="#前言">⁍</a></h2><p>最近看到这么一道面试题</p><blockquote><p>输出以下代码执行的结果并解释为什么<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-string">&#x27;length&#x27;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&#x27;splice&#x27;</span>: <span class="hljs-built_in">Array</span>.prototype.splice,<br>    <span class="hljs-string">&#x27;push&#x27;</span>: <span class="hljs-built_in">Array</span>.prototype.push<br>&#125;<br>obj.push(<span class="hljs-number">1</span>)<br>obj.push(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">console</span>.log(obj)<br></code></pre></td></tr></table></figure><p>试了一下，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; obj.push(1)<br>3<br>&gt; obj.push(2)<br>4<br>&gt; console.log(obj)<br>&#123;<br>  <span class="hljs-string">&#x27;2&#x27;</span>: 1,<br>  <span class="hljs-string">&#x27;3&#x27;</span>: 2,<br>  length: 4,<br>  splice: [Function: splice],<br>  push: [Function: push]<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为<code>push</code> 方法根据 <code>length</code> 属性来决定从哪里开始插入给定的值。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>之后好奇试了一下<code>pop</code>和<code>shift</code>方法，<code>pop</code>属性也是根据<code>length</code>属性来决定位置，而<code>shift</code>属性总是从<strong>第一个</strong>位置开始移除元素。所以这两个方法的结果都是只有<code>length</code>减少，直至0，就不变了。</p><h2 id="问题">问题<a class="header-anchor" href="#问题">⁍</a></h2><p>问题就出在<code>unshift</code>方法上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt; <span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-string">&#x27;2&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;length&#x27;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-literal">undefined</span><br>&gt; obj.unshift = <span class="hljs-built_in">Array</span>.prototype.unshift<br>[<span class="hljs-built_in">Function</span>: unshift]<br>&gt; obj.unshift(<span class="hljs-number">0</span>)<br><span class="hljs-number">3</span><br>&gt; obj<br>&#123; <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">unshift</span>: [<span class="hljs-built_in">Function</span>: unshift] &#125;<br>&gt; obj.unshift(<span class="hljs-number">1</span>)<br><span class="hljs-number">4</span><br>&gt; obj<br>&#123; <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">unshift</span>: [<span class="hljs-built_in">Function</span>: unshift] &#125;<br></code></pre></td></tr></table></figure><p>当我们移入<code>0</code>时，位于下标2的<code>3</code>被删除了，而位于下标3的<code>4</code>却没变。感觉和想象的不太一样。</p><h2 id="分析">分析<a class="header-anchor" href="#分析">⁍</a></h2><p>对于这个方法，mdn上的描述是：<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><blockquote><p><strong><code>unshift()</code></strong> 方法将<strong>一个或多个元素</strong>添加到数组的<strong>开头</strong>，并返回该数组的<strong>新长度</strong>。</p></blockquote><p>看上去没什么，不过mdn还给出了它的ECMAScript规范<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>其中是这么写的</p><blockquote><ol><li>1. Let O be ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toobject">ToObject</a>(this value).</li><li>2. Let len be ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-lengthofarraylike">LengthOfArrayLike</a>(O).</li><li>3. Let argCount be the number of elements in items.</li><li>4. If argCount &gt; 0, then<ol><li>a. If len + argCount &gt; 253 - 1, throw a TypeError exception.</li><li>b. Let k be len.</li><li>c. Repeat, while k &gt; 0,<ol><li>i. Let from be ! <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tostring">ToString</a>(<a href="https://tc39.es/ecma262/multipage/notational-conventions.html#%F0%9D%94%BD">𝔽</a>(k - 1)).</li><li>ii. Let to be ! <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tostring">ToString</a>(<a href="https://tc39.es/ecma262/multipage/notational-conventions.html#%F0%9D%94%BD">𝔽</a>(k + argCount - 1)).</li><li>iii. Let fromPresent be ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-hasproperty">HasProperty</a>(O, from).</li><li>iv. If fromPresent is true, then<ol><li>1. Let fromValue be ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-get-o-p">Get</a>(O, from).</li><li>2. Perform ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-set-o-p-v-throw">Set</a>(O, to, fromValue, true).</li></ol></li><li>v. Else,<ol><li>1. <a href="https://tc39.es/ecma262/multipage/notational-conventions.html#assert">Assert</a>: fromPresent is false.</li><li>2. Perform ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-deletepropertyorthrow">DeletePropertyOrThrow</a>(O, to).</li></ol></li><li>vi. Set k to k - 1.</li></ol></li><li>d. Let j be +0𝔽.</li><li>e. For each element E of items, do<ol><li>i. Perform ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-set-o-p-v-throw">Set</a>(O, ! <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tostring">ToString</a>(j), E, true).</li><li>ii. Set j to j + 1𝔽.</li></ol></li></ol></li><li>5. Perform ? <a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-set-o-p-v-throw">Set</a>(O, “length”, <a href="https://tc39.es/ecma262/multipage/notational-conventions.html#%F0%9D%94%BD">𝔽</a>(len + argCount), true).</li><li>6. Return <a href="https://tc39.es/ecma262/multipage/notational-conventions.html#%F0%9D%94%BD">𝔽</a>(len + argCount).</li></ol></blockquote><p>虽然没有完全看懂，但翻译成人话，大概是这么个流程<br><img src="https://pic.stackoverflow.wiki/uploadImages/223/68/237/164/2022/09/05/20/56/1cb6b057-84a4-4428-8038-821dc817aa81.png" alt="image.png"></p><p>对于原题中的数组来说，一开始<code>from</code>是1，此时数组中不存在下标为1的值，所以要把<code>to</code>也就是2-1+1=2下标处的值（即<code>'2':3</code>）删除掉；<code>k-1</code>后为<code>1</code>，<code>from</code>变为<code>0</code>，也不存在，<code>k</code>继续减至0。从0开始移入新加入的值，结果就是<br><code>&#123;'0':0,'3':4&#125;</code></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://juejin.cn/post/6844903885488783374">https://juejin.cn/post/6844903885488783374</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push">Array.prototype.push() - JavaScript | MDN (mozilla.org)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift">Array.prototype.unshift() - JavaScript | MDN (mozilla.org)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.unshift">ECMAScript® 2023 Language Specification (tc39.es)</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝</title>
      <link href="/augu1sto/4cf012bad379/"/>
      <url>/augu1sto/4cf012bad379/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浅拷贝的时候是地址传递，两个对象指向的是同一个地址，修改其中一个对象里的值，另一个对象里的值也会被改变；深拷贝则是值传递，两个对象指向的是不同的地址，但是值是相同的</p></blockquote><h2 id="方法一：利用json">方法一：利用json<a class="header-anchor" href="#方法一：利用json">⁍</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不支持值为undefined、函数和循环引用的情况</span><br><span class="hljs-keyword">const</span> cloneObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj))<br></code></pre></td></tr></table></figure><p>利用JSON方法来拷贝有空位的数组的时候，空位（<code>undefined</code>）会被拷贝为<code>null</code></p><h2 id="方法二：递归拷贝">方法二：递归拷贝<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><a class="header-anchor" href="#方法二：递归拷贝">⁍</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj)<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj)<br>  <br><span class="hljs-keyword">if</span> (cache.has(obj)) <span class="hljs-keyword">return</span> cache.get(obj) <span class="hljs-comment">// 如果出现循环引用，则返回缓存的对象，防止递归进入死循环</span><br><span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor() <span class="hljs-comment">// 使用对象所属的构造函数创建一个新对象</span><br>cache.set(obj, cloneObj) <span class="hljs-comment">// 缓存对象，用于循环引用的情况</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br><span class="hljs-comment">// 用let..in拷贝对象会跳过empty item，因此不会定义没遍历到的key，那一位自然就变成empty item了</span><br><span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>cloneObj[key] = deepClone(obj[key], cache) <span class="hljs-comment">// 递归拷贝</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-attr">address</span>: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">200</span> &#125; &#125;<br>obj.a = obj <span class="hljs-comment">// 循环引用</span><br><span class="hljs-keyword">const</span> newObj = deepClone(obj)<br><span class="hljs-built_in">console</span>.log(newObj.address === obj.address) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="方法三：结合defineproperty">方法三：结合defineProperty<a class="header-anchor" href="#方法三：结合defineproperty">⁍</a></h2><p>参考<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> [[属性的描述对象#对象的拷贝]]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>.hasOwnProperty(property)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 过滤掉继承的属性，否则可能会报错</span><br>    <span class="hljs-built_in">Object</span>.defineProperty(<br>      to,<br>      property,<br>      <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-keyword">from</span>, property)<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br></code></pre></td></tr></table></figure><p>在方法二的基础上改进<a href="https://www.wangdoc.com/javascript/stdlib/attributes.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D">属性描述对象 - JavaScript 教程 - 网道 (wangdoc.com)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">let</span> newobj = <span class="hljs-keyword">new</span> obj.constructor(); <span class="hljs-comment">// 使数组仍是数组，日期仍是日期</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">if</span> (!obj.hasOwnProperty(property)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 过滤掉继承的属性，否则可能会报错</span><br>        <span class="hljs-built_in">Object</span>.defineProperty(<br>            newobj,<br>            property,<br>            <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, property)<br>        );<br>    &#125;<br>  <br>    <span class="hljs-keyword">return</span> newobj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附（最外层深拷贝）：object-assign">附（最外层深拷贝）：<code>Object.assign</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><a class="header-anchor" href="#附（最外层深拷贝）：object-assign">⁍</a></h2><p><code>Object.assign</code>默认是对对象进行深拷贝的，但是我们需要注意的是，它只对最外层的进行深拷贝，也就是当对象内嵌套有对象的时候，被嵌套的对象进行的还是浅拷贝；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneDeepAssign</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,obj)<br>  <span class="hljs-comment">//Object.assign(&#123;&#125;,obj)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（温馨提示：数组拷贝方法当中，使用<code>...</code>、<code>slice</code>、<code>concat</code>等进行拷贝也是一样的效果，只深拷贝最外层）</p><p>同时，我们知道<code>Object.assign</code>针对的是对象自身可枚举的属性，对于不可枚举的没有效果；</p><p>所以，当我们对于一个层次单一对象的时候，可以考虑这种方法，简单快捷。（试过了，也不支持<code>undefined</code>）</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://juejin.cn/post/7031322059414175774#heading-4">10个常见的前端手写功能，你全都会吗？ - 掘金 (juejin.cn)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.wangdoc.com/javascript/stdlib/attributes.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D">属性描述对象 - JavaScript 教程 - 网道 (wangdoc.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://juejin.cn/post/7013603488315736072#heading-2">深拷贝的实现方式（超全） - 掘金 (juejin.cn)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-CSS】图形以及动画</title>
      <link href="/augu1sto/0117eb7c6a8f/"/>
      <url>/augu1sto/0117eb7c6a8f/</url>
      
        <content type="html"><![CDATA[<div class="note flat"><p>本文简要记录一些freeCodeCamp里涉及的图形和动画相关内容</p></div><h2 id="transform">Transform<a class="header-anchor" href="#transform">⁍</a></h2><ul><li>CSS 属性 <code>transform</code> 里面的 <code>scale()</code> 函数可以用来改变元素的显示比例。<ul><li>可以用在<code>:hover</code>上面</li></ul></li><li><code>skewX()</code>：它使选择的元素沿着 X 轴（横向）倾斜指定的角度。（变成平行四边形那种样子）</li><li><code>rotate()</code>：旋转</li></ul><h2 id="图形">图形<a class="header-anchor" href="#图形">⁍</a></h2><ul><li><p>创建一个圆形的对象，<code>border-radius</code> 应该被设置成 50%。</p></li><li><p>新月：利用<code>border-radius</code>和<code>border-shadow</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: transparent;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">25px</span> <span class="hljs-number">10px</span> <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> blue;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>心形：利用伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.heart</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(-<span class="hljs-number">45deg</span>);<br>&#125;<br><span class="hljs-selector-class">.heart</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  // 注意这里的<span class="hljs-attribute">top</span>和<span class="hljs-attribute">left</span>的计算是<span class="hljs-attribute">transform</span>之前的<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">25px</span>;<br>&#125;<br><span class="hljs-selector-class">.heart</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="动画">动画<a class="header-anchor" href="#动画">⁍</a></h2><ul><li><p><code>animation-name</code> 用来设置动画的名称，也就是我们稍后要在 <code>@keyframes</code> 里用到的名称。</p></li><li><p><code>animation-duration</code> 设置动画所花费的时间。</p></li><li><p><code>animation-fill-mode</code> 指定了在动画结束时元素的样式，设置为<code>forwards</code>，保持最后的属性。</p></li><li><p><code>@keyframes</code> 可以通过设置特定时间点的行为来创建动画。只需要给持续时间内的特定帧（从 0% 到 100%）加上 CSS 规则。</p><ul><li>如果只设置0-100%中的一个关键帧，会自动进行一个往返</li></ul></li><li><p><code>animation-iteration-count</code>，这个属性允许你控制动画循环的次数，<code>infinite</code>无限</p></li><li><p><code>animation-timing-function</code> 用来定义动画的速度曲线。</p><ul><li><p>默认值是 <code>ease</code>，动画以低速开始，然后加快，在结束前变慢。</p></li><li><p><code>ease-out</code>：动画以高速开始，以低速结束</p></li><li><p><code>ease-in</code>，动画以低速开始，以高速结束；</p></li><li><p><code>linear</code>：动画从头到尾的速度是相同的。</p></li><li><p>可以用 <code>cubic-bezier</code> 来定义贝塞尔曲线。</p><ul><li><p><code>cubic-bezier</code> 函数包含了 1 * 1 网格里的4个点：<code>p0</code>、<code>p1</code>、<code>p2</code>、<code>p3</code>。 其中 <code>p0</code> 和 <code>p3</code> 是固定值，代表曲线的起始点和结束点，坐标值依次为 (0, 0) 和 (1, 1)。 你只需设置 <strong>另外两点的x 值和 y 值</strong> ，设置的这两点确定了曲线的形状从而确定了动画的速度曲线。 在 CSS 里面通过 <code>(x1, y1, x2, y2)</code> 来确定 <code>p1</code> 和 <code>p2</code>。</p></li><li><p>贝塞尔曲线是在 1*1 的坐标系统内，x 值只能在 0 到 1，但是 y 值是可以大于 1 的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation-timing-function</span>: <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">0.75</span>); // linear<br><span class="hljs-attribute">animation-timing-function</span>: <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.58</span>, <span class="hljs-number">1</span>); // ease-out<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><mark><code>::before</code>和<code>::after</code>不需要单独设置动画，会随主元素一起动</mark> （因为它们本质是主元素中的属性）</p><h3 id="常见属性">常见属性<a class="header-anchor" href="#常见属性">⁍</a></h3><ul><li>在元素的 <code>position</code> 已有指定值（如 <code>fixed</code> 或者 <code>relative</code>）时，CSS 偏移属性 <code>right</code>、<code>left</code>、<code>top</code>、<code>bottom</code> 可以用在动画规则里创建动作。<ul><li>定位为<code>relative</code>时，会相对上一个关键帧的位置移动</li></ul></li><li>改变动画元素的 <code>opacity</code> 属性值，实现渐隐。</li><li><code>transform</code>实现缩放或者旋转等<ul><li>注意如果有多个效果A和B，只想改变A，不想改变B，B也要在每个关键帧出现</li></ul></li></ul><p>实例：</p><p>心跳（github待添加链接）</p><p>星星闪烁</p>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-JS】函数</title>
      <link href="/augu1sto/0038d1413ee3/"/>
      <url>/augu1sto/0038d1413ee3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述">概述<a class="header-anchor" href="#概述">⁍</a></h2><h3 id="声明方法">声明方法<a class="header-anchor" href="#声明方法">⁍</a></h3><ul><li>普通方法</li><li>赋值语句（将 <strong>匿名函数</strong> 赋值给某个变量）</li></ul><h3 id="第一等公民">第一等公民<a class="header-anchor" href="#第一等公民">⁍</a></h3><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// 将函数赋值给一个变量</span><br><span class="hljs-keyword">var</span> operator = add;<br><br><span class="hljs-comment">// 将函数作为参数和返回值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">op</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> op;<br>&#125;<br>a(operator)(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="函数名提升与重复声明">函数名提升与重复声明<a class="header-anchor" href="#函数名提升与重复声明">⁍</a></h3><ul><li>用赋值语句定义的函数 <strong>不能</strong> 在调用前声明，因为变量提升到前面后并未赋值，相当于<code>undefined</code></li><li>采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义。<ul><li>而一般情况下，重复声明，后面声明的会覆盖前面的</li></ul></li></ul><h3 id="属性和方法">属性和方法<a class="header-anchor" href="#属性和方法">⁍</a></h3><ul><li><code>name</code>属性：函数的名字/匿名函数声明时赋给的变量名<ul><li>可以用于获取传入的参数函数的名字</li></ul></li><li><code>length</code>属性：返回 <strong>定义</strong> 的参数个数<ul><li>如果是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">剩余参数</a><code>...args</code>，则会返回0</li></ul></li><li><code>toString()</code>方法返回一个字符串，内容是函数的源码。<ul><li>函数内部的注释也可以返回。利用这一点，可以变相实现多行字符串。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li><li>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code>。</li></ul></li></ul><h2 id="函数作用域scope">函数作用域scope<a class="header-anchor" href="#函数作用域scope">⁍</a></h2><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域（ES6新增）</li></ul><p>函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p><h2 id="参数">参数<a class="header-anchor" href="#参数">⁍</a></h2><h3 id="参数的省略">参数的省略<a class="header-anchor" href="#参数的省略">⁍</a></h3><p>没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入<code>undefined</code>。</p><h3 id="传递方式">传递方式<a class="header-anchor" href="#传递方式">⁍</a></h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>值传递与引用传递</span></div>    <div class="hide-content"><p><strong>值传递</strong></p><p>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的原始值得一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值得修改，不影响实际参数的值</p><p><strong>引用传递</strong></p><p>一般也称为地址传递。方法调用时，实际参数的引用（地址，而不是参数的值）被传递给方法中相对应的形式参数，函数接收的原始值的内存地址</p></div></div><p>变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。</p><p>如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。</p><p>如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。(重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响。)</p><h3 id="同名参数">同名参数<a class="header-anchor" href="#同名参数">⁍</a></h3><p>如果有同名的参数，则取最后出现的那个值。</p><h3 id="arguments对象">arguments对象<a class="header-anchor" href="#arguments对象">⁍</a></h3><p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p><ul><li>数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</li></ul><p><strong>callee 属性</strong></p><p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p><p>可以通过<code>arguments.callee()</code>，达到调用函数自身的目的。( <strong>ES5禁止在严格模式下使用此属性</strong> )</p><h2 id="闭包">闭包<a class="header-anchor" href="#闭包">⁍</a></h2><p>JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>但是，嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数）。这给内部函数的变量提供了一定的 <strong>安全性</strong> 。</p><p>总结如下：</p><ul><li>内部函数只可以在外部函数中访问。</li><li>内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。</li></ul><p>由于内部函数可以访问外部函数的作用域，因此当内部函数 <strong>生存周期</strong> 大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。</p><p>就是说，一个闭包必须 <strong>保存它可见作用域中所有参数和变量</strong> 。因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIncrementor</span>(<span class="hljs-params">start</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> start++;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> inc = createIncrementor(<span class="hljs-number">5</span>);<br><br>inc() <span class="hljs-comment">// 5</span><br>inc() <span class="hljs-comment">// 6</span><br>inc() <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><p>闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。</p><p>闭包的用处：</p><ol><li>读取外层函数内部的变量</li><li>让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li><li>封装对象的私有属性和私有方法</li></ol><h2 id="立即调用的函数表达式（iife）">立即调用的函数表达式（IIFE）<a class="header-anchor" href="#立即调用的函数表达式（iife）">⁍</a></h2><p>JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p><p>函数定义后立即调用的解决方法，最简单的处理，就是将其放在一个圆括号里面。(Immediately-Invoked Function Expression），简称 IIFE。(<mark>注意分号</mark>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// SyntaxError: Unexpected token (</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br><br><span class="hljs-comment">// correct</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;();<br>f <span class="hljs-comment">// 1</span><br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>~<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>-<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br><br><span class="hljs-comment">// IIFE</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;());<br><span class="hljs-comment">// 或者</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;)();<br></code></pre></td></tr></table></figure><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：</p><ol><li>不必为函数命名，避免了污染全局变量；</li><li>IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li></ol><h2 id="箭头函数">箭头函数<a class="header-anchor" href="#箭头函数">⁍</a></h2><p>箭头函数总是匿名的 ref <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数表达式 (mozilla.org)</a>/<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/">深度了解ES6：箭头函数 (mozilla.org)</a></p><p><strong>箭头函数表达式</strong>的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><h2 id="预定义函数">预定义函数<a class="header-anchor" href="#预定义函数">⁍</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">函数 - JavaScript | MDN (mozilla.org)</a></p><h3 id="eval">eval<a class="header-anchor" href="#eval">⁍</a></h3><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://wangdoc.com/javascript/types/function.html">函数 - JavaScript 教程 - 网道 (wangdoc.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions#%E9%97%AD%E5%8C%85">函数 - JavaScript | MDN (mozilla.org)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【marp】VSCODE+Markdown写slides</title>
      <link href="/augu1sto/5bac2fb186d0/"/>
      <url>/augu1sto/5bac2fb186d0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文旨在记录一些marp做slides的常用语法</p><p>参考： <a href="https://marpit.marp.app/markdown">Marpit Markdown</a></p></blockquote><h2 id="开启marp">开启marp<a class="header-anchor" href="#开启marp">⁍</a></h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><span class="hljs-section">marp: true</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h2 id="常见指令">常见指令<a class="header-anchor" href="#常见指令">⁍</a></h2><h3 id="分割slides">分割slides<a class="header-anchor" href="#分割slides">⁍</a></h3><p>用<code>---</code>/<code>___</code>/<code>***</code>/<code>- - -</code>分割</p><h3 id="设置样式的几种方法">设置样式的几种方法<a class="header-anchor" href="#设置样式的几种方法">⁍</a></h3><ul><li>用HTML注释实现：当前页及其之后的所有页都会变成该样式 <code>&lt;!-- backgroundColor: aqua --&gt;</code><ul><li>加上<code>_</code>就会只应用于本幻灯片 <code>&lt;!-- _backgroundColor: aqua --&gt;</code></li></ul></li><li>YAML frontmatter：应用所有</li></ul><h3 id="全局指令">全局指令<a class="header-anchor" href="#全局指令">⁍</a></h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>theme</code></td><td>Specify theme of the slide deck.</td></tr><tr><td><code>style</code></td><td>Specify CSS for tweaking theme.</td></tr><tr><td><code>headingDivider</code></td><td>Specify heading divider option.</td></tr></tbody></table><ul><li>用<code>&lt;!-- headingDivider: 3 --&gt;</code>可以设置分页的最低标题级数，不用分割线分割（例如设置为3，则遇到1/2/3级标题就会自动分页）</li></ul><h3 id="local指令">local指令<a class="header-anchor" href="#local指令">⁍</a></h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>paginate</code></td><td>显示页码 if you set <code>true</code>.</td></tr><tr><td><code>header</code></td><td>指定页眉（用单引号，可以插图片）</td></tr><tr><td><code>footer</code></td><td>指定页脚（用单引号，可以插图片）</td></tr><tr><td><code>class</code></td><td>Specify HTML class of slide’s <code>&lt;section&gt;</code> element.</td></tr><tr><td><code>backgroundColor</code></td><td>Setting <code>background-color</code> style of slide.</td></tr><tr><td><code>backgroundImage</code></td><td>Setting <code>background-image</code> style of slide.（可以直接用css语法设置渐变色）</td></tr><tr><td><code>backgroundPosition</code></td><td>Setting <code>background-position</code> style of slide.（默认center）</td></tr><tr><td><code>backgroundRepeat</code></td><td>Setting <code>background-repeat</code> style of slide.（默认no-repeat）</td></tr><tr><td><code>backgroundSize</code></td><td>Setting <code>background-size</code> style of slide.（默认cover）</td></tr><tr><td><code>color</code></td><td>Setting <code>color</code> style of slide.</td></tr></tbody></table><h3 id="主题设置">主题设置<a class="header-anchor" href="#主题设置">⁍</a></h3><p>内置主题见：<a href="https://github.com/marp-team/marp-core/tree/main/themes">marp-core/themes at main · marp-team/marp-core (github.com)</a></p><p>可以通过如下语法对细节进行调整</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><span class="hljs-section"># class: invert</span><br>theme: uncover<br>style: |<br>  section &#123;<br><span class="hljs-code">    text-align: left;</span><br><span class="hljs-code">    font-size: 30px;</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">    ul, ol &#123;</span><br><span class="hljs-code">      margin: 0;</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">---</span><br></code></pre></td></tr></table></figure><h2 id="图片语法">图片语法<a class="header-anchor" href="#图片语法">⁍</a></h2><p>图片的通用语法是<code>![options](imgsrc)</code></p><p><a href="https://marpit.marp.app/image-syntax">Image syntax (marp.app)</a></p><h3 id="调整宽高">调整宽高<a class="header-anchor" href="#调整宽高">⁍</a></h3><p><code>![width:200px height:30cm](image.jpg) </code> 空格分隔！</p><h3 id="设置背景">设置背景<a class="header-anchor" href="#设置背景">⁍</a></h3><p>options: <code>bg</code></p><p>其他可选：</p><ul><li><code>vertical</code> 垂直</li><li><code>cover(default)</code>/<code>contain</code>/<code>fit</code>/<code>auto</code>/<code>x%</code>：调整尺寸（可以用调宽高的方法）</li><li><code>left</code>/<code>right</code>/<code>left:33%</code></li></ul><h3 id="设置颜色">设置颜色<a class="header-anchor" href="#设置颜色">⁍</a></h3><p><code>![bg](#fff)</code></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-JS】JS基础</title>
      <link href="/augu1sto/f7c3b46165f9/"/>
      <url>/augu1sto/f7c3b46165f9/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><h2 id="javascript">JavaScript<a class="header-anchor" href="#javascript">⁍</a></h2><p>JavaScript可以分为三部分<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p><blockquote><p>注：这里暂时没找其他的理论依据，但是道理大概是这么回事</p></blockquote><ul><li>ECMAScript：核心，描述了Js语法及各种标准，目前通用的有ES5，更新的是ES6</li><li>DOM（文档对象类型）：HTML和XML的API。用DOM API可以轻松地删除、添加、替换节点</li><li>BOM（浏览器对象模型）：对浏览器窗口进行访问和操作（不同浏览器有自己的实现，没有统一标准）</li></ul><p><strong>应用程序接口（Application Programming Interfaces</strong>（<strong>API</strong>）） <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p><p>API 通常分为浏览器API和第三方API</p><p>浏览器API包括DOM API、地理位置API、画布和web GL API，以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API"><code>WebRTC</code></a> 等 <a href="https://developer.mozilla.org/en-US/Apps/Fundamentals/Audio_and_video_delivery">影音类 API</a></p><h3 id="javascript-在页面上做了什么"><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#javascript_%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">JavaScript 在页面上做了什么</a><a class="header-anchor" href="#javascript-在页面上做了什么">⁍</a></h3><p>在 HTML 和 CSS 集合组装成一个网页后，浏览器的 JavaScript 引擎将执行 JavaScript 代码。</p><p>JavaScript 最普遍的用处是通过 DOM API（见上文）动态修改 HTML 和 CSS 来更新用户界面 （user interface）。</p><p>每个浏览器标签页就是其自身用来运行代码的独立容器（运行环境）</p><h3 id="解释型和编译型"><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%E8%A7%A3%E9%87%8A%E4%BB%A3%E7%A0%81_vs_%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">解释型和编译型</a><a class="header-anchor" href="#解释型和编译型">⁍</a></h3><p>在解释型语言中，代码自上而下运行，且实时返回运行结果。</p><p>JavaScript 是轻量级解释型语言。浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。技术上，几乎所有 JavaScript 转换器都运用了一种叫做 <strong>即时编译</strong> （JIT，Just-In-Time compiling）的技术；当 JavaScript 源代码被执行时，它会被编译成 <strong>二进制的格式</strong> ，使代码运行速度更快。尽管如此，JavaScript 仍然是一门解释型语言，因为编译过程发生在代码运行中，而非之前。</p><h3 id="添加js的方法">添加Js的方法<a class="header-anchor" href="#添加js的方法">⁍</a></h3><h4 id="内部javascript">内部JavaScript<a class="header-anchor" href="#内部javascript">⁍</a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 在此编写 JavaScript 代码</span></span><br><span class="javascript"></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="外部javascript">外部JavaScript<a class="header-anchor" href="#外部javascript">⁍</a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="脚本调用策略">脚本调用策略<a class="header-anchor" href="#脚本调用策略">⁍</a></h4><div class="note modern red flat"><p>HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">文档对象模型</a> DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。</p></div><p>如果Js脚本位于文档头处，则会在HTML文档体之前解析，存在隐患。需要用一些结构笔面错误发生。</p><ol><li>（旧方法）把脚本元素放在文档体的底端（<code>&lt;/body&gt;</code> 标签之前，与之相邻），这样脚本就可以在 HTML 解析完毕后加载了。</li><li>监听浏览器的 “<code>DOMContentLoaded</code>” 事件,即 HTML 文档体加载、解释完毕事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  . . .<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li>外部引用添加<code>async</code> “异步”属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-keyword">async</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="async-和-defer"><code>async</code> 和 <code>defer</code><a class="header-anchor" href="#async-和-defer">⁍</a></h5><ul><li>如果脚本无需等待页面解析，且页面的脚本之间彼此独立，不依赖于本页面的其它任何脚本时，那么应使用 <code>async</code>。</li><li>如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script defer src=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;&lt;/script&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="声明-变量-常量">声明/变量/常量<a class="header-anchor" href="#声明-变量-常量">⁍</a></h2><p><strong>09-3种声明变量方式 P9 - 01:19</strong> <sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup></p><ul><li>var，可变变量，有函数作用域（就是类比函数的话，可以在第1行调用，但是第10行定义）</li><li>const不可修改(const定义的其实不是变量，是 <strong>常量</strong> )</li><li>let可修改 用在循环</li></ul><blockquote><p>var可以省略，但如果省略后就是全局变量（即使定义在函数内也是全局变量（准确说是全局对象的属性？））</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  oopsGlobal = <span class="hljs-number">5</span>;<br>&#125;<br>fun1();<br><br><span class="hljs-built_in">console</span>.log(oopsGlobal); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>如果访问没有声明的变量会抛出 <strong>引用错误（ReferenceError）</strong> <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p><h3 id="变量">变量<a class="header-anchor" href="#变量">⁍</a></h3><p>一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）</p><p>变量未被赋值-》返回<code>undefined</code></p><h4 id="变量提升">变量提升<a class="header-anchor" href="#变量提升">⁍</a></h4><blockquote><p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码（函数）的头部，这就叫做变量提升（hoisting）。<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p></blockquote><p>对于var来说，可以先使用变量稍后再声明变量而不会引发异常。</p><blockquote><p>在 ECMAScript 6 中，let（const）同样<strong>会被提升</strong>变量到代码块的顶部但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。</p></blockquote><p>但是只是没有引发异常，变量不能获取之后被赋予的值，此时调用会显示<code>undefined</code>，而如果与数字进行运算，则会输出<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>（因为是非数值<code>undefined</code>进行运算）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 例子1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">console</span>.log(x === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 例子2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// will return a value of undefined</span><br><span class="hljs-keyword">var</span> myvar = <span class="hljs-string">&quot;my value&quot;</span>;<br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(myvar); <span class="hljs-comment">// undefined</span><br>  <span class="hljs-keyword">var</span> myvar = <span class="hljs-string">&quot;local value&quot;</span>; <span class="hljs-comment">// 这一行的myvar声明被提升到function的开头，因此此时的myvar是违背赋值的状态</span><br>&#125;)();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 例子3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">console</span>.log(x-<span class="hljs-number">10</span>); <span class="hljs-comment">//NaN</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><br></code></pre></td></tr></table></figure><p>对于函数来说，只有函数声明<code>function foo() </code>会被提升到顶部，而函数表达式<code>var baz = function() </code>不会被提升。</p><h3 id="常量const">常量const<a class="header-anchor" href="#常量const">⁍</a></h3><p>常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。</p><p><mark>但是，</mark> 对象属性被赋值为常量是不受保护的，可以修改。（同样，数组也属于对象）<sup class="footnote-ref"><a href="#fn7" id="fnref7:1">[7:1]</a></sup></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-number">2</span><br>&#125;;<br><br>obj.key1 = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123; key1: 10, key2: 2 &#125;</span><br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [ 1, 2, 20 ]</span><br></code></pre></td></tr></table></figure><h2 id="数据类型">数据类型<a class="header-anchor" href="#数据类型">⁍</a></h2><p>JavaScript 中的类型应该包括这些：<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a>（数字）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>（字符串）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a>（布尔）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>（符号）（ES6 新增，一种实例是唯一且不可改变的数据类型。）</p></li><li><p><code>Object</code></p><p>（对象）</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a>（函数）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>（数组）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a>（日期）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a>（正则表达式）</li></ul></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>（空）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>（未定义）</p></li></ul><h3 id="确定js的类型">确定js的类型<a class="header-anchor" href="#确定js的类型">⁍</a></h3><ul><li><code>typeof</code>运算符</li><li><code>instanceof</code>运算符</li><li><code>Object.prototype.toString</code>方法<sup class="footnote-ref"><a href="#fn9" id="fnref9:1">[9:1]</a></sup><ul><li>具体使用 <code>Object.prototype.toString.call(i)</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> i = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">const</span> f = <span class="hljs-number">0.3</span>;<br><span class="hljs-keyword">const</span> s = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> b = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> u = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">const</span> o = &#123;<br>    <span class="hljs-string">&quot;1&quot;</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">o2</span> :<span class="hljs-string">&quot;2&quot;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> i0 = <span class="hljs-built_in">Number</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">const</span> i1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// typeof</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;---typeof---&quot;</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;i&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> i&#125;</span>`</span>); <span class="hljs-comment">// number</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;i0&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> i0&#125;</span>`</span>); <span class="hljs-comment">// number</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;i1&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> i1&#125;</span>`</span>); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;f&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> f&#125;</span>`</span>); <span class="hljs-comment">// number</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;s&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> s&#125;</span>`</span>); <span class="hljs-comment">// string</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;arr&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> arr&#125;</span>`</span>); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;b&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> b&#125;</span>`</span>); <span class="hljs-comment">// boolean</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;n&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> n&#125;</span>`</span>); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;u&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> u&#125;</span>`</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;o&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> o&#125;</span>`</span>); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;fn&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> fn&#125;</span>`</span>); <span class="hljs-comment">// function</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-literal">NaN</span>&#125;</span>:\t <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>&#125;</span>`</span>); <span class="hljs-comment">// number</span><br><br><span class="hljs-comment">// instanceof </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;---instanceof---&quot;</span>)<br><span class="hljs-comment">// console.log(`$&#123;i instanceof number&#125;`); number is not defined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;i <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>&#125;</span>`</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;s <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>&#125;</span>`</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;i0 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>&#125;</span>`</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;i1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>&#125;</span>`</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;o <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>&#125;</span>`</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>&#125;</span>`</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;fn <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>&#125;</span>`</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// prototype</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;---prototype---&quot;</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(i)&#125;</span>`</span>); <span class="hljs-comment">// [object Number]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(f)&#125;</span>`</span>); <span class="hljs-comment">// [object Number]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(s)&#125;</span>`</span>); <span class="hljs-comment">// [object String]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(arr)&#125;</span>`</span>); <span class="hljs-comment">// [object Array]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(b)&#125;</span>`</span>); <span class="hljs-comment">// [object Boolean]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(n)&#125;</span>`</span>); <span class="hljs-comment">// [object Null]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(u)&#125;</span>`</span>); <span class="hljs-comment">// [object Undefined]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(o)&#125;</span>`</span>); <span class="hljs-comment">// [object Object]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(fn)&#125;</span>`</span>); <span class="hljs-comment">// [object Function]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">NaN</span>)&#125;</span>`</span>); <span class="hljs-comment">// [object Number]</span><br></code></pre></td></tr></table></figure><h4 id="typeof">typeof<a class="header-anchor" href="#typeof">⁍</a></h4><h4 id="instanceof">instanceof<a class="header-anchor" href="#instanceof">⁍</a></h4><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">object instanceof constructor<br></code></pre></td></tr></table></figure><p>必须是object</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof - JavaScript | MDN (mozilla.org)</a></p><h4 id="prototype">prototype<a class="header-anchor" href="#prototype">⁍</a></h4><h3 id="字面量（literals，字面形式）">字面量（Literals，字面形式）<a class="header-anchor" href="#字面量（literals，字面形式）">⁍</a></h3><p>字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></p><h3 id="null-undefined-和布尔值">null, undefined 和布尔值<a class="header-anchor" href="#null-undefined-和布尔值">⁍</a></h3><h4 id="null">null<a class="header-anchor" href="#null">⁍</a></h4><p>JavaScript 中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a> 表示一个空值（non-value），必须使用 null 关键字才能访问，，转为数值时为<code>0</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br><br>fn(); <span class="hljs-comment">// Hello World</span><br>fn(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Hello World</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)+<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>+<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>+<span class="hljs-string">&#x27;n&#x27;</span>); <span class="hljs-comment">// nulln</span><br></code></pre></td></tr></table></figure><h4 id="undefined">undefined<a class="header-anchor" href="#undefined">⁍</a></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 是一个“undefined（未定义）”类型的对象，表示一个未初始化的值，也就是还没有被分配的值。转为数值时为<code>NaN</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 变量声明了，但没有赋值</span><br><span class="hljs-keyword">var</span> i;<br><span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-built_in">console</span>.log(f()); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 对象没有赋值的属性</span><br><span class="hljs-keyword">var</span>  o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">console</span>.log(o.p) <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 函数没有返回值时，默认返回 undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(f()); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>));  <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h4 id="布尔值">布尔值<a class="header-anchor" href="#布尔值">⁍</a></h4><p>转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code>或<code>''</code>（空字符串）</li></ul><p>注意，空数组（<code>[]</code>）和空对象（<code>&#123;&#125;</code>）对应的布尔值，都是<code>true</code>。</p><h3 id="数值">数值<a class="header-anchor" href="#数值">⁍</a></h3><p>JavaScript 采用“遵循 IEEE 754 标准的双精度 64 位格式”（“double-precision 64-bit format IEEE 754 values”）表示数字。——在JavaScript（除了BigInt）当中， <mark>并不存在整数/整型(Integer)</mark> 。<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 === 1.0 // true<br>0.1 + 0.2 === 0.3 // false 0.1 + 0.2 = 0.30000000000000004<br></code></pre></td></tr></table></figure><p>JavaScript  浮点数的64个二进制位，从最左边开始，是这样组成的。<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup></p><ul><li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li><li>第2位到第12位（共11位）：指数部分 (0到2047)</li><li>第13位到第64位（共52位）：小数部分（即有效数字）</li></ul><p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2<sup>53</sup>到2<sup>53</sup>，都可以精确表示。</p><p><mark>简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</mark></p><h4 id="正向溢出与负向溢出">正向溢出与负向溢出<a class="header-anchor" href="#正向溢出与负向溢出">⁍</a></h4><p>JavaScript 能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>) <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, -<span class="hljs-number">1075</span>) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p><h4 id="科学计数法-浮点数字面量">科学计数法/浮点数字面量<a class="header-anchor" href="#科学计数法-浮点数字面量">⁍</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">123e3</span> <span class="hljs-comment">// 123000</span><br><span class="hljs-number">123e-3</span> <span class="hljs-comment">// 0.123</span><br>-<span class="hljs-number">3.1E+12</span><br><span class="hljs-number">.1e-23</span><br></code></pre></td></tr></table></figure><p>浮点数字面值可以有以下的组成部分：</p><ul><li>一个十进制整数，可以带正负号（即前缀“+”或“ - ”），</li><li>小数点（“.”），</li><li>小数部分（由一串十进制数表示），</li><li>指数部分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[(+|-)][digits][.digits][(E|e)[(+|-)]digits]<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">3.14</span><br>-<span class="hljs-number">.2345789</span> <span class="hljs-comment">// -0.23456789</span><br>-<span class="hljs-number">3.12e+12</span>  <span class="hljs-comment">// -3.12*10^12</span><br><span class="hljs-number">.1e-23</span>    <span class="hljs-comment">// 0.1*10^(-23)=10^(-24)=1e-24</span><br></code></pre></td></tr></table></figure><h4 id="整数进制字面量">整数进制字面量<a class="header-anchor" href="#整数进制字面量">⁍</a></h4><ul><li>十进制：没有前导0的数值。</li><li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li><li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li><li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul><h4 id="特殊数值">特殊数值<a class="header-anchor" href="#特殊数值">⁍</a></h4><ul><li><code>NaN</code>： Not a Number<ul><li><code>0/0</code>也是<code>NaN</code></li><li><code>NaN</code>不等于任何值，包括它本身。 <code>NaN === NaN // false</code></li><li><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</li><li>可以使用内置函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN"><code>isNaN()</code></a> 来判断一个变量是否为 <code>NaN</code></li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Infinity"><code>Infinity</code></a>（正无穷）和 <code>-Infinity</code>（负无穷）<ul><li><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。</li><li>四则运算，符合无穷的数学计算规则。</li><li>0乘以<code>Infinity</code>，返回<code>NaN</code>；0除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以0，返回<code>Infinity</code>。<ul><li>与<code>null</code>计算时，<code>null</code>会转成0</li></ul></li><li><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</li><li>内置函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isFinite"><code>isFinite()</code></a> 来判断一个变量是否是一个有穷数 （类型为<code>Infinity</code>, <code>-Infinity</code> 或 <code>NaN</code>则返回false）</li><li><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</li></ul></li><li>正零<code>+0</code>和负零<code>-0</code><ul><li>区别就是64位浮点数表示法的符号位不同，几乎等价</li><li>唯一区别：<code>(1 / +0) === (1 / -0) // false</code><ul><li>一个是<code>Infinity</code>一个是<code>-Infinity</code></li></ul></li></ul></li></ul><h4 id="数值转换">数值转换<a class="header-anchor" href="#数值转换">⁍</a></h4><h5 id="parseint">parseInt<a class="header-anchor" href="#parseint">⁍</a></h5><p>内置函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt"><code>parseInt()</code></a> 将字符串转换为整型。该函数的第二个可选参数表示字符串所表示数字的基（进制）（2到36之间）如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略，返回十进制结果。</p><ul><li>会自动删除头部空格</li><li>会自动将参数转换为字符串</li><li>遇到不能转换的字符则停止转换，返回前面已经转换的部分（如果有小数点，只能转换整数部分）（前提是已经是字符串格式）</li><li>如果第一个字符就不能转换，则返回<code>NaN</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;.3&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+1&#x27;</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1.1</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1.</span>.) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1..&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ul><li>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1000000000000000000000.5</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1e+21&#x27;</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000008</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8e-7&#x27;</span>) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><ul><li>如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果，，对于八进制的前缀0，尤其需要注意：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">011</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">2</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">011</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">9</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h5 id="parsefloat">parseFloat<a class="header-anchor" href="#parsefloat">⁍</a></h5><p>会自动过滤字符串前导的空格</p><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p><p><code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// 123.45</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h5 id="一元加法运算符">一元加法运算符<a class="header-anchor" href="#一元加法运算符">⁍</a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;1.1&quot;</span> + <span class="hljs-string">&quot;1.1&quot;</span> = <span class="hljs-string">&quot;1.11.1&quot;</span><br>(+<span class="hljs-string">&quot;1.1&quot;</span>) + (+<span class="hljs-string">&quot;1.1&quot;</span>) = <span class="hljs-number">2.2</span><br><span class="hljs-comment">// 注意：加入括号为清楚起见，不是必需的。</span><br>+ <span class="hljs-string">&quot;42&quot;</span>;   <span class="hljs-comment">// 42</span><br>+ <span class="hljs-string">&quot;010&quot;</span>;  <span class="hljs-comment">// 10</span><br>+ <span class="hljs-string">&quot;0x10&quot;</span>; <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><h3 id="字符串">字符串<a class="header-anchor" href="#字符串">⁍</a></h3><ul><li>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</li><li>反斜杠后面跟八进制或十六进制可以表示Unicode码点</li><li>JavaScript 原生提供两个 Base64 相关的方法。（将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。）<ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul></li></ul><p>字符串也有一些方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;hello&quot;</span>.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// &quot;h&quot;</span><br><span class="hljs-string">&quot;hello, world&quot;</span>.replace(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;mars&quot;</span>); <span class="hljs-comment">// &quot;hello, mars&quot;</span><br><span class="hljs-string">&quot;hello&quot;</span>.toUpperCase(); <span class="hljs-comment">// &quot;HELLO&quot;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>JS特殊字符</span></div>    <div class="hide-content"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">意思</th></tr></thead><tbody><tr><td style="text-align:left">\0</td><td style="text-align:left">Null字节</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格符</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页符</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行符</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车符</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">Tab (制表符)</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直制表符</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">单引号</td></tr><tr><td style="text-align:left">\&quot;</td><td style="text-align:left">双引号</td></tr><tr><td style="text-align:left">\\</td><td style="text-align:left">反斜杠字符（\）</td></tr><tr><td style="text-align:left">\XXX</td><td style="text-align:left">由从0到377最多三位八进制数<em>XXX</em>表示的 Latin-1 字符。例如，\251是版权符号的八进制序列。</td></tr><tr><td style="text-align:left">\x<em>XX</em></td><td style="text-align:left">由从00和FF的两位十六进制数字XX表示的Latin-1字符。例如，\ xA9是版权符号的十六进制序列。</td></tr><tr><td style="text-align:left">\uXXXX</td><td style="text-align:left">由四位十六进制数字XXXX表示的Unicode字符。例如，\ u00A9是版权符号的Unicode序列。见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#string_literals">Unicode escape sequences</a> (Unicode 转义字符).</td></tr><tr><td style="text-align:left">\u*{XXXXX}*</td><td style="text-align:left">Unicode代码点 (code point) 转义字符。例如，\u{2F804} 相当于Unicode转义字符 \uD87E\uDC04的简写。</td></tr></tbody></table></div></div><h4 id="模板字面量">模板字面量<a class="header-anchor" href="#模板字面量">⁍</a></h4><p>ES6中提供了一种模板字面量（template literals），模板字符串提供了一些语法糖来帮你构造字符串。</p><p>除此之外，你可以在通过模板字符串前添加一个tag来自定义模板字符串的解析过程，这可以用来防止注入攻击，或者用来建立基于字符串的高级数据抽象。<sup class="footnote-ref"><a href="#fn10" id="fnref10:1">[10:1]</a></sup></p><p>此外模板字面量支持多行字符串的输入</p><blockquote><p>如何放置注入攻击？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Basic literal string creation</span><br><span class="hljs-string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span><br><br><span class="hljs-comment">// Multiline strings</span><br><span class="hljs-string">`In JavaScript this is</span><br><span class="hljs-string"> not legal.`</span><br><br><span class="hljs-comment">// String interpolation</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Bob&quot;</span>, time = <span class="hljs-string">&quot;today&quot;</span>;<br><span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>, how are you <span class="hljs-subst">$&#123;time&#125;</span>?`</span><br><br><span class="hljs-comment">// Construct an HTTP request prefix is used to interpret the replacements and construction</span><br>POST<span class="hljs-string">`http://foo.org/bar?a=<span class="hljs-subst">$&#123;a&#125;</span>&amp;b=<span class="hljs-subst">$&#123;b&#125;</span></span><br><span class="hljs-string">     Content-Type: application/json</span><br><span class="hljs-string">     X-Credentials: <span class="hljs-subst">$&#123;credentials&#125;</span></span><br><span class="hljs-string">     &#123; &quot;foo&quot;: <span class="hljs-subst">$&#123;foo&#125;</span>,</span><br><span class="hljs-string">       &quot;bar&quot;: <span class="hljs-subst">$&#123;bar&#125;</span>&#125;`</span>(myOnReadyStateChangeHandler);<br><br></code></pre></td></tr></table></figure><h3 id="对象">对象<a class="header-anchor" href="#对象">⁍</a></h3><h4 id="对象的创建">对象的创建<a class="header-anchor" href="#对象的创建">⁍</a></h4><p>有两种简单方法可以创建一个空对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure><p>和：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br></code></pre></td></tr></table></figure><p>这两种方法在语义上是相同的。第二种更方便的方法叫作“对象字面量（object literal）”法。</p><h4 id="读取对象属性">读取对象属性<a class="header-anchor" href="#读取对象属性">⁍</a></h4><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p><p>注意，数值键名不能使用点运算符，只能使用方括号运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&quot;alpha&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;two&quot;</span>&#125;;<br><span class="hljs-built_in">console</span>.log(foo.a);    <span class="hljs-comment">// alpha</span><br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-number">2</span>]);   <span class="hljs-comment">// two</span><br><span class="hljs-comment">//console.log(foo.2);  // SyntaxError: missing ) after argument list</span><br><span class="hljs-comment">//console.log(foo[a]); // ReferenceError: a is not defined</span><br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-string">&quot;a&quot;</span>]); <span class="hljs-comment">// alpha</span><br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-string">&quot;2&quot;</span>]); <span class="hljs-comment">// two</span><br></code></pre></td></tr></table></figure><ul><li>支持链式访问</li></ul><h4 id="其他">其他<a class="header-anchor" href="#其他">⁍</a></h4><ul><li>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</li><li><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</li><li><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值）</li><li><code>for...in</code>循环用来遍历一个对象的全部键。<ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性（<code>toString</code>属性）。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。<ul><li>一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</li></ul></li></ul></li><li><code>with</code>语句：操作同一个对象的多个属性时，提供一些书写的方便。</li></ul><p>关于对象和原型的详情参见： <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Object.prototype</a>. 解释对象原型和对象原型链可以参见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链</a>。</p><h3 id="数组">数组<a class="header-anchor" href="#数组">⁍</a></h3><ul><li><p><strong>数组就是键值为下标的对象</strong></p></li><li><p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p></li></ul><p>如果想在数组后追加元素，只需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">a.push(item);<br></code></pre></td></tr></table></figure><p>也可以直接通过下标添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a[<span class="hljs-number">5</span>]=<span class="hljs-number">2</span>;<br>a<br><span class="hljs-comment">// [ 1, 2, 3, 1, &lt;1 empty item&gt;, 2 ]</span><br></code></pre></td></tr></table></figure><h4 id="数组的空位">数组的空位<a class="header-anchor" href="#数组的空位">⁍</a></h4><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var a = [1, , 1];<br>a.length // 3<br></code></pre></td></tr></table></figure><ul><li><p>上面代码表明，数组的空位不影响<code>length</code>属性。虽然这个位置没有值，引擎依然认为这个位置是有效的。</p></li><li><p>数组的空位是可以读取的，返回<code>undefined</code>。</p><ul><li>但是给数组某一位赋值<code>undefined</code>不代表那一位为空，详见下面的示例</li></ul></li><li><p>使用<code>delete a[i]</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p></li></ul><p>遍历有空位的数组时，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。但是使用<code>for...of</code>结构就不会。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js">a = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,,<span class="hljs-number">1</span>]<br>b = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---- for...in ----&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">in</span> a) &#123;<br>    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// index</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---- forEach ----&#x27;</span>);<br>a.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(element);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---- Object.keys ----&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(a));<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---- for...of ----&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> a) &#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---- undefined ----&#x27;</span>);<br>b.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(element);<br>&#125;);<br><br><span class="hljs-comment">// result:</span><br><span class="hljs-comment">// ---- for...in ----</span><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// ---- forEach ----</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// ---- Object.keys ----</span><br><span class="hljs-comment">// [ &#x27;0&#x27;, &#x27;1&#x27;, &#x27;3&#x27; ]</span><br><span class="hljs-comment">// ---- for...of ----</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// undefined</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// ---- undefined ----</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// undefined</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array 方法的完整文档 (mozilla.org)</a></p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>a.toString()</code></td><td style="text-align:left">返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。</td></tr><tr><td style="text-align:left"><code>a.toLocaleString()</code></td><td style="text-align:left">根据宿主环境的区域设置，返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。</td></tr><tr><td style="text-align:left"><code>a.concat(item1[, item2[, ...[, itemN]]])</code></td><td style="text-align:left">返回一个数组，这个数组包含原先 <code>a</code> 和 <code>item1、item2、……、itemN</code> 中的所有元素。（和push不同的是，它可以添加多个数组形式的数，也可以直接添加多个数）</td></tr><tr><td style="text-align:left"><code>a.join(sep)</code></td><td style="text-align:left">返回一个包含数组中所有元素的字符串，每个元素通过指定的 <code>sep</code> 分隔。</td></tr><tr><td style="text-align:left"><code>a.pop()</code></td><td style="text-align:left">删除并返回数组中的最后一个元素。</td></tr><tr><td style="text-align:left"><code>a.push(item1, ..., itemN)</code></td><td style="text-align:left">将 <code>item1、item2、……、itemN</code> 追加至数组 <code>a</code>。</td></tr><tr><td style="text-align:left"><code>a.reverse()</code></td><td style="text-align:left">数组逆序（会更改原数组 <code>a</code>）。</td></tr><tr><td style="text-align:left"><code>a.shift()</code></td><td style="text-align:left">删除并返回数组中第一个元素。（相当于 <strong>出队</strong> ）</td></tr><tr><td style="text-align:left"><code>a.slice(start, end)</code></td><td style="text-align:left">返回子数组，以 <code>a[start]</code> 开头，以 <code>a[end]</code> 前一个元素结尾。</td></tr><tr><td style="text-align:left"><code>a.sort([cmpfn])</code></td><td style="text-align:left">依据可选的比较函数 <code>cmpfn</code> 进行排序，如果未指定比较函数，则按字符顺序比较（即使被比较元素是数字）。</td></tr><tr><td style="text-align:left"><code>a.splice(start, delcount[, item1[, ...[, itemN]]])</code></td><td style="text-align:left">从 <code>start</code> 开始，删除 <code>delcount</code> 个元素，然后插入所有的 <code>item</code>。</td></tr><tr><td style="text-align:left"><code>a.unshift(item1[, item2[, ...[, itemN]]])</code></td><td style="text-align:left">将 <code>item</code> 插入数组头部，返回数组新长度（考虑 <code>undefined</code>）。</td></tr></tbody></table><h2 id="控制、循环与迭代">控制、循环与迭代<a class="header-anchor" href="#控制、循环与迭代">⁍</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration">循环与迭代 - JavaScript | MDN (mozilla.org)</a></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for_%E8%AF%AD%E5%8F%A5"><code>for</code> 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#do...while_%E8%AF%AD%E5%8F%A5"><code>do...while</code> 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#while_%E8%AF%AD%E5%8F%A5"><code>while</code> 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#label_%E8%AF%AD%E5%8F%A5"><code>label</code> 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#break_%E8%AF%AD%E5%8F%A5"><code>break</code> 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#continue_%E8%AF%AD%E5%8F%A5"><code>continue</code> 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...in_%E8%AF%AD%E5%8F%A5"><code>for...in</code> 语句</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_%E8%AF%AD%E5%8F%A5"><code>for...of</code> 语句</a></li></ul><h3 id="lable语句"><code>lable</code>语句<a class="header-anchor" href="#lable语句">⁍</a></h3><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。<sup class="footnote-ref"><a href="#fn8" id="fnref8:1">[8:1]</a></sup></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">label:<br>  语句<br></code></pre></td></tr></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">top:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> top;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br></code></pre></td></tr></table></figure><h3 id="for-in语句"><code>for...in</code>语句<a class="header-anchor" href="#for-in语句">⁍</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 语句循环一个指定的变量来循环一个对象所有可枚举的属性。</p><p>Js里不推荐使用<code>for..in</code>来迭代数组，如果你想改变数组对象，比如添加属性或者方法，<strong>for…in</strong> 语句迭代的是自定义的属性，而不是数组的元素。<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup></p><blockquote><p>这里注意和python的区别，迭代数组的话 <code>for...of</code> 语句，和 <code>forEach()</code>，是理想的选择。</p></blockquote><h3 id="for-of语句"><code>for...of</code>语句<a class="header-anchor" href="#for-of语句">⁍</a></h3><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">可迭代对象</a>（包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a> 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。</p><p><code>for...in</code> 循环遍历的结果是数组元素的下标，而 <code>for...of</code> 遍历的结果是元素的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<br>arr.foo = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 输出 &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 注意 for...of 的输出没有出现 &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h3 id="foreach"><code>forEach()</code><a class="header-anchor" href="#foreach">⁍</a></h3><p><a href="https://z.itpub.net/article/detail/26AAA844E21AC59E19E80FB00570FCCE">面试官：有了 for 循环 为什么还要 forEach ？ - 文章详情 (itpub.net)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array.prototype.forEach() - JavaScript | MDN (mozilla.org)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;hen&quot;</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, array</span>) </span>&#123;<br>  <span class="hljs-comment">// 操作 currentValue 或者 array[index]</span><br>&#125;);<br><br><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>colors.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(color);<br>&#125;);<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br></code></pre></td></tr></table></figure><div class="note danger flat"><p><a href="https://segmentfault.com/a/1190000040163287">For循环中的let和var - SegmentFault 思否</a></p></div><h2 id="异常处理">异常处理<a class="header-anchor" href="#异常处理">⁍</a></h2><p>详见<sup class="footnote-ref"><a href="#fn13" id="fnref13:1">[13:1]</a></sup></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">openMyFile();<br><span class="hljs-keyword">try</span> &#123;<br>    writeMyFile(theData); <span class="hljs-comment">//This may throw a error</span><br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>    handleError(e); <span class="hljs-comment">// If we got a error we handle it</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    closeMyFile(); <span class="hljs-comment">// always close the resource</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果<code>finally</code>块返回一个值，该值会是整个<code>try-catch-finally</code>流程的返回值，不管在<code>try</code>和<code>catch</code>块中语句返回了什么</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://wangdoc.com/javascript/index.html">JavaScript 教程 - 网道 (wangdoc.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>《JavaScript权威指南》 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://www.bilibili.com/video/BV18a4y1L7kD?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">微软官方 JavaScript 入门教程【完结撒花】_哔哩哔哩_bilibili</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript | MDN (mozilla.org)</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>《前端程序员面试笔试通关宝典》 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript">什么是 JavaScript？ - 学习 Web 开发 | MDN (mozilla.org)</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types</a> <a href="#fnref7" class="footnote-backref">↩︎</a> <a href="#fnref7:1" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p><a href="https://wangdoc.com/javascript/basic/grammar.html">JavaScript 的基本语法 - JavaScript 教程 - 网道 (wangdoc.com)</a> <a href="#fnref8" class="footnote-backref">↩︎</a> <a href="#fnref8:1" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript">重新介绍 JavaScript（JS 教程） - JavaScript | MDN (mozilla.org)</a> <a href="#fnref9" class="footnote-backref">↩︎</a> <a href="#fnref9:1" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%AD%97%E9%9D%A2%E9%87%8F_literals">语法和数据类型 - JavaScript | MDN (mozilla.org)</a> <a href="#fnref10" class="footnote-backref">↩︎</a> <a href="#fnref10:1" class="footnote-backref">↩︎</a></p></li><li id="fn11" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#%E6%95%B0%E5%AD%97">重新介绍 JavaScript（JS 教程） - JavaScript | MDN (mozilla.org)</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p></li><li id="fn12" class="footnote-item"><p><a href="https://wangdoc.com/javascript/types/number.html">数值 - JavaScript 教程 - 网道 (wangdoc.com)</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p></li><li id="fn13" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5">流程控制与错误处理 - JavaScript | MDN (mozilla.org)</a> <a href="#fnref13" class="footnote-backref">↩︎</a> <a href="#fnref13:1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSS】格式化上下文</title>
      <link href="/augu1sto/5888660a1014/"/>
      <url>/augu1sto/5888660a1014/</url>
      
        <content type="html"><![CDATA[<div class="note flat"><p>参考MDN文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts">Introduction to formatting contexts 格式化上下文简介 - CSS（层叠样式表） | MDN (mozilla.org)</a></p></div><p>格式化的意思是, 在这个环境中元素应当被初始化, 初始化的过程就是元素在此环境中的布局过程<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>格式化上下文</p><ul><li>块格式化上下文 BFC</li><li>内联格式化上下文 IFC</li><li>灵活（flex）格式化上下文 FFC</li></ul><h2 id="块格式化上下文-bfc">块格式化上下文 BFC<a class="header-anchor" href="#块格式化上下文-bfc">⁍</a></h2><h3 id="bfc布局原则">BFC布局原则<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><a class="header-anchor" href="#bfc布局原则">⁍</a></h3><ul><li>第1条：内部的Box会在垂直方向，一个接一个地放置。</li><li>第2条：Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>第3条：每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<ul><li>导致样例2的出现</li></ul></li><li>第4条：BFC的区域不会与float box重叠。</li><li>第5条：BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>第6条：计算BFC的高度时，浮动元素也参与计算</li></ul><hr><p>文档最外层元素（<code>&lt;html&gt;</code>元素）使用块布局规则</p><p>新的BFC的行为与最外层的文档非常相似，它 <strong>在主布局中创造了一个小布局</strong> 。</p><p>下列方式会创建 <strong>块格式化上下文</strong> ：</p><h3 id="创建bfc">创建BFC<a class="header-anchor" href="#创建bfc">⁍</a></h3><ul><li>根元素（<code>&lt;html&gt;）</code></li><li>浮动元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 不是 <code>none</code>）</li><li>绝对定位元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li><li>行内块元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>inline-block</code>）</li><li>表格单元格（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li><li>表格标题（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li><li>匿名表格单元格元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 计算值(Computed)不为 <code>visible</code> 的块元素</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flow-root</code> 或<code>flow-root list-item</code>的元素</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 值为 <code>layout</code>、<code>content </code>或 paint 的元素</li><li>弹性元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>flex</code> 或 <code>inline-flex </code>元素的直接子元素）（flex-items）</li><li>网格元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li><li>多列容器（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a> 不为 <code>auto</code>，包括 <code>column-count</code> 为 <code>1</code>）</li><li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">标准变更</a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>）。</li></ul><p>块格式化上下文包含创建它的元素内部的所有内容</p><h3 id="bfc与浮动">BFC与浮动<a class="header-anchor" href="#bfc与浮动">⁍</a></h3><p>块格式化上下文对浮动定位（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>）与清除浮动（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a>）都很重要。</p><p>浮动定位和清除浮动时只会应用于 <strong>同一个BFC内 的元素</strong> 。</p><p>浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。</p><p>外边距折叠（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">Margin collapsing</a>）也只会发生在属于同一BFC的块级元素之间。</p><h4 id="范例1：让父元素包含子浮动元素，清除内部浮动。（防止子元素设置浮动后，父元素高度塌陷collapse）">范例1：让父元素包含子浮动元素，清除内部浮动。（防止子元素设置浮动后，父元素高度塌陷collapse）<a class="header-anchor" href="#范例1：让父元素包含子浮动元素，清除内部浮动。（防止子元素设置浮动后，父元素高度塌陷collapse）">⁍</a></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context#%E8%AE%A9%E6%B5%AE%E5%8A%A8%E5%86%85%E5%AE%B9%E5%92%8C%E5%91%A8%E5%9B%B4%E7%9A%84%E5%86%85%E5%AE%B9%E7%AD%89%E9%AB%98">让浮动内容和周围的内容等高 (mozilla.org)</a></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682ed62251d04df2b5391c73b7a30fa0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="BFC作用之清除内部浮动.png"></p><p>解决浮动脱离文档流的情况给浮动的父元素容器添加属性<code>overflow:auto</code>或者<code>display:flow-root</code></p><h5 id="overflow-auto"><code>overflow: auto</code><a class="header-anchor" href="#overflow-auto">⁍</a></h5><p>创建一个会包含这个浮动的 BFC，通常的做法是设置父元素 <code>overflow: auto</code> 或者设置其他的非默认的 <code>overflow: visible</code> 的值。</p><p><strong>副作用：</strong> 可能会发现一些不想要的问题，比如滚动条或者一些剪切的阴影</p><h5 id="display-flow-root"><code>display: flow-root</code><a class="header-anchor" href="#display-flow-root">⁍</a></h5><p>在父级块中使用 <code>display: flow-root</code> 可以创建新的 BFC。是一种显示创建方法，无副作用。</p><p>实际上是在创建一个行为类似于根元素 （浏览器中的<code>&lt;html&gt;</code>元素） 的东西。</p><blockquote><p>或许可以说<code>display: flow-root</code>就是为了创建新的BFC而存在的？</p><p>使用<code>display: flow-root</code> ，该容器内的所有内容都参与该容器的块格式上下文，并且浮动不会从元素底部弹出。</p><p><code>flow-root</code> 关键字的意义是，创建的内容本质上类似于一个新的根元素（如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html">``</a>所做），并确定这个新的上下文如何创建及其流布局如何实现。</p></blockquote><h4 id="范例2：防止元素被浮动元素覆盖">范例2：防止元素被浮动元素覆盖<a class="header-anchor" href="#范例2：防止元素被浮动元素覆盖">⁍</a></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context#exclude_external_floats">Exclude external floats</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e9ec7325ad54bb0baaf9f79b141be47~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="BFC作用之元素覆盖问题.png"></p><p>设置容器A的属性为<code>display: flow-root</code>或者<code>overflow:hidden</code>等方法，使当前与浮动元素重叠的容器A分离</p><p><strong>适用场景：</strong> 自适应两（三）栏布局（避免多列布局由于宽度计算四舍五入而自动换行）</p><h4 id="范例3：防止外边距重叠（collapse）">范例3：防止外边距重叠（collapse）<a class="header-anchor" href="#范例3：防止外边距重叠（collapse）">⁍</a></h4><p><a href="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/Guide/CSS/Block_formatting_context/_sample_.margin_collapsing.html">块格式化上下文 - margin_collapsing - code sample (mozit.cloud)</a></p><ul><li><strong>解决方法</strong>：给任意一个子元素的外侧包裹一个块级元素，并为这个块级元素设置<code>overflow:hidden</code></li><li>注意：应该避免这样添加margin，尽量在同一个方向给元素添加，例如：都添加顶部margin</li></ul><h4 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h4><p><strong>BFC的两个功能：</strong></p><ul><li>父元素包裹住子元素</li><li>兄弟元素之间划清界限</li></ul><h2 id="行内格式化上下文-ifc"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Inline_formatting_context">行内格式化上下文 IFC</a><a class="header-anchor" href="#行内格式化上下文-ifc">⁍</a></h2><p>当块容器盒（block container box）不包括任何块级盒（block-level boxes）时，就会创建一个行内格式化上下文（IFC）。</p><p>段落创建了一个内联格式上下文，其中在文本中使用诸如 <code>&lt;strong&gt;</code>/<code>&lt;a&gt;</code>/<code>&lt;span&gt;</code>元素等内容</p><h3 id="核心概念">核心概念<a class="header-anchor" href="#核心概念">⁍</a></h3><p>行内格式化上下文是一个网页的渲染结果的一部分。其中，各行内框（inline boxes）根据书写模式（writing-mode）顺序排列</p><ul><li>对于水平书写模式，各个框从左边开始水平地排列</li><li>对于垂直书写模式，各个框从顶部开始水平地排列</li></ul><h4 id="行框与行内框：">行框与行内框：<a class="header-anchor" href="#行框与行内框：">⁍</a></h4><p>行框的大小将足以包含该行中所有的行内框（inline boxes）。一个段落实际上是一系列行框的集合，这些行框在块的方向上排列。</p><p>如果一个行内框要换行， margins, borders, 以及 padding 的设定均不会在断裂处生效。</p><p><img src="https://i.bmp.ovh/imgs/2022/04/01/427e7426f6e31ccb.png" alt=""></p><h3 id="在块的方向上对齐">在块的方向上对齐<a class="header-anchor" href="#在块的方向上对齐">⁍</a></h3><p>行内框（Inline boxes）可使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align"><code>vertical-align</code></a>属性，以不同的方式在块的方向上进行对齐</p><p>（与书写方向垂直）</p><p>取值：<code>top</code>/<code>bottom</code>/<code>middle</code>/<code>baseline</code></p><p><img src="https://i.bmp.ovh/imgs/2022/04/01/eaf2d8892ef11b90.png" alt=""></p><h3 id="在行内方向上对齐">在行内方向上对齐<a class="header-anchor" href="#在行内方向上对齐">⁍</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a> 可用于将各行内框（inline boxes）在行框（line box）内对齐。</p><p><code>start</code>/<code>end</code>/<code>left</code>/<code>right</code>/<code>center</code></p><h3 id="浮动造成的效果">浮动造成的效果<a class="header-anchor" href="#浮动造成的效果">⁍</a></h3><p>如果同一个块格式化上下文中存在一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>，则这个浮动元素将导致包裹了文本的各行框变短。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span>I am a floated box!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am content inside the container.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.bmp.ovh/imgs/2022/04/01/5c2ca9d4291c81bc.png" alt=""></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://tink.gitbooks.io/fe-collections/content/ch03-css/formatting-context.html">格式化上下文 | 前端知识手册 (gitbooks.io)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://juejin.cn/post/7029622804739784717">BFC(边距重叠解决方案) - 掘金 (juejin.cn)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSS】nth-child和nth-of-type的区别</title>
      <link href="/augu1sto/0259cd9b6703/"/>
      <url>/augu1sto/0259cd9b6703/</url>
      
        <content type="html"><![CDATA[<p>两个都可以选择元素的兄弟节点</p><p>不同的是<code>nth-of-type</code>规则作用的范围是与元素类型一致的兄弟节点</p><p><code>nth-child</code>规则作用的范围是所有兄弟节点（选择了范围之后，再判断是否与元素类型一致）</p><p>示例： <a href="https://codepen.io/augu1sto/pen/XWVaQRy">在线查看</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-comment">/* 不起作用，因为第三个不是p标签 */</span></span><br><span class="css"><span class="hljs-selector-class">.test01</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>)&#123;</span><br><span class="css">  <span class="hljs-attribute">color</span>: red;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.test01</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>)&#123;</span><br><span class="css">  <span class="hljs-attribute">color</span>: red;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.test02</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>)&#123;</span><br><span class="css">  <span class="hljs-attribute">color</span>:red;</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test01&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>try<span class="hljs-symbol">&amp;nbsp;</span>nth-child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1st p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>I&#x27;m not p!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2st p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3st p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test02&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>try<span class="hljs-symbol">&amp;nbsp;</span>nth-of-type<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1st p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>I&#x27;m not p!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2st p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3st p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-CSS】CSS布局</title>
      <link href="/augu1sto/4e4d47a5c8d7/"/>
      <url>/augu1sto/4e4d47a5c8d7/</url>
      
        <content type="html"><![CDATA[<h2 id="正常布局流normal-flow">正常布局流normal flow<a class="header-anchor" href="#正常布局流normal-flow">⁍</a></h2><p>浏览器默认的HTML布局方式</p><blockquote><p>块方向/内联方向</p><p>块方向在英语等具有水平<strong>书写模式</strong>(<code>writing mode</code>)的语言中垂直运行。它可以在任何垂直书写模式的语言中水平运行。对应的<strong>内联方向</strong>是内联内容（如句子）的运行方向。</p></blockquote><p>display、浮动、position、表格布局和多列布局都会覆盖默认布局</p><h2 id="display">display<a class="header-anchor" href="#display">⁍</a></h2><ul><li>基础值： <code>block</code>/<code>inline</code>/<code>inline-block</code> (见盒模型)</li><li>全新布局方式：<code>flex</code>/<code>grid</code></li></ul><h3 id="弹性盒子flex">弹性盒子flex<a class="header-anchor" href="#弹性盒子flex">⁍</a></h3><p><code>display: flex</code></p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png" alt="flex_terms.png"></p><ul><li><strong>主轴：</strong> 沿flex元素放置方向延伸的轴：<code>flex-direction:column/row</code><ul><li><code>row-reverse</code>/<code>column-reverse</code>可以反向排向flex项</li></ul></li><li><strong>交叉轴：</strong> 垂直于flex元素垂直方向的轴</li><li><code>flex-wrap: wrap</code>：防止溢出</li><li>简写：<code>flex-flow: row wrap</code></li><li>可以嵌套使用</li></ul><h4 id="flex项">flex项<a class="header-anchor" href="#flex项">⁍</a></h4><p>给每个flex项添加属性，<code>flex: 数值</code>表示每一项占的属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>指定 flex 的最小值。每个flex 项将首先给出200px的可用空间，然后，剩余的可用空间将根据分配的比例共享。</p></li><li><p><code>flex-grow</code>：规定了 <code>flex-grow</code> 项在 flex 容器中分配剩余空间的相对比例。剩余空间是 flex 容器的大小减去所有 flex 项的大小加起来的大小。如果所有的兄弟项目都有相同的 flex-grow 系数，那么所有的项目将剩余空间按相同比例分配，否则将根据不同的 flex-grow 定义的比例进行分配。</p></li><li><p><code>flex-shrink</code>：指定了 flex 元素的收缩比例</p></li><li><p><code>flex-basis</code>：即上面说的最小值（基础值）</p></li></ul><h4 id="水平和垂直对齐">水平和垂直对齐<a class="header-anchor" href="#水平和垂直对齐">⁍</a></h4><h5 id="交叉轴上的位置（按行排列的垂直方向）">交叉轴上的位置（按行排列的垂直方向）<a class="header-anchor" href="#交叉轴上的位置（按行排列的垂直方向）">⁍</a></h5><p>容器属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 控制 flex 项在 <strong>交叉轴</strong> 上的位置。</p><ul><li><code>stretch</code>  default，拉伸填充容器，如果父容器没有固定大小，则会与最高的flex项保持一致</li><li><code>center</code>/<code>flex-start</code>/<code>flex-end</code></li></ul><p>flex项设置<code>align-self</code>可以覆盖<code>align-items</code>的行为</p><h5 id="主轴上的位置（按行排列的水平方向）">主轴上的位置（按行排列的水平方向）<a class="header-anchor" href="#主轴上的位置（按行排列的水平方向）">⁍</a></h5><p>容器属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content"><code>justify-content</code></a> 控制 flex 项在 <strong>主轴</strong> 上的位置。</p><ul><li><code>flex-start</code> default / <code>flex-end</code>/<code>center</code></li><li><code>space-around</code>均匀分布，默认整体居中</li><li><code>space-between</code>均匀分布，两端不留空间，默认从start开始</li></ul><h4 id="flex项排序">flex项排序<a class="header-anchor" href="#flex项排序">⁍</a></h4><p>可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）</p><p><strong>通过给flex项设置<code>order</code>属性实现</strong></p><ul><li>默认是0，小的在前面，也就是说其他元素默认的情况下</li><li>设置为1会将当前元素放到最后</li><li>设置为-1会将当前元素放到最前面</li></ul><h3 id="网格grid">网格Grid<a class="header-anchor" href="#网格grid">⁍</a></h3><p><code>display: grid</code></p><ul><li><p>基础概念：<code>row</code>/<code>colunm</code>/<code>gutter</code>（沟槽即间隔）</p></li><li><p>单位：<code>fr</code>，表示可用空间的一个比例</p></li><li><p>网格间隙：<code>grid-gap</code>（单位不能用fr）（<code>grid-row/column-gap</code>）（直接写gap就行了）</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 函数可以为一个行/列的尺寸设置了取值范围</p></li><li><p>一个网格排版框架一般由12到16列的网格构成</p></li><li><p>放置元素时如果重叠，HTML里定义在后面的元素会覆盖前面的元素；但可以用<code>order</code>或者<code>z-index</code>来调整顺序</p></li></ul><h4 id="显式网格与隐式网格">显式网格与隐式网格<a class="header-anchor" href="#显式网格与隐式网格">⁍</a></h4><ul><li>显式网格是我们用<code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。</li><li>隐式网格则是当有内容被放到网格外时才会生成的。隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显式网格自动生成的网格部分。</li><li>隐式网格中生成的行/列大小是参数默认是<code>auto</code>，大小会根据放入的内容自动调整。可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows"><code>grid-auto-rows</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns"><code>grid-auto-columns</code></a>属性手动设定隐式网格的大小。</li></ul><h4 id="创建显示网格">创建显示网格<a class="header-anchor" href="#创建显示网格">⁍</a></h4><p>以列为例</p><ul><li>基础用法：<code>grid-template-columns: 2fr 1fr 1fr</code></li><li>重复构建：<code>grid-template-columns: repeat(3, 1fr)</code> / <code>grid-template-columns: repeat(2, 2fr 1fr)</code></li><li>自动使用多列填充：<code>grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));</code></li></ul><h4 id="基于网格线放置元素">基于网格线放置元素<a class="header-anchor" href="#基于网格线放置元素">⁍</a></h4><p><code>F12</code>选择布局里的<code>网格覆盖</code>，可以查看网格线</p><p><code>grid-column/row-start/end</code></p><p>或者简写为 <code>grid-column: start / end</code> 用<code>/</code>隔开</p><p>用定义网格线的方法可以将元素放置在网格中</p><p>或者用<code>span 数字</code>指定该行/列占几格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">header</span> &#123;<br>  grid-column: span <span class="hljs-number">2</span>;<br>  grid-row: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  grid-column: <span class="hljs-number">2</span>;<br>  grid-row: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  grid-column: <span class="hljs-number">1</span>;<br>  grid-row: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  grid-column: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  grid-row: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用grid-template-areas属性放置元素">使用grid-template-areas属性放置元素<a class="header-anchor" href="#使用grid-template-areas属性放置元素">⁍</a></h4><p>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas"><code>grid-template-areas</code></a>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-areas:<br>      <span class="hljs-string">&quot;header header&quot;</span><br>      <span class="hljs-string">&quot;sidebar content&quot;</span><br>      <span class="hljs-string">&quot;footer footer&quot;</span>;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">3</span>fr;<br>  grid-gap: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用<code>grid-area</code>为相应的元素赋予对应的区域名称</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">header</span> &#123;<br>  grid-area: header;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>grid-template-areas</code>属性的使用规则如下：</p><ul><li>你需要填满网格的每个格子</li><li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li><li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li><li>一个连续的区域必须是一个矩形</li><li>使用<code>.</code>符号，让一个格子留空</li></ul><h2 id="浮动float">浮动float<a class="header-anchor" href="#浮动float">⁍</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性有四个可能的值：<code>left</code>/<code>right</code>/<code>none</code>(default)/<code>inherit</code></p><p>例如：首字下沉</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3em</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果页面上第二个和第三个div的float都是right</p><p>则因为第二个div在先，最右边的会是div2</p><h3 id="清除浮动">清除浮动<a class="header-anchor" href="#清除浮动">⁍</a></h3><p>问题——所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装，如果没有处理这些元素，就会变得很糟糕。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 属性</p><ul><li><code>left</code>：停止任何活动的左浮动</li><li><code>right</code>：停止任何活动的右浮动</li><li><code>both</code>：停止任何活动的左右浮动</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合下面的问题，应该</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clearfix&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>foot<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上可以直接用伪元素选择器来清除浮动（适合浮动元素有父容器单独包裹的情况）</p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;black&quot;</span>&gt;</span>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus sit amet diam. Duis mattis varius dui. Suspendisse eget dolor. Fusce pulvinar lacus ac dui.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus sit amet diam. Duis mattis varius dui. Suspendisse eget dolor.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;both&quot;</span>&gt;</span>This paragraph clears both.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;.&quot;</span>;<span class="hljs-comment">/*可以使用\200B零宽度空格，这样不用设置visibility*/</span><br>    <span class="hljs-attribute">clear</span>: both;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.wrapper</span>&#123; <span class="hljs-comment">/*兼容IE6-7*/</span><br>    *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮动问题">浮动问题<a class="header-anchor" href="#浮动问题">⁍</a></h3><ol><li><p>如果浮动框有内边距外边距边框等样式，布局可能损坏</p><p>可以使用<code>box-sizing: border-box</code> 通过更改盒模型来使得盒子的宽度包含content + padding + border，而不仅是之前的content</p></li><li><p>因为浮动的元素存在于正常的文档布局流之外：</p><ul><li><p>在父元素中所占的面积的有效高度为0</p></li><li><p>非浮动元素的外边距不能用于它们和浮动元素之间来创建空间</p><blockquote><p>为浮动元素后面的清除了浮动的其他元素（如footer）添加顶部外边距时不起作用的</p><p><strong>解决方法：</strong> 在需要清除浮动的元素前加一个空的div，将这个div的浮动清除</p><p><a href="https://mdn.github.io/learning-area/css/css-layout/floats/4_fixed-layout-border-box.html">Fixed layout border-box (mdn.github.io)</a></p></blockquote></li><li><p><a href="https://css-tricks.com/all-about-floats/">more</a></p></li></ul></li><li><p>浮动项目的背景高度不同</p><ul><li>设定固定的<code>height</code>（必要时可以加上<code>overflow: auto/scroll</code>使内容滚动）</li><li>将背景颜色都设置为父元素的背景颜色</li><li><mark>伪列技术</mark></li></ul></li></ol><p>浮动和BFC密不可分，要熟悉BFC部分</p><h2 id="定位">定位<a class="header-anchor" href="#定位">⁍</a></h2><p>定位(positioning)能够让我们把一个元素从它原本在正常布局流(normal flow)中应该在的位置移动到另一个位置。</p><h3 id="分类">分类<a class="header-anchor" href="#分类">⁍</a></h3><p>示例：<a href="https://mdn.github.io/learning-area/css/css-layout/positioning/0_basic-flow.html">Basic document flow</a></p><ol><li><strong>静态定位(Static positioning)</strong> ： 默认的属性，将元素放在文档布局流的默认位置</li></ol><ul><li><a href="https://mdn.github.io/learning-area/css/css-layout/positioning/1_static-positioning.html">Static positioning </a> <code>position: static;</code></li></ul><ol start="2"><li><strong>相对定位(Relative positioning)</strong> ：相对于元素在正常的文档流中的 <strong>默认位置</strong> 偏移（对于微调和精准设计(design pinpointing)非常有用）</li></ol><ul><li><code>position: relative;</code></li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom"><code>bottom</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a>, 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/right"><code>right</code></a> 来精确指定要将定位元素移动到的位置。（<code>top</code>就是说相对于顶端向下偏移xxpx）</li><li>示例： <a href="https://mdn.github.io/learning-area/css/css-layout/positioning/2_relative-positioning.html">Relative positioning </a></li></ul><ol start="3"><li><strong>绝对定位(Absolute positioning)</strong> ： 元素完全从页面的正常布局流(normal layout flow)中移出，放入单独的图层。相对于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html"><code>&lt;html&gt;</code></a> 元素或其最近的定位祖先⭐</li></ol><ul><li><p><code>position: absolute;</code></p></li><li><p>不再存在于正常文档布局流中，不干扰页面上其他元素的位置的隔离</p></li><li><p><code>left</code>/<code>right</code>/<code>top</code>/<code>bottom</code>指定元素应距离每个包含元素的边的距离</p><ul><li>都指定为0实际上会占满页面，但是如果为该元素指定大小，也会生效</li><li>margins 仍会影响定位的元素。 然而margin collapsing不会。</li></ul></li><li><p><strong>定位上下文：</strong> 默认会被包含在 <strong>初始块容器</strong> 中。简单来说，绝对定位元素会被放在<code>&lt;html&gt;</code>元素的外面，并且根据浏览器视口来定位。</p><ul><li><p>设置 绝对定位元素 的 父元素 的定位属性（不为<code>static</code>即可）</p><blockquote><p>和BFC没有关系，因为将父容器设置为<code>display: flow-root</code>并不能改变定位基准</p></blockquote></li><li><p>示例：<a href="https://mdn.github.io/learning-area/css/css-layout/positioning/4_positioning-context.html">Positioning context (mdn.github.io)</a></p></li></ul></li><li><p>示例： <a href="https://mdn.github.io/learning-area/css/css-layout/positioning/3_absolute-positioning.html">Absolute positioning </a></p></li></ul><ol start="4"><li><p><strong>固定定位(Fixed positioning)</strong> ：元素相对浏览器视口固定</p><ul><li><code>position: fixed;</code></li><li>常用于创建持久导航菜单</li><li>设置为<code>fixed</code>的元素不在文档流中，后面的内容会向上移动，因此可能会挡住后面的内容，可以给 <strong>后面紧跟的内容</strong> 设置上边距解决</li><li>示例：<a href="https://mdn.github.io/learning-area/css/css-layout/positioning/6_fixed-positioning.html">Fixed positioning (mdn.github.io)</a></li></ul></li><li><p><strong>粘性定位(Sticky positioning)</strong> ：让元素先保持和相对定位一样的定位(*)，当它的相对视口位置(offset from the viewport)达到某一个预设值时，他就会像<code>position: fixed</code>一样定位。</p><ul><li><code>position: sticky;</code></li><li>基本上是相对位置和固定位置的混合体</li><li>示例：<a href="https://mdn.github.io/learning-area/css/css-layout/positioning/7_sticky-positioning.html">Sticky positioning (mdn.github.io)</a></li><li>将<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>的值设置为0，当标题滚动到视口的顶部时，支持此属性的浏览器会将标题粘贴到那个位置。随后，每个后续标题将替换前一个标题，直到它向上滚动到该位置。</li></ul><div class="note 疑问 flat"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Introduction#%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D">粘性定位 (mozilla.org)</a>中说的是将静态定位与固定定位混合，<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning#%E4%BB%8B%E7%BB%8D%E5%AE%9A%E4%BD%8D">定位 - 学习 Web 开发 | MDN (mozilla.org)</a>中说的是相对定位和固定定位混合，</p></div></li></ol><h3 id="z-index">z-index<a class="header-anchor" href="#z-index">⁍</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index">理解CSS的 z-index属性 - CSS（层叠样式表） | MDN (mozilla.org)</a></p><p>出现覆盖时，决定z轴顺序： 数字越大， 元素越接近观察者，在上面。</p><p><strong>只对设置了定位的元素生效</strong> （<code>static</code>以外）</p><p>示例：<a href="https://mdn.github.io/learning-area/css/css-layout/positioning/5_z-index.html">z-index (mdn.github.io)</a></p><h2 id="表格布局">表格布局<a class="header-anchor" href="#表格布局">⁍</a></h2><div class="note flat"><p>表格布局并不是用table标签进行布局，相反，CSS默认给table标签设置了表格布局的属性。</p><p>也可以用对其他元素使用table layout</p></div><p><code>display: table-caption/table-row/table-cell;</code></p><p>通过以上来设置表格的标题，行和单元格的元素的布局</p><p>对于标题，还可以设置<code>caption-side: bottom/...</code>来调整标题的位置。</p><p>基本上，它们会像HTML表格标记一样，导致标签和输入在默认情况下排列整齐。</p><p>示例： <a href="https://mdn.github.io/learning-area/css/styling-boxes/box-model-recap/css-tables-example.html">CSS tables example (mdn.github.io)</a></p><h2 id="多列布局">多列布局<a class="header-anchor" href="#多列布局">⁍</a></h2><blockquote><p>多列布局不用设置display属性（默认是block）</p></blockquote><p>可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a>属性来告诉浏览器我们需要多少列，也可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a>来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。</p><p><code>column-gap</code>设置间隔，<code>column-rule</code>设置分割线ban样式（column-width: 200px;）</p><p>为了控制文字折断，可以利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Fragmentation">CSS分片 - CSS（层叠样式表） | MDN (mozilla.org)</a></p><p>添加属性<code>break-inside: avoid;</code>或<code>page-break-inside: avoid;</code></p><hr><h2 id="响应式设计">响应式设计<a class="header-anchor" href="#响应式设计">⁍</a></h2><p><em>responsive web design，RWD</em></p><ul><li>媒体查询</li><li>液态网格Fluid Grids</li><li>液态图像 <code>max-width: 100%</code></li></ul><h3 id="媒体查询">媒体查询<a class="header-anchor" href="#媒体查询">⁍</a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> media-type <span class="hljs-keyword">and</span> (media-feature-rule) &#123;<br>  <span class="hljs-comment">/* CSS rules go here */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它由以下部分组成：</p><ul><li><strong>媒体类型</strong> 告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；<ul><li><code>all</code></li><li><code>print</code></li><li><code>screen</code></li><li><code>speech</code></li></ul></li><li><strong>媒体表达式</strong> 是一个被包含的CSS生效所需的规则或者测试；<ul><li><code>max-width/min-width/min-height/max-height</code>等</li><li><code>orientation: portrait / landscape</code></li><li><code>hover:hover</code></li><li>and/or/not与或非</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries">see more</a></li></ul></li><li>一组CSS规则，会在测试通过且媒体类型正确的时候应用。</li></ul><p>断点：引入媒体查询的点</p><h3 id="现代布局技术">现代布局技术<a class="header-anchor" href="#现代布局技术">⁍</a></h3><ul><li>多列：指定<code>column-count</code>或<code>column-width</code></li><li>flex box伸缩盒</li><li>网格</li></ul><h3 id="响应式图像">响应式图像<a class="header-anchor" href="#响应式图像">⁍</a></h3><p>使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture"><code>&lt;picture&gt;</code></a>元素和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img"><code>&lt;img&gt;</code></a>元素的<code>srcset</code>和<code>sizes</code> 特性，解决了这两个问题。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图片 - see more)</a></p><h3 id="视口元标签与视口单位">视口元标签与视口单位<a class="header-anchor" href="#视口元标签与视口单位">⁍</a></h3><h4 id="视口元标签">视口元标签<a class="header-anchor" href="#视口元标签">⁍</a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>initial-scale</code>：设定了页面的初始缩放，我们设定为1。</li><li><code>height</code>：特别为视口设定一个高度。</li><li><code>minimum-scale</code>：设定最小缩放级别。（尽量避免）</li><li><code>maximum-scale</code>：设定最大缩放级别。（尽量避免）</li><li><code>user-scalable</code>：如果设为no的话阻止缩放。（不推荐）</li></ul><p><strong>永远都不要只用viewport单位设定文本</strong> ，会使用户失去放缩任何使用<code>vw</code>单位的文本的能力</p><p>可以用<code>calc</code>混合<code>vw</code>单位盒固定大小 <code>font-size: calc(1.5rem + 3vw);</code></p><p>MDN上的练习解： [FE-learning/MDN practice/layout/fundamental-layout-comprehension at main · Augu1sto/FE-learning (<a href="http://github.com">github.com</a>)](“<a href="https://github.com/Augu1sto/FE-learning/tree/main/MDN">https://github.com/Augu1sto/FE-learning/tree/main/MDN</a> practice/layout/fundamental-layout-comprehension”)</p>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-CSS】盒模型</title>
      <link href="/augu1sto/8bbf92a860de/"/>
      <url>/augu1sto/8bbf92a860de/</url>
      
        <content type="html"><![CDATA[<h2 id="block-box-和-inline-box">Block Box 和 Inline Box<a class="header-anchor" href="#block-box-和-inline-box">⁍</a></h2><p>这里讨论的是外部显示模型</p><table><thead><tr><th></th><th>块级</th><th>内联</th><th>inline-block</th></tr></thead><tbody><tr><td>设置<code>display</code></td><td><code>block</code></td><td><code>inline</code></td><td><code>inline-block</code></td></tr><tr><td>默认</td><td>标题/<code>p</code></td><td><code>&lt;a&gt;</code>/<code>&lt;span&gt;</code>/<code>&lt;em&gt;</code>/<code>&lt;strong&gt;</code></td><td>无（常用于导航栏）</td></tr><tr><td>是否换行</td><td>是</td><td>否</td><td>否</td></tr><tr><td><code>width</code>和<code>height</code>属性是否会发挥作用</td><td>是</td><td>否</td><td>是</td></tr><tr><td>垂直方向</td><td>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</td><td>会被应用，但不会把其他处于 <code>inline</code> 状态的盒子推开。</td><td>同块级</td></tr><tr><td>水平方向</td><td>同上</td><td>可以把其他处于 <code>inline</code> 状态的盒子推开。</td><td>同块级</td></tr></tbody></table><blockquote><ul><li>内部显示类型，它决定了盒子内部元素是如何布局的。可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。 如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。 该盒子的所有直接子元素都会成为flex元素.</li><li>Learn more: <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Block_and_Inline_Layout_in_Normal_Flow">常规流中的块和内联布局 - CSS（层叠样式表） | MDN (mozilla.org)</a></li></ul></blockquote><h2 id="盒模型的组成">盒模型的组成<a class="header-anchor" href="#盒模型的组成">⁍</a></h2><ul><li>content-box：width/height</li><li>padding</li><li>border</li><li>margin</li></ul><h3 id="标准盒模型">标准盒模型<a class="header-anchor" href="#标准盒模型">⁍</a></h3><p><img src="https://mdn.mozillademos.org/files/16559/standard-box-model.png" alt="Showing the size of the box when the standard box model is being used."></p><h3 id="替代盒-ie盒模型">替代盒/IE盒模型<a class="header-anchor" href="#替代盒-ie盒模型">⁍</a></h3><p><img src="https://mdn.mozillademos.org/files/16557/alternate-box-model.png" alt="Showing the size of the box when the alternate box model is being used."></p><ul><li>通过设置<code>box-sizing: border-box</code>实现</li><li><code>height/width</code>包含了<code>padding</code>和<code>border</code>的大小</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br>*, *<span class="hljs-selector-pseudo">::before</span>, *<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: inherit;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="外边距折叠collapse">外边距折叠collapse<a class="header-anchor" href="#外边距折叠collapse">⁍</a></h3><p>如果有两个外边距相接的元素，这些外边距将合并为一个外边距，即 <strong>最大的单个外边距的大小</strong> 。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">mastering margin collapsing (mozilla.org)</a></p><p>有三种情况会形成外边距重叠：</p><ol><li><p>同一层的相邻的两个元素之间的外边距重叠，除非后一个元素加上<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">clear-fix清除浮动</a>。</p></li><li><p>没有内容将父元素和后代元素分开</p><ol><li>两个上边界：没有border/padding/inline内容/创建<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">块级格式上下文</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">清除浮动</a> 来分开</li><li>两个下边界：没有border/padding/inline内容/height/min-height/max-height来分开</li></ol><p>重叠部分最终会溢出到父级块元素外面</p></li><li><p>空的块级元素</p></li></ol><h2 id="溢出">溢出<a class="header-anchor" href="#溢出">⁍</a></h2><p>css不会主动隐藏内容</p><p>设置<code>overflow: hidden/visible/scroll/auto</code></p><ul><li>滚动可以单独设置<code>overflow-x/overflow-y</code></li><li><code>overflow: scroll hidden</code>会把<code>overflow-x</code>设置成<code>scroll</code>，而<code>overflow-y</code>则为<code>hidden</code>。</li><li>设置为<code>auto</code>由浏览器决定是否显示滚动条。</li></ul><h3 id="块级排版上下文"><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Overflowing_content#%E6%BA%A2%E5%87%BA%E5%BB%BA%E7%AB%8B%E4%BA%86%E5%9D%97%E7%BA%A7%E6%8E%92%E7%89%88%E4%B8%8A%E4%B8%8B%E6%96%87">块级排版上下文</a><a class="header-anchor" href="#块级排版上下文">⁍</a></h3><p><strong>Block Formatting Context，BFC</strong></p><p>使用诸如<code>scroll</code>或者<code>auto</code>的时候，你就建立了一个块级排版上下文。</p><p>见CSS-BFC</p>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-CSS】字体/文本等样式化</title>
      <link href="/augu1sto/2b1512a54a3e/"/>
      <url>/augu1sto/2b1512a54a3e/</url>
      
        <content type="html"><![CDATA[<h2 id="font和文本样式">font和文本样式<a class="header-anchor" href="#font和文本样式">⁍</a></h2><p>font简写顺序： <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style"><code>font-style</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a>.</p><ul><li>必需：<code>font-size</code> 和 <code>font-family</code></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性之间必须放一个正斜杠</li></ul><h3 id="网页安全字体（通用）">网页安全字体（通用）<a class="header-anchor" href="#网页安全字体（通用）">⁍</a></h3><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">字体名称</td><td style="text-align:left">泛型</td><td style="text-align:left">注意</td></tr><tr><td style="text-align:left">Arial</td><td style="text-align:left">sans-serif</td><td style="text-align:left">通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但 Helvetica 被认为具有更好的形状，即使Arial更广泛地可用。</td></tr><tr><td style="text-align:left">Courier New</td><td style="text-align:left">monospace</td><td style="text-align:left">某些操作系统有一个 Courier New 字体的替代（可能较旧的）版本叫Courier。使用Courier New作为Courier的首选替代方案，被认为是最佳做法。</td></tr><tr><td style="text-align:left">Georgia</td><td style="text-align:left">serif</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Times New Roman</td><td style="text-align:left">serif</td><td style="text-align:left">某些操作系统有一个 Times New Roman 字体的替代（可能较旧的）版本叫 Times。使用Times作为Times New Roman的首选替代方案，被认为是最佳做法。</td></tr><tr><td style="text-align:left">Trebuchet MS</td><td style="text-align:left">sans-serif</td><td style="text-align:left">您应该小心使用这种字体——它在移动操作系统上并不广泛。</td></tr><tr><td style="text-align:left">Verdana</td><td style="text-align:left">sans-serif</td><td style="text-align:left"></td></tr></tbody></table><p>详见 <a href="http://www.cssfontstack.com/">cssfontstack.com</a></p><h3 id="通用字体族-默认字体">通用字体族/默认字体<a class="header-anchor" href="#通用字体族-默认字体">⁍</a></h3><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left"><code>serif</code></td><td style="text-align:left">衬线体</td></tr><tr><td style="text-align:left"><code>sans-serif</code></td><td style="text-align:left">无衬线体</td></tr><tr><td style="text-align:left"><code>monospace</code></td><td style="text-align:left">等宽字体</td></tr><tr><td style="text-align:left"><code>cursive</code></td><td style="text-align:left">手写体</td></tr><tr><td style="text-align:left"><code>fantasy</code></td><td style="text-align:left">装饰体</td></tr></tbody></table><h3 id="font-family">font-family<a class="header-anchor" href="#font-family">⁍</a></h3><ul><li>有空格或特殊符号需要用单引号包围</li><li>与字体族重名要用双引号包围</li><li><strong>字体栈</strong> ( <strong>font stack</strong> ) 用逗号分隔</li></ul><h3 id="相关其他属性">相关其他属性<a class="header-anchor" href="#相关其他属性">⁍</a></h3><ul><li><code>font-style</code>：<code>normal</code>/<code>italic</code>/<code>oblique</code>（模拟斜体）</li><li><code>font-weight</code>：字重 <code>normal</code>/<code>bold</code>/<code>bolder</code>/<code>light</code>/<code>lighter</code>/<code>100</code>~<code>900</code>（100的倍数）</li><li><code>font-size</code>：…</li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>其他样式</span></div>    <div class="hide-content"><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>: 在小型大写字母和普通文本选项之间切换。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-kerning"><code>font-kerning</code></a>: 开启或关闭字体间距选项。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-feature-settings"><code>font-feature-settings</code></a>: 开启或关闭不同的 <a href="https://en.wikipedia.org/wiki/OpenType">OpenType</a> 字体特性。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-alternates"><code>font-variant-alternates</code></a>: 控制给定的自定义字体的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-caps"><code>font-variant-caps</code></a>: 控制大写字母替代字形的使用。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-east-asian"><code>font-variant-east-asian</code> (en-US)</a>: 控制东亚文字替代字形的使用, 像日语和汉语。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-ligatures"><code>font-variant-ligatures</code></a>: 控制文本中使用的连写和上下文形式。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-numeric"><code>font-variant-numeric</code></a>: 控制数字，分式和序标的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-position"><code>font-variant-position</code></a>: 控制位于上标或下标处，字号更小的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size-adjust"><code>font-size-adjust</code></a>: 独立于字体的实际大小尺寸，调整其可视大小尺寸。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>: 在给定字体的可选拉伸版本中切换。</li></ul></div></div><h3 id="文本样式">文本样式<a class="header-anchor" href="#文本样式">⁍</a></h3><p>属于文本设置的范畴，但本质是给字本身添加样式</p><h4 id="文字阴影"><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals#%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1">文字阴影</a><a class="header-anchor" href="#文字阴影">⁍</a></h4><p>你可以为你的文本应用阴影，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a> 属性。这最多需要 4 个值，如下例所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">4px</span> <span class="hljs-number">4px</span> <span class="hljs-number">5px</span> red;<br></code></pre></td></tr></table></figure><p>4 个属性如下:</p><ol><li>水平偏移，通常用px做单位。必须指定。</li><li>垂直偏移。必须指定。</li><li>模糊半径 ，默认为0，这意味着没有模糊。</li><li>阴影的基础颜色，默认为 <code>black</code>.</li></ol><p>可以用逗号分隔，设置多重阴影</p><h4 id="text-transform"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-transform"><code>text-transform</code></a><a class="header-anchor" href="#text-transform">⁍</a></h4><ul><li><code>none</code>: 防止任何转型。</li><li><code>uppercase</code>: 将所有文本转为大写。</li><li><code>lowercase</code>: 将所有文本转为小写。</li><li><code>capitalize</code>: 转换所有单词让其首字母大写。</li><li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。</li></ul><h4 id="text-decoration"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a><a class="header-anchor" href="#text-decoration">⁍</a></h4><ul><li><code>none</code>: 取消已经存在的任何文本装饰。</li><li><code>underline</code>: 文本下划线.</li><li><code>overline</code>: 文本上划线</li><li><code>line-through</code>: 穿过文本的线</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a> 是一个缩写形式，它由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration-line"><code>text-decoration-line</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration-style"><code>text-decoration-style</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration-color"><code>text-decoration-color</code></a> 构成</p><h2 id="文本布局">文本布局<a class="header-anchor" href="#文本布局">⁍</a></h2><h3 id="inline和block">inline和block<a class="header-anchor" href="#inline和block">⁍</a></h3><p>以正常的横向书写来讲，块级就是控制文本的纵向样式，行内就是控制文本的横向样式</p><ul><li>块级方向：当前书写模式下块级元素放置的顺序</li><li>行内方向：行内元素书写的方向</li></ul><p>书写方式可以通过<code>writing-mode</code>来指定，<code>text-orientation</code>可以用作改变文本方向</p><h3 id="文本对齐（inline）">文本对齐（inline）<a class="header-anchor" href="#文本对齐（inline）">⁍</a></h3><p>用<code>text-align</code>：<code>left</code>/<code>right</code>/<code>center</code>/<code>justify</code>（两端对齐）</p><p>在CSS3中，新增了<code>start</code>、<code>end</code>，根据书写方向进行调整</p><h3 id="行高（block）">行高（block）<a class="header-anchor" href="#行高（block）">⁍</a></h3><p><code>line-height</code></p><ul><li><p>可以设置为无单位的值，相当于乘以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a></p></li><li><p>如果<code>font-size</code>是14px，<code>line-height</code>是18px，则多出来的4px，会被 <strong>分成两半</strong> 到上部分和下部分</p></li><li><p>继承时，行高根据父元素的字号计算，而不根据子元素计算；而使用无单位的数字则没有这个问题，会应用到当前元素及所有其元素上，各元素根据自身行高进行计算</p></li></ul><h3 id="字母和单词间距（inline）">字母和单词间距（inline）<a class="header-anchor" href="#字母和单词间距（inline）">⁍</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-spacing"><code>word-spacing</code></a> 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。（必须有单位，除了默认0）</p><p>可能会受到<code>text-align:justify;</code>的影响</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>其他样式</span></div>    <div class="hide-content"><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-indent"><code>text-indent</code></a>: 指定文本内容的第一行前面应该留出多少的水平空间。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-overflow"><code>text-overflow</code></a>: 定义如何向用户表示存在被隐藏的溢出内容。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a>: 定义如何处理元素内部的空白和换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>: 指定是否能在单词内部换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>: 定义文本的方向 (这取决于语言，并且通常最好让HTML来处理这部分，因为它是和文本内容相关联的。)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>: 为支持的语言开启或关闭连字符。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-break"><code>line-break</code></a>: 对东亚语言采用更强或更弱的换行规则。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align-last"><code>text-align-last</code></a>: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-orientation"><code>text-orientation</code></a>: 定义行内文本的方向。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap"><code>word-wrap</code></a>: 指定浏览器是否可以在单词内换行以避免超出范围。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</li></ul></div></div><h2 id="样式列表">样式列表<a class="header-anchor" href="#样式列表">⁍</a></h2><ul><li>缩进通过<code>&lt;ul&gt;</code>/<code>&lt;ol&gt;</code>的<code>padding-left</code>控制</li><li>符号样式通过 <code>list-style-type/position/image</code>控制<ul><li>取消圆点：<code>list-style(-type):none;</code></li><li><code>position</code>有<code>inside/outside（默认）</code>两种，表示序号是否嵌入文本内</li></ul></li><li>管理计数一般通过HTML标签实现，例如<code>&lt;ol start=&quot;4&quot; reversed&gt;</code>、<code>&lt;li value=&quot;2&quot;&gt;</code></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists">样式列表 - 学习 Web 开发 | MDN (mozilla.org)</a></p><h2 id="样式化链接">样式化链接<a class="header-anchor" href="#样式化链接">⁍</a></h2><h3 id="伪类">伪类<a class="header-anchor" href="#伪类">⁍</a></h3><h3 id="常见属性">常见属性<a class="header-anchor" href="#常见属性">⁍</a></h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a> 文字的颜色</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor"><code>cursor</code></a> 鼠标光标的样式，你不应该把这个关掉，除非你有非常好的理由。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline"><code>outline</code></a> 文字的轮廓 (轮廓有点像边框，唯一的区别是边框占用了盒模型的空间，而轮廓没有； 它只是设置在背景图片的顶部)。outline 是一个有用的辅助功能，所以在把它关掉之前考虑清楚；你至少应该将悬停 (hover) 状态的样式同时应用到选中 (focus) 状态上。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a></li><li><code>border</code></li><li><code>background</code></li></ul><h3 id="链接中插入图标">链接中插入图标<a class="header-anchor" href="#链接中插入图标">⁍</a></h3><p>给链接设置背景图片实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;http&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://mdn.mozillademos.org/files/12982/external-link-52.png&#x27;</span>) no-repeat <span class="hljs-number">100%</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/*放在最右边，top距离0*/</span><br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">16px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">19px</span>; <span class="hljs-comment">/*为背景图片留出空间*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="样式化链接为按钮"><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_links#%E6%A0%B7%E5%BC%8F%E5%8C%96%E9%93%BE%E6%8E%A5%E4%B8%BA%E6%8C%89%E9%92%AE">样式化链接为按钮</a><a class="header-anchor" href="#样式化链接为按钮">⁍</a></h3><p>略</p><h2 id="font-face-web文本"><code>@font-face</code>/Web文本<a class="header-anchor" href="#font-face-web文本">⁍</a></h2><mark class="hl-label orange">TODO!</mark> <p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Web_fonts">Web 字体 - 学习 Web 开发 | MDN (mozilla.org)</a></p><ol><li>在CSS开始定义<code>@font-face</code>块，用<code>font-family</code>定义名称，<code>src</code>指定字体链接</li><li>可以自定义本地font套件或者使用google fonts来插入在线字体服务</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-CSS】CSS重点知识总结</title>
      <link href="/augu1sto/d207e9f19477/"/>
      <url>/augu1sto/d207e9f19477/</url>
      
        <content type="html"><![CDATA[<div class="note flat"><p>本文参考[^1]的提纲，进行知识的梳理与整理，更新中~</p></div><h2 id="css引入方式">CSS引入方式<a class="header-anchor" href="#css引入方式">⁍</a></h2><h3 id="外部样式表">外部样式表<a class="header-anchor" href="#外部样式表">⁍</a></h3><p>在<code>&lt;head&gt;</code>-<code>&lt;link&gt;</code>中引入样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;sheet1.css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;all&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>Points</span></div>    <div class="hide-content"><ol><li>media属性是媒体描述符，可选，多个用逗号隔开，指明CSS样式针对的媒体类型</li><li>可以用多个<code>link</code>引入多个样式表。如果这下样式表都没有设定<code>title</code>，就是永久样式表，浏览器会合并样式，如果设定了<code>title</code>，浏览器会选择其中的一个，忽略其它的。[^2]</li><li>候选样式表：把<code>rel</code>属性设置为<code>alternate stylesheet</code>，<code>title</code>属性里指定样式表名称。用户可以在浏览器里选择对应的样式表（只要浏览器支持的话，如基于<code>WebKit</code>的浏览器就不支持选择候选样式表，比如chrome）[^2]</li></ol></div></div><h3 id="内部样式表">内部样式表<a class="header-anchor" href="#内部样式表">⁍</a></h3><p>将CSS放在HTML文件<code>&lt;head&gt;</code>-<code>&lt;style&gt;</code>标签中</p><h3 id="内联样式">内联样式<a class="header-anchor" href="#内联样式">⁍</a></h3><p>存在于HTML元素的style属性之中。（注意要加分号！）</p><h3 id="import">@import<a class="header-anchor" href="#import">⁍</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;styles2.css&#x27;</span>;</span><br><span class="css"><span class="hljs-keyword">@import</span> url(sheet2.css) projection,print;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>位置：放在style标签内的开头</li><li>也可以在外部样式表里添加<code>@import</code>指令（而link本身就不能放在外部样式表里），使得一个外部样式表可以引用其他外部样式表<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li><li>一个文档中可以有多个<code>@import</code>语句，每个样式表都会被用到，不存在候选一说。</li><li>可以在后面指定媒体描述符</li></ul><blockquote><p>@规则</p><p><code>@import</code>其实是<code>@rules</code> 规则里的一种，有规则名和值，其他的<code>@rules</code>规则例如<code>@media</code>，它允许使用 媒体查询 来应用CSS，仅当某些条件成立(例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时)。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>媒体类型：</p><ul><li><code>all</code></li><li><code>print</code> ：打印</li><li><code>screen</code>：屏幕</li><li><code>projection</code>：部分浏览器支持，幻灯片</li></ul><p>媒体特性描述符：例如<code>min-width</code>等，详见<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup> <sub>p30-32</sub></p></blockquote><h2 id="css-权重">CSS 权重<a class="header-anchor" href="#css-权重">⁍</a></h2><table><thead><tr><th>选择符</th><th>特指度</th></tr></thead><tbody><tr><td>ID</td><td>0100</td></tr><tr><td>类、属性选择、伪类</td><td>0010</td></tr><tr><td>元素/伪元素</td><td>0001</td></tr><tr><td>内联样式</td><td>1000</td></tr><tr><td>通用选择符</td><td>0000（不等于无）</td></tr></tbody></table><p>可以相加， <strong>注</strong> :  通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ’ ')，和否定伪类 (<code>:not</code>) 不会影响优先级。</p><h2 id="用css画三角形">用CSS画三角形<a class="header-anchor" href="#用css画三角形">⁍</a></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">300px</span>``) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>:lightblue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>元素水平垂直居中的方案</p><p>元素固定宽高</p><p>元素不固定宽高</p><p>元素种类的划分</p><p>盒子模型及其理解</p><p>margin塌陷及合并问题</p><p>浮动模型及清除浮动的方法</p><p>IFC与BFC</p><p>圣杯布局与双飞翼布局圣杯布局双飞翼布局</p><p>Flex 布局容器的属性项目的属性</p><h2 id="px-em-rem的区别">px,em,rem的区别<a class="header-anchor" href="#px-em-rem的区别">⁍</a></h2><p>px：像素px是相对于显示器屏幕分辨率而言的。</p><p>em：相对于当前父元素的字体大小</p><p>rem：rem相对于根元素设置字体大小</p><p>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可</p><p>对于需要适配各种移动设备，使用rem</p><h2 id="媒体查询">媒体查询<a class="header-anchor" href="#媒体查询">⁍</a></h2><h2 id=""><a class="header-anchor" href="#">⁍</a></h2><p>HTML5 新特性</p><p>理解 BFC</p><p>Grid 布局</p><p>行内元素的间距怎么解决</p><h2 id="伪类和伪元素有什么不同">伪类和伪元素有什么不同<a class="header-anchor" href="#伪类和伪元素有什么不同">⁍</a></h2><p>优先级，伪类和类一致是0010，伪元素跟元素一致是0001</p><p><strong>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的</strong>，比如说，当用户悬停在指定的元素时，我们可以用:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是<strong>它只有处于dom树无法描述的状态下才能为元素添加样式</strong>，所以将其称为伪类。</p><p><strong>伪元素不是 DOM 中的真实元素，但是存在于最终的渲染树中，可以为其添加样式，比如说，我们可以通过：before来在一个元素前增加一些文本</strong>。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>《CSS权威指南》 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_is_structured#%E8%A7%84%E5%88%99">如何构建CSS - 学习 Web 开发 | MDN (mozilla.org)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-CSS】基础CSS</title>
      <link href="/augu1sto/c33b3b0f62e6/"/>
      <url>/augu1sto/c33b3b0f62e6/</url>
      
        <content type="html"><![CDATA[<div class="note flat"><p>依据freeCodeCamp、<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS">MDN</a>、《CSS权威指南》等相关知识的笔记整理</p><p>实时更新代码仓库<a href="https://github.com/Augu1sto/FE-learning">Augu1sto/FE-learning: 一个练习前端的小仓库，争取日更 (github.com)</a></p></div><h2 id="css如何运行">CSS如何运行<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><a class="header-anchor" href="#css如何运行">⁍</a></h2><p>浏览器加载网页的基本步骤（不同浏览器或许会有所差异）</p><ol><li><strong>载入HTML</strong> ：浏览器载入HTML文件（比如从网络上获取）。</li><li><strong>转化为DOM</strong> ：将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。</li><li><strong>加载资源</strong> ：接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。</li><li><strong>解析CSS，创建渲染树</strong> ：浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</li><li>上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。</li><li>网页展示在屏幕上（这一步被称为着色）。</li></ol><p>结合下面的图示更形象：</p><p><img src="https://mdn.mozillademos.org/files/11781/rendering.svg" alt="img"></p><h2 id="margin-padding顺序">margin/padding顺序<a class="header-anchor" href="#margin-padding顺序">⁍</a></h2><p>上右下左（顺时针），中间空格隔开</p><h2 id="速记-简写属性">速记/简写属性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><a class="header-anchor" href="#速记-简写属性">⁍</a></h2><p>像上面的被称作速记属性，除了<code>margin</code>/<code>padding</code>还有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 等属性</p><ul><li><code>padding</code>/<code>margin</code>：上右下左</li><li><code>font</code>：style/variant/weight/stretch/   <strong>size</strong> /line-height   / <strong>family</strong></li><li><code>list-style</code>：type/image/position</li><li><code>border</code>：粗细 样式 颜色</li><li><code>background</code>：值（图像/颜色/渐变） 垂直位置 水平位置 repeat属性（，逗号分隔多个背景）</li><li><code>box-shadow</code> 属性按顺序采用以下值：<ul><li><code>offset-x</code> （阴影的水平偏移量），</li><li><code>offset-y</code> （阴影的垂直偏移量），</li><li><code>blur-radius</code></li><li><code>spread-radius</code></li><li><code>color</code></li></ul></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties">CSS 的简写属性 - CSS（层叠样式表） | MDN (mozilla.org)</a></p><h2 id="引入google-font-api">引入google font api<a class="header-anchor" href="#引入google-font-api">⁍</a></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://fonts.googleapis.com/css?family=Lobster&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="选择符">选择符<a class="header-anchor" href="#选择符">⁍</a></h2><h3 id="1-元素选择符">1. 元素选择符<a class="header-anchor" href="#1-元素选择符">⁍</a></h3><h3 id="2-群组选择符">2. 群组选择符<a class="header-anchor" href="#2-群组选择符">⁍</a></h3><p>逗号隔开，<code>*</code>是通用选择符</p><h3 id="3-id选择符">3. ID选择符<a class="header-anchor" href="#3-id选择符">⁍</a></h3><h3 id="4-类选择符">4. 类选择符<a class="header-anchor" href="#4-类选择符">⁍</a></h3><p>ID和类选择符的书写方式其实是[元素选择符/群组选择符][ID选择符/类选择符]，例如<code>p.first-para</code>/<code>*#first</code></p><p>不过通用选择符可以省略，所以一般看到的就是<code>#first</code>的形式</p><p>选中同时拥有多个类的元素：<code>.classA.classB</code></p><h3 id="5-属性选择符">5. 属性选择符<a class="header-anchor" href="#5-属性选择符">⁍</a></h3><p>选择具有某个属性的元素</p><p>使用 <code>元素[attr=value]</code> 属性选择器来修改样式</p><ul><li>和ID/类选择符一样，当前面的元素为<code>*</code>时，可以省略</li><li><code>=value</code>可以省略，表示所有具有<code>attr</code>属性的元素</li><li>可以基于多个属性选择，例如<code>a[href][title]</code></li><li>可以匹配子串，详细规则见《CSS权威指南》p57-62</li></ul><h3 id="6-根据文档结构选择">6. 根据文档结构选择<a class="header-anchor" href="#6-根据文档结构选择">⁍</a></h3><h4 id="后代选择符">后代选择符<a class="header-anchor" href="#后代选择符">⁍</a></h4><p>根据空格隔开，例如 <code>ul ol&#123;color:gray;&#125;</code></p><p>两个元素之间的层级间隔可以是无限的，不论嵌套多深，后代选择符不能感知距离</p><h4 id="选择直接子元素">选择直接子元素<a class="header-anchor" href="#选择直接子元素">⁍</a></h4><p>用<code>&gt;</code>表示，如<code>h1 &gt; strong &#123;color:red;&#125;</code></p><h4 id="选择紧邻同胞元素">选择紧邻同胞元素<a class="header-anchor" href="#选择紧邻同胞元素">⁍</a></h4><p>选择紧跟在A元素后面平级的B元素<code>A+B</code></p><h4 id="选择后续同胞">选择后续同胞<a class="header-anchor" href="#选择后续同胞">⁍</a></h4><p>选择一个元素后面同属一个父元素的另一个元素（不一定紧邻），例如<code>h2~ol</code></p><h3 id="7-伪类选择符">7. 伪类选择符<a class="header-anchor" href="#7-伪类选择符">⁍</a></h3><p>pseudo-class selector 为 <strong>文档中不一定真实存在的结构</strong> 或者 <strong>某些元素的特定状态</strong> 指定样式/赋予幽灵类</p><ul><li>不相互排斥的伪类可以通过<code>:</code>串联拼接，例如<code>a:visited:hover</code></li><li>分为 <strong>结构伪类</strong> 、 <strong>动态伪类</strong> 、 <strong>UI状态伪类</strong> 、 <strong>target伪类</strong> 、<strong>lang伪类</strong>、 <strong>否定伪类（即not()）</strong></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes#%E6%A0%87%E5%87%86%E4%BC%AA%E7%B1%BB%E7%B4%A2%E5%BC%95">伪类 - CSS（层叠样式表） | MDN (mozilla.org)</a></p><p>部分：</p><ul><li><p><code>:empty</code>：没有子代的任何元素（甚至连文本节点，包括文本和空格、换行等都没有），利用<code>p:empty&#123;display:none;&#125;</code>可以禁止显示空段落。但是<code>img</code>/<code>textarea</code>等也算空元素。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203231728961.png" alt="image-20220323172830782"></p><blockquote><p>例如我在一个网页中添加样式<code>*:empty&#123;display:none&#125;</code>会使得图片也一起消失</p></blockquote></li><li><p><code>:nth-child</code>(/<code>:nth-last-child</code>)</p><p>选择每第n个元素，找到所有当前元素的 <strong>兄弟元素</strong> ，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3…）。</p><ul><li>表示HTML表的倒数的奇数行：<code>tr:nth-child(2n+1)</code> or <code>tr:nth-child(odd)</code></li><li>表示父元素中子元素为第一的并且名字为span的标签被选中：<code>span:nth-child(1)</code>，相当于<code>span:first-child</code></li></ul></li><li><p><code>:active</code>：匹配被用户激活的元素（表示鼠标点击状态）。一般被用于<code>&lt;a&gt;</code>和<code>&lt;button&gt;</code>中。声明的时候要防止被其他伪类覆盖，需要按照LVHA顺序声明。（其他几个伪类很熟了就不介绍了）</p><blockquote><p><em>LVHA 顺序</em>：<code>:link</code> — <code>:visited</code> — <code>:hover</code> — <code>:active</code>。</p><p><strong>L</strong> o <strong>V</strong> e <strong>F</strong> ears <strong>HA</strong> te (<code>:focus</code>)</p></blockquote></li><li><p><code>:focus</code>：获取当前的焦点</p></li><li><p><code>:required</code>：表单必填项的格式</p></li><li><p><code>:invalid</code>：不满足所有数据有效性的输入框</p></li><li><p><code>:enabled/:disabled</code>：启用/禁用</p></li><li><p><code>:target</code>：表一个唯一的页面元素(目标元素)，其id与当前URL里的片段标识符（例如<code>http://www.example.com/index.html#section2</code>，id为<code>section2</code>）匹配，可以用于加亮锚点</p></li></ul><h3 id="8-伪元素选择符">8. 伪元素选择符<a class="header-anchor" href="#8-伪元素选择符">⁍</a></h3><p>用一对冒号<code>::first-line</code>表示，只能出现在选择符最后，例如<code>p::first-line em</code>是无效的</p><p><code>::before</code>和<code>::after</code>伪元素与<code>content</code>属性的共同使用，在CSS中被叫做“生成内容“，可以用作给出视觉提示（但并不会朗读出来）</p><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a></td><td style="text-align:left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a></td><td style="text-align:left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter"><code>::first-letter</code></a></td><td style="text-align:left">匹配元素的第一个字母。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line"><code>::first-line</code></a></td><td style="text-align:left">匹配包含此伪元素的元素的第一行。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error"><code>::grammar-error</code></a></td><td style="text-align:left">匹配文档中包含了浏览器标记的语法错误的那部分。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection"><code>::selection</code></a></td><td style="text-align:left">匹配文档中被选择的那部分。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error"><code>::spelling-error</code></a></td><td style="text-align:left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td></tr></tbody></table><h2 id="层叠与继承">层叠与继承<a class="header-anchor" href="#层叠与继承">⁍</a></h2><h3 id="继承">继承<a class="header-anchor" href="#继承">⁍</a></h3><ol><li><code>CSS</code>的某些样式是具有继承性的，继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。</li><li>不可继承样式：<code>display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear</code></li><li>可以继承的样式：<code>letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction、visibility、cursor</code></li></ol><h3 id="层叠规则">层叠规则<a class="header-anchor" href="#层叠规则">⁍</a></h3><p>有三个因素需要考虑，根据重要性排序如下，前面的更重要：</p><ol><li>重要程度：<code>!important</code>用于修改特定属性的值， 能够覆盖普通规则的层叠。</li><li>优先级</li><li>资源顺序：相同重要程度和优先级的情况下，定义在后面的css样式会覆盖前面的</li></ol><p>相互冲突的声明将按以下顺序适用，后一种声明将覆盖前一种声明：</p><ol><li>用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。</li><li>用户样式表中的常规声明(由用户设置的自定义样式)。</li><li>作者样式表中的常规声明(这些是我们web开发人员设置的样式)。</li><li>作者样式表中的<code>!important</code>声明</li><li>用户样式表中的<code>!important</code> 声明</li></ol><h3 id="特指度-优先级权重">特指度/优先级权重<a class="header-anchor" href="#特指度-优先级权重">⁍</a></h3><p>由4位数字组成</p><table><thead><tr><th>选择符</th><th>特指度</th></tr></thead><tbody><tr><td>ID</td><td>0100</td></tr><tr><td>类、属性选择、伪类</td><td>0010</td></tr><tr><td>元素/伪元素</td><td>0001</td></tr><tr><td>内联样式</td><td>1000</td></tr><tr><td>通用选择符</td><td>0000（不等于无）</td></tr></tbody></table><p>可以相加， <strong>注</strong> :  通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ’ ')，和否定伪类 (<code>:not</code>) 不会影响优先级。</p><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">优先级</th></tr></thead><tbody><tr><td style="text-align:left"><code>h1</code></td><td style="text-align:left">0001</td></tr><tr><td style="text-align:left"><code>h1 + p::first-letter</code></td><td style="text-align:left">0003</td></tr><tr><td style="text-align:left"><code>li &gt; a[href*=&quot;en-US&quot;] &gt; .inline-warning</code></td><td style="text-align:left">0022</td></tr><tr><td style="text-align:left"><code>#identifier</code></td><td style="text-align:left">0100</td></tr><tr><td style="text-align:left">内联样式</td><td style="text-align:left">1000</td></tr></tbody></table><h2 id="绝对单位、相对单位">绝对单位、相对单位<a class="header-anchor" href="#绝对单位、相对单位">⁍</a></h2><ul><li><p>绝对：  例如，<code>in</code> 和 <code>mm</code> 分别代表着英寸和毫米。 绝对长度单位会接近屏幕上的实际测量值，不过不同屏幕的分辨率会存在差异，这就可能会造成误差。</p><table><thead><tr><th style="text-align:left">单位</th><th style="text-align:left">名称</th><th style="text-align:left">等价换算</th></tr></thead><tbody><tr><td style="text-align:left"><code>cm</code></td><td style="text-align:left">厘米</td><td style="text-align:left">1cm = 96px/2.54</td></tr><tr><td style="text-align:left"><code>mm</code></td><td style="text-align:left">毫米</td><td style="text-align:left">1mm = 1/10th of 1cm</td></tr><tr><td style="text-align:left"><code>Q</code></td><td style="text-align:left">四分之一毫米</td><td style="text-align:left">1Q = 1/40th of 1cm</td></tr><tr><td style="text-align:left"><code>in</code></td><td style="text-align:left">英寸</td><td style="text-align:left">1in = 2.54cm = 96px</td></tr><tr><td style="text-align:left"><code>pc</code></td><td style="text-align:left">十二点活字</td><td style="text-align:left">1pc = 1/16th of 1in</td></tr><tr><td style="text-align:left"><code>pt</code></td><td style="text-align:left">点</td><td style="text-align:left">1pt = 1/72th of 1in</td></tr><tr><td style="text-align:left"><code>px</code></td><td style="text-align:left">像素</td><td style="text-align:left">1px = 1/96th of 1in</td></tr></tbody></table></li><li><p>相对： 比如 <code>em</code> 和 <code>rem</code>，它们的实际值会依赖其他长度的值而决定。 比如  <code>em</code> <strong>的大小基于元素字体的字体大小</strong> 。 如果使用它来设置 <code>font-size</code> 值，它的值会跟随父元素的 <code>font-size</code> 值来改变。</p><table><thead><tr><th style="text-align:left">单位</th><th style="text-align:left">相对于</th></tr></thead><tbody><tr><td style="text-align:left"><code>em</code></td><td style="text-align:left">在 font-size 中使用是相对于父元素的字体大小(嵌套)，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td style="text-align:left"><code>ex</code></td><td style="text-align:left">字符“x”的高度</td></tr><tr><td style="text-align:left"><code>ch</code></td><td style="text-align:left">数字“0”的宽度</td></tr><tr><td style="text-align:left"><code>rem</code></td><td style="text-align:left">根元素的字体大小</td></tr><tr><td style="text-align:left"><code>lh</code></td><td style="text-align:left">元素的line-height</td></tr><tr><td style="text-align:left"><code>vw</code></td><td style="text-align:left">视窗宽度的1%</td></tr><tr><td style="text-align:left"><code>vh</code></td><td style="text-align:left">视窗高度的1%</td></tr><tr><td style="text-align:left"><code>vmin</code></td><td style="text-align:left">视窗较小尺寸的1%</td></tr><tr><td style="text-align:left"><code>vmax</code></td><td style="text-align:left">视图大尺寸的1%</td></tr><tr><td style="text-align:left">百分号</td><td style="text-align:left">父元素的百分比</td></tr></tbody></table></li></ul><p>使用百分比作为元素外边距（ margin ）或填充（ padding ）的单位时，值是以包含块的<strong>内联尺寸</strong>进行计算的，也就是元素的水平宽度。（上下边距也是水平宽度）</p><h3 id="min-max-尺寸">min-/max-尺寸<a class="header-anchor" href="#min-max-尺寸">⁍</a></h3><p>设置一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height"><code>min-height</code></a>属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p><h2 id="基础样式">基础样式<a class="header-anchor" href="#基础样式">⁍</a></h2><h3 id="背景">背景<a class="header-anchor" href="#背景">⁍</a></h3><p>可以通过逗号分隔添加多个重叠的背景图像</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a>属性用于控制图像的平铺行为。</p><ul><li><code>no-repeat</code> — 不重复。</li><li><code>repeat-x</code> —水平重复。</li><li><code>repeat-y</code> —垂直重复。</li><li><code>repeat</code> — 在两个方向重复。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>属性，它可以设置长度或百分比值，也可以使用关键字:</p><ul><li><code>cover</code> —— 浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像 <strong>可能会跳出盒子外</strong></li><li><code>contain</code>  —— 使图像的大小适合盒子内。可能在图像的任何一边或顶部和底部出现间隙。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>框沿着水平(x)和垂直(y)轴定位。可以用<code>center</code>/<code>top</code>/<code>bottom</code> <code>center</code>/<code>left</code>/<code>right</code>等关键词进行定位。默认是<code>center</code>（？</p><h4 id="渐变背景">渐变背景<a class="header-anchor" href="#渐变背景">⁍</a></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">90deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">154</span>,<span class="hljs-number">205</span>,<span class="hljs-number">72</span>,<span class="hljs-number">1</span>) <span class="hljs-number">25%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">212</span>,<span class="hljs-number">255</span>,<span class="hljs-number">1</span>) <span class="hljs-number">100%</span>);<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">radial-gradient</span>(circle, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">238</span>,<span class="hljs-number">174</span>,<span class="hljs-number">202</span>,<span class="hljs-number">1</span>) <span class="hljs-number">0%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">148</span>,<span class="hljs-number">187</span>,<span class="hljs-number">233</span>,<span class="hljs-number">1</span>) <span class="hljs-number">100%</span>);<br></code></pre></td></tr></table></figure><blockquote><p>大致就是 （角度，颜色 位置，…）</p></blockquote><h4 id="条纹背景">条纹背景<a class="header-anchor" href="#条纹背景">⁍</a></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">repeating-linear-gradient</span>(<br>  <span class="hljs-number">45deg</span>,<br>  yellow <span class="hljs-number">0px</span>,<br>  yellow <span class="hljs-number">40px</span>,<br>  black <span class="hljs-number">40px</span>,<br>  black <span class="hljs-number">80px</span><br>);<br></code></pre></td></tr></table></figure><blockquote><p>角度，颜色1 起始位置，颜色1 结束位置，…</p></blockquote><h4 id="背景附加">背景附加<a class="header-anchor" href="#背景附加">⁍</a></h4><p>指定他们如何滚动时，内容滚动。这是由<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a>属性</p><p><a href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html">示例</a></p><ul><li><code>scroll</code>：固定在页面的某个位置（成为页面的一个部分）。内容滚动时，背景不动；页面滚动时，背景随页面滚动</li><li><code>fixed</code>：固定不动。</li><li><code>local</code>：（CSS3新增）。固定在元素内容上（随内容滚动）。</li></ul><h4 id="简写">简写<a class="header-anchor" href="#简写">⁍</a></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a>的MDN</p><p>有一些规则，需要在简写背景属性时遵循，例如:</p><ul><li><code>background-color</code> 只能在逗号之后指定。</li><li><code>background-size</code> 值只能包含在背景位置之后，用’/'字符分隔，例如：<code>center/80%</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background</span>:   <br>    <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">2</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>) center center / <span class="hljs-number">400px</span> <span class="hljs-number">200px</span> no-repeat,<br><span class="hljs-built_in">url</span>(<span class="hljs-string">big-star.png</span>) center no-repeat, <br>    rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="边框">边框<a class="header-anchor" href="#边框">⁍</a></h3><p>使右上角边框圆角的水平半径为1em，垂直半径为10％：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">1em</span> <span class="hljs-number">10%</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="替换元素——图像和视频以及iframe">替换元素——图像和视频以及iframe<a class="header-anchor" href="#替换元素——图像和视频以及iframe">⁍</a></h3><p>CSS不能影响这些元素的内部布局-仅影响它们在页面上于其他元素中的位置。</p><p><strong>如何调整图像大小使之合适盒子：</strong></p><ul><li><p>用<code>max-width:100%</code>处理溢出</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit"><code>object-fit</code></a>属性（本身不会改变大小，使用前需要设置<code>width/height:100%</code>）</p><ul><li><code>cover</code>：填充整个盒子（不改变比例）</li><li><code>contain</code>：保持比例完整显示图片，但会有空隙</li><li><code>fill</code>：拉伸，改变比例填充盒子</li></ul><p><a href="https://discourse.mozilla.org/t/need-help-with-task-1-of-images-and-form-elements-skill-test/62981/4">Need help with task 1 of Images and Form elements skill test - MDN / Learn - Mozilla Discourse</a></p></li></ul><p>在替换元素使用各式CSS布局技巧，例如网格或者弹性布局的一部分时，有不同的默认行为</p><h3 id="表单样式">表单样式<a class="header-anchor" href="#表单样式">⁍</a></h3><p>在一些浏览器中，表单元素默认不会继承字体样式。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Images_media_form_elements#form%E5%85%83%E7%B4%A0">form元素 (mozilla.org)</a> 一些有用的表单重置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: inherit;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="表格">表格<a class="header-anchor" href="#表格">⁍</a></h3><p><a href="https://github.com/mdn/learning-area/tree/main/css/styling-boxes/styling-tables">示例</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout"><code>table-layout</code></a> CSS属性定义了用于布局表格<em>单元格</em>，<em>行</em>和<em>列</em>的算法。</p><ul><li><code>auto</code>：表格及单元格的宽度取决于其包含的内容。</li><li><code>fixed</code>：表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。任何一个包含溢出内容的单元格可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 属性控制是否允许内容溢出。</li></ul><p>通过设定<code>fixed</code>，指定首行宽度，可以是表的行为在默认情况下更好预测。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a>属性的<code>collapse</code>值可以让表格边框合为一条</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/caption-side"><code>caption-side</code></a>属性，可以调整表格标题的位置</p><p>使用<code>&lt;thead&gt;</code>,<code>&lt;tbody&gt;</code>(en-US)和<code>&lt;tfoot&gt; </code>将表格分割成逻辑块，并提供额外的应用CSS的地方，因此如果需要的话，可以更容易地将样式层叠在一起。</p><p>使用斑马线来让其他行更容易阅读。</p><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a>直线对齐您的文本，使内容更整洁、更易于跟随。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works">CSS如何运行 - 学习 Web 开发 | MDN (mozilla.org)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_is_structured#%E9%80%9F%E8%AE%B0%E5%B1%9E%E6%80%A7">如何构建CSS - 学习 Web 开发 | MDN (mozilla.org)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【FE学习-HTML】HTML重点汇总</title>
      <link href="/augu1sto/698e04067f30/"/>
      <url>/augu1sto/698e04067f30/</url>
      
        <content type="html"><![CDATA[<div class="note flat"><p>参考教程：</p><ul><li>《HTML&amp;CSS设计与构建网站》</li><li><a href="https://wangdoc.com/html/index.html">HTML 教程 - 网道 (wangdoc.com)</a></li></ul><p>主要参考的是网道的教程，个人认为它比较新，仅记录个人理解的重点和不熟悉的地方</p></div><h2 id="网页的基本概念">网页的基本概念<a class="header-anchor" href="#网页的基本概念">⁍</a></h2><div class="note success flat"><p>HTML的标签和属性都是 <strong>不分大小写</strong> 的，<code>onclick</code>和<code>onClick</code>是同一个属性。</p></div><h3 id="标签与元素">标签与元素<a class="header-anchor" href="#标签与元素">⁍</a></h3><p>浏览器渲染网页时，会把 HTML 源码解析成一个标签树，每个标签都是树的一个节点（node）。这种节点就称为 <strong>网页元素（element）。</strong></p><p>“标签”和“元素”基本上是同义词，只是使用的场合不一样：</p><ul><li><strong>标签</strong> 是从 <strong>源码</strong> 角度来看</li><li><strong>元素</strong> 是从 <strong>编程</strong> 角度来看</li></ul><p>比如<code>&lt;p&gt;</code>标签对应网页的<code>p</code>元素。嵌套的标签就构成了网页元素的层级关系（父元素/子元素）。</p><h3 id="块级元素，行内元素">块级元素，行内元素<a class="header-anchor" href="#块级元素，行内元素">⁍</a></h3><h4 id="块级元素（block）">块级元素（block）<a class="header-anchor" href="#块级元素（block）">⁍</a></h4><p>默认占据一个独立的区域，在网页上会自动另起一行，占据 100% 的宽度。</p><p>例如： <code>p</code></p><h4 id="行内元素（inline）">行内元素（inline）<a class="header-anchor" href="#行内元素（inline）">⁍</a></h4><p>行内元素默认与其他元素在同一行，不产生换行。</p><p>例如： <code>span</code>、<code>sup</code>（上标）、<code>sub</code>（下标）、<code>b</code>、<code>i</code></p><div class="note warning flat"><p>行内元素还有哪些呢？</p></div><h2 id="网页的基本标签">网页的基本标签<a class="header-anchor" href="#网页的基本标签">⁍</a></h2><p>符合 HTML 语法标准的网页，应该满足下面的基本结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不管多么复杂的网页，都是从上面这个基本结构衍生出来的。</p><ul><li><p><a href="#%60%3C!doctype%3E%60"><code>&lt;!doctype&gt;</code></a></p></li><li><p><code>&lt;html&gt;</code>：网页的顶层 <strong>容器</strong> ，即标签树结构的顶层节点，也称为根元素（root element），其他元素都是它的子元素。</p><ul><li><p>该标签的<code>lang</code>属性，表示网页内容默认的语言。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>&lt;head&gt;</code>： <strong>容器</strong> 标签，用于放置网页的元信息。</p><ul><li><a href="#%60%3Cmeta%3E%60"><code>&lt;meta&gt;</code></a>：设置网页的元数据（编码/元数据/http回应字段）。</li><li><code>&lt;link&gt;</code>：连接外部样式表。</li><li><code>&lt;title&gt;</code>：设置网页标题。会显示在浏览器窗口的标题栏。搜索引擎会根据这个来显示。</li><li><code>&lt;style&gt;</code>：放置内嵌的样式表。</li><li><code>&lt;script&gt;</code>：引入脚本。</li><li><code>&lt;noscript&gt;</code>：浏览器不支持脚本时，所要显示的内容。</li><li><a href="#%60%3Cbase%3E%60"><code>&lt;base&gt;</code></a>：设置网页内部相对 URL 的计算基准。</li></ul></li><li><p><code>&lt;body&gt;</code>： <strong>容器</strong> 标签</p></li></ul><h3 id="doctype"><code>&lt;!doctype&gt;</code><a class="header-anchor" href="#doctype">⁍</a></h3><p>网页的第一个标签通常是<code>&lt;!doctype&gt;</code>，表示文档类型，告诉浏览器如何解析网页。</p><p>一般来说，只要像下面这样，简单声明<code>doctype</code>为<code>html</code>即可。浏览器就会按照 HTML 5 的规则处理网页。</p><p>有时，该标签采用完全大写的形式，以便区别于正常的 HTML 标签。因为<code>&lt;!doctype&gt;</code>本质上不是标签，更像一个处理指令。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="meta"><code>&lt;meta&gt;</code><a class="header-anchor" href="#meta">⁍</a></h3><p>一个<code>&lt;meta&gt;</code>标签就是一项元数据，网页可以有多个<code>&lt;meta&gt;</code>。<code>&lt;meta&gt;</code>标签约定放在<code>&lt;head&gt;</code>内容的最前面。</p><p>不管什么样的网页，一般都可以放置以下两个<code>&lt;meta&gt;</code>标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Page Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面例子中，第一个<code>&lt;meta&gt;</code>标签表示网页采用 UTF-8 格式编码，第二个<code>&lt;meta&gt;</code>标签表示网页在手机端可以自动缩放。</p><p><code>&lt;meta&gt;</code>标签有五个属性，下面依次介绍。</p><p><strong>（1）charset 属性</strong></p><p><code>&lt;meta&gt;</code>标签的<code>charset</code>属性，用来指定网页的 <strong>编码方式</strong> 。该属性非常重要，如果设置得不正确，浏览器可能无法正确解码，就会显示乱码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码声明，网页为 UTF-8 编码。这里声明的编码方式，应该与网页实际的编码方式一致，</p><p><strong>（2）name 属性，content 属性</strong></p><p><code>&lt;meta&gt;</code>标签的<code>name</code>属性表示元数据的名字，<code>content</code>属性表示元数据的值。它们合在一起使用，就可以 <strong>为网页指定一项元数据</strong> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML 语言入门&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML,教程&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码包含了三个元数据：<code>description</code>是网页内容的描述，<code>keywords</code>是网页内容的关键字，<code>author</code>是网页作者。</p><p>其他元数据例子⭐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;application-name&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Application Name&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;generator&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;program&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;subject&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;your document&#x27;s subject&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（3）http-equiv 属性，content 属性</strong></p><p><code>&lt;meta&gt;</code>标签的<code>http-equiv</code>属性用来覆盖 HTTP 回应的头信息字段，<code>content</code>属性是对应的字段内容。这两个属性与 HTTP 协议相关，属于高级用法，这里就不详细介绍了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码可以覆盖 HTTP 回应的<code>Content-Security-Policy</code>字段。</p><p>下面是另一些例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Type=text/html; charset=utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;30;URL=&#x27;http://website.com&#x27;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="base"><code>&lt;base&gt;</code><a class="header-anchor" href="#base">⁍</a></h3><p><code>&lt;base&gt;</code>标签指定网页内部的所有相对 URL 的计算基准。</p><p>整张网页 <strong>只能有一个</strong> <code>&lt;base&gt;</code>标签，而且只能放在<code>&lt;head&gt;</code>里面。它是单独使用的标签， <strong>没有闭合标签</strong> ，下面是一个例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.example.com/files/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;base&gt;</code>标签的<code>href</code>属性给出计算的基准网址，<code>target</code>属性给出如何打开链接的说明（参见《链接》一章）。已知计算基准是<code>https://www.example.com/files/</code>，那么相对 URL <code>foo.html</code>，就可以转成绝对 URL <code>https://www.example.com/files/foo.html</code>。</p><p>注意，<code>&lt;base&gt;</code>标签必须至少具有<code>href</code>属性或<code>target</code>属性之一。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://foo.com/app/&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一旦设置了<code>&lt;base&gt;</code>，就对整个网页都有效。</p><p>尤其需要注意 <strong>锚点</strong> ，这时锚点也是针对<code>&lt;base&gt;</code>计算的，而不是针对当前网页的 URL。</p><div class="note flat"><p>更多有关URL的介绍见：</p><p><a href="https://wangdoc.com/html/url.html">URL 简介 - HTML 教程 - 网道 (wangdoc.com)</a></p><p>更多有关编码的内容见：</p><p><a href="https://wangdoc.com/html/encode.html">HTML 字符编码 - HTML 教程 - 网道 (wangdoc.com)</a></p><blockquote><p>HTML 标签本身不能使用码点表示，否则浏览器会认为这是所要显示的文本内容，而不是标签。比如，<code>&lt;p&gt;</code>一旦写成<code>&lt;p&gt;</code>或者<code>&lt;p&gt;</code>，浏览器就不再认为这是标签了，而会当作文本内容将其显示为<code>&lt;p&gt;</code>。</p></blockquote></div><h2 id="元素的全局属性">元素的全局属性<a class="header-anchor" href="#元素的全局属性">⁍</a></h2><ol><li><p><strong>id</strong> ：唯一标识符，不能包含空格。在id前加“#”可以用做锚点。</p></li><li><p><strong>class</strong> ：元素可以同时具有多个 class，它们之间使用空格分隔。</p></li><li><p><strong>title</strong> ：<code>title</code>属性用来为元素添加附加说明。大多数浏览器中，鼠标悬浮在元素上面时，会将<code>title</code>属性值作为浮动提示，显示出来。</p></li><li><p><strong>tabindex</strong> ：<code>tabindex</code>属性的值是一个整数，表示用户按下 Tab 键的时候，网页焦点转移的顺序。不同的属性值有不同的含义。</p><ul><li><p>负整数：该元素可以获得焦点（比如使用 JavaScript 的<code>focus()</code>方法），但不参与 Tab 键对网页元素的遍历。这个值通常是<code>-1</code>。</p></li><li><p><code>0</code>：该元素参与 Tab 键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。</p></li><li><p>正整数：网页元素按照从小到大的顺序（1、2、3、……），参与 Tab 键的遍历。如果多个元素的<code>tabindex</code>属性相同，则按照在网页源码里面出现的顺序遍历。</p></li></ul><p>如果网页所有元素都没有设置<code>tabindex</code>，那么只有那些 <strong>默认可以遍历的元素（比如链接、输入框等）</strong> 才能参与 Tab 键的遍历，顺序由其在源码的位置决定。</p></li><li><p><strong>accesskey</strong> ：指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。 <strong>必须配合功能键，一起按下才会生效。</strong> Chrome 浏览器在 Windows 系统和 Linux 系统的快捷键是<code>Alt + 字符键</code>，在 Mac 系统的快捷键是<code>Ctrl + Alt + 字符键</code>。</p></li><li><p><strong>style</strong> ：指定当前元素的 CSS 样式</p></li><li><p><strong>hidden</strong> : 注意，CSS 的可见性设置，高于<code>hidden</code>属性。如果 CSS 设为该元素可见，<code>hidden</code>属性将无效。</p></li><li><p><strong>lang</strong> ： <code>lang</code>属性指定网页元素使用的语言。必须符合 <a href="https://www.ietf.org/rfc/bcp/bcp47.txt">BCP47</a> 的标准。</p></li><li><p><strong>dir</strong> ：表示文字的阅读方向，有三个可能的值。<code>ltr</code>/<code>rtr</code>/<code>auto</code></p></li><li><p><strong>contenteditable</strong> ： 允许用户修改内容。两个值：<code>true</code>/<code>false</code>。鼠标单击句子，就可以进入编辑状态，用户可以改变句子的内容。当然，除非提交到服务器，否则刷新页面还是显示原来的内容。</p><p>鼠标单击句子，就可以进入编辑状态，用户可以改变句子的内容。当然，除非提交到服务器，否则刷新页面还是显示原来的内容。</p><p><strong>该属性是枚举属性，不是布尔属性，规范的写法是最好带上属性值。</strong> （下面的<code>spellcheck</code>也是这样）</p></li><li><p><strong>spellcheck</strong> ：是否打开拼写检查功能。只在编辑时生效，即<code>contenteditable=&quot;true&quot;</code></p></li><li><p><strong>data-</strong> ：<code>data-</code>属性用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在<code>data-</code>属性。</p><p><code>data-</code>属性只能通过 CSS 或 JavaScript 利用，下面是 CSS 的例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* HTML 代码如下</span><br><span class="hljs-comment">&lt;div data-role=&quot;mobile&quot;&gt;</span><br><span class="hljs-comment">Mobile only content</span><br><span class="hljs-comment">&lt;/div&gt;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[data-role=<span class="hljs-string">&quot;mobile&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">display</span>:none;<br>&#125;<br><br><span class="hljs-comment">/* HTML 代码如下</span><br><span class="hljs-comment">&lt;div class=&quot;test&quot; data-content=&quot;This is the div content&quot;&gt;test&lt;/div&gt;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-class">.test</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br><span class="hljs-selector-class">.test</span>:after &#123;<br>  content: <span class="hljs-built_in">attr</span>(data-content);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>事件处理属性</strong> ： event handler，响应用户的动作。这些属性的值都是 JavaScript 代码：</p><blockquote><p>onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting</p></blockquote></li></ol><h2 id="html语义结构">HTML语义结构<a class="header-anchor" href="#html语义结构">⁍</a></h2><ul><li><strong>结构化标记</strong> ：可用来描述标题和段落的元素</li><li><strong>语义化标记</strong> ：表达特定含义的标记。例如在一个句子中的什么位置加入强调内容，也可能标明是一个引用（以及引用的作者），或者标明是一个缩写词的全称等等。</li></ul><div class="note flat"><p>TODO: 补充HTML语义化的好处</p></div><p>语义良好的网页，</p><ol><li>天然具有良好的结构，</li><li>对于开发者易读易写，容易维护，</li><li>也能帮助计算机更好地处理网页内容。</li></ol><p><strong>常用标签：</strong></p><ul><li><p><code>header</code>： <mark>不是head!!</mark>  可以放网站导航、搜索栏、文章标题、作者信息等。（不可以嵌套<code>header</code>/<code>footer</code>）</p></li><li><p><code>footer</code>：比如版权信息等（不可以嵌套<code>header</code>/<code>footer</code>）</p></li><li><p><code>main</code>：主题内容。一个页面只能有一个。顶层标签。</p></li><li><p><code>article</code>：一段完整的内容，比如一篇文章。</p></li><li><p><code>aside</code>：与网页或文章主要内容间接相关的部分。（侧边栏、补充信息、评论、注释）不一定非要在侧边。</p></li><li><p><code>section</code>：一个含有主题的独立部分，通常用在文档里面表示一个章节。总是多个一起使用，一个页面不能只有一个<code>&lt;section&gt;</code>。比如<code>&lt;article&gt;</code>包含了两个<code>&lt;section&gt;</code>，代表两章。适合幻灯片展示的页面</p></li><li><p><code>nav</code>：放置页面或文档的导航信息。一个页面可以有多个<code>&lt;nav&gt;</code>，比如一个用于站点导航，另一个用于文章导航。里面通常是列表</p></li><li><p><code>h1</code> ~ <code>h6</code>：标题</p></li><li><p><code>hgroup</code>：如果主标题包含多级标题（比如带有副标题），那么可以使用<code>&lt;hgroup&gt;</code>标签，将多级标题放在其中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hgroup</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Heading 1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Subheading 1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Subheading 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hgroup</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，<code>&lt;hgroup&gt;</code>只能包含<code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>，不能包含其他标签。</p></li></ul><h2 id="基本标签">基本标签<a class="header-anchor" href="#基本标签">⁍</a></h2><h3 id="文本标签">文本标签<a class="header-anchor" href="#文本标签">⁍</a></h3><div class="note primary flat"><p>注：加粗的表示是语义标签</p></div><ol><li><p><code>&lt;div&gt;</code> ：表示一个区块。提供 CSS 的钩子，用来指定各种样式。</p></li><li><p><code>&lt;p&gt;</code>：文章的一个段落（paragraph）。</p></li><li><p><code>&lt;span&gt;</code>：通用目的的行内标签（即不会产生换行）。通常用作 CSS 样式的钩子，如果需要对某些行内内容指定样式</p></li><li><p><code>&lt;br&gt;</code>，<code>&lt;wbr&gt;</code>：换行/可选断行。没有闭合标签。<code>&lt;wbr&gt;</code>标签跟<code>&lt;br&gt;</code>很相似，表示一个可选的断行。如果一行的宽度足够，则不断行；如果宽度不够，需要断行，就在<code>&lt;wbr&gt;</code>的位置的断行。</p><p><strong>注意，块级元素的间隔，不要使用<code>&lt;br&gt;</code>来产生，而要使用 CSS 指定。</strong></p></li><li><p><code>&lt;hr&gt;</code>：水平分割线。没有闭合标签。</p><p><strong>该标签是历史遗留下来的，建议尽量避免使用。主题之间的分隔可以使用<code>&lt;section&gt;</code>，如果想要水平线的效果，可以使用 CSS。</strong></p></li><li><p><code>&lt;pre&gt;</code>： <strong>块级元素</strong> ，表示保留原来的格式（preformatted），即浏览器会保留该标签内部原始的换行和空格。</p></li><li><p><strong><code>&lt;strong&gt;</code></strong> ，<code>&lt;b&gt;</code>： <strong>行内元素</strong> 。加粗，优先使用含有语义的<code>&lt;strong&gt;</code>标签。</p></li><li><p><strong><code>&lt;em&gt;</code></strong> ，<code>&lt;i&gt;</code>： <strong>行内元素</strong> 。强调，一般情况下，会以斜体表示。优先使用含有语义的<code>&lt;em&gt;</code>标签。</p></li><li><p><code>&lt;sub&gt;</code>，<code>&lt;sup&gt;</code>，<code>&lt;var&gt;</code>：行内元素，下标/上标/代码或数学公式的变量</p></li><li><p><code>&lt;u&gt;</code>， <code>&lt;s&gt;</code> ：行内元素。提示存在的问题（浏览器默认用下划线渲染）/删除线。</p></li><li><p><strong><code>&lt;blockquote&gt;</code>，<code>&lt;cite&gt;</code>，<code>&lt;q&gt;</code></strong> ：</p><ul><li><p>.<code>&lt;blockquote&gt;</code> 是一个 <strong>块级标签</strong> ，表示引用他人的话。浏览器会在样式上，与正常文本区别显示。<code>&lt;blockquote&gt;</code>标签有一个<code>cite</code>属性，它的值是一个网址，表示引言来源，不会显示在网页上。</p></li><li><p>.<code>&lt;cite&gt;</code> 标签表示引言出处或者作者，浏览器默认使用斜体显示这部分内容。不一定跟<code>&lt;blockquote&gt;</code>一起用。</p></li><li><p>.<code>&lt;q&gt;</code> 是一个 <strong>行内标签</strong> （不换行），也表示引用。也有<code>cite</code>属性。浏览器默认并且会自动添加半角的双引号。</p></li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>示例</span></div>    <div class="hide-content"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;https://quote.example.com&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>天才就是 1% 的天赋和99%的汗水。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>-- 爱迪生<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  莎士比亚的《哈姆雷特》有一句著名的台词：<br>  <span class="hljs-tag">&lt;<span class="hljs-name">q</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;https://quote.example.com&quot;</span>&gt;</span>活着还是死亡，这是一个问题。<span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203201707337.png" alt="image-20220320170735016"></p></div></div></li><li><p><strong><code>&lt;code&gt;</code></strong> ： <strong>行内元素</strong> ，表示标签内容是计算机代码，浏览器默认会以等宽字体显示。如果要表示多行代码，<code>&lt;code&gt;</code>标签必须放在<code>&lt;pre&gt;</code>内部。</p></li><li><p><strong><code>&lt;kbd&gt;</code>，<code>&lt;samp&gt;</code></strong> ：</p><ul><li>.<code>&lt;kbd&gt;</code> ： <strong>行内元素</strong> ，用户从键盘输入的内容，现在扩展到各种输入，包括语音输入。<code>&lt;kbd&gt;</code>可以嵌套，方便指定样式。<a href="https://zhuanlan.zhihu.com/p/131529323">译]您知道 HTML 的键盘标签吗？ - 知乎 (zhihu.com)</a></li><li>.<code>&lt;samp&gt;</code> ： <strong>行内元素</strong> ，表示计算机程序输出内容的一个例子。浏览器默认以等宽字体显示。</li></ul></li><li><p><strong><code>&lt;mark&gt;</code></strong> ： <strong>行内标签</strong> ，表示突出显示的内容。Chrome 浏览器默认会以亮黄色背景，显示该标签的内容（ <strong>不要只为了高亮的效果，而使用这个标签，因为不能保证浏览器的处理方式。如果要保证高亮，还是要使用 CSS 样式。</strong> ）。还可以用于在搜索结果中，标记出匹配的关键词。</p></li><li><p><strong><code>&lt;small&gt;</code></strong> ：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。 <strong>行内标签</strong></p></li><li><p><strong><code>&lt;time&gt;</code>，<code>&lt;data&gt;</code></strong> ： <strong>行内标签</strong> 。提供机器可读的格式。（前者与事件有关）</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><p><code>&lt;time&gt;</code>的<code>datetime</code>属性，用来指定机器可读的日期，可以有多种格式。</p><ul><li>有效年份：<code>2011</code></li><li>有效月份：<code>2011-11</code></li><li>有效日期：<code>2011-11-18</code></li><li>无年份的日期：<code>11-18</code></li><li>年度的第几周：<code>2011-W47</code></li><li>有效时间：<code>14:54</code>、<code>14:54:39</code>、<code>14:54:39.929</code></li><li>日期和时间：<code>2011-11-18T14:54:39.929</code></li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>示例</span></div>    <div class="hide-content"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>音乐会在<span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;20:00&quot;</span>&gt;</span>晚上八点<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span>开始。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>本次马拉松比赛第一名是<span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;39&quot;</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>。<br></code></pre></td></tr></table></figure></div></div></li><li><p><strong><code>&lt;address&gt;</code></strong> ：<strong>块级元素</strong> ，表示某人或某个组织的联系方式。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>注意点</span></div>    <div class="hide-content"><p>（1）如果是文章里提到的地址（比如提到搬家前的地址），而不是联系信息，不要使用<code>&lt;address&gt;</code>标签。</p><p>（2）<code>&lt;address&gt;</code>的内容不得有非联系信息，比如发布日期。</p><p>（3）<code>&lt;address&gt;</code>不能嵌套，并且内部不能有标题标签（<code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>），也不能有<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>等标签。</p><p>（4）通常，<code>&lt;address&gt;</code>会放在<code>&lt;footer&gt;</code>里面，下面是一个例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br>    文章的相关问题请联系<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:zhangsan@example.com&quot;</span>&gt;</span>张三<br>    McClure<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>。<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></div></div></li><li><p><strong><code>&lt;abbr&gt;</code></strong>  ：<strong>行内元素</strong> ，表示标签内容是一个 <strong>缩写</strong> 。它的<code>title</code>属性给出缩写的完整形式，或者缩写的描述。鼠标悬停在该元素上方时，<code>title</code>属性值作为提示，会完整显示出来。</p></li><li><p><strong><code>&lt;ins&gt;</code>，<code>&lt;del&gt;</code></strong> ： <strong>行内元素</strong> 。原始文档添加（insert）/删除（delete）的内容。</p><p>浏览器默认为<code>&lt;del&gt;</code>标签的内容加上删除线，为<code>&lt;ins&gt;</code>标签的内容加上下划线。</p><p>这两个标签都有以下属性。</p><ul><li><code>cite</code>：该属性的值是一个 URL，表示该网址可以解释本次删改。</li><li><code>datetime</code>：表示删改发生的时间。</li></ul></li><li><p><strong><code>&lt;dfn&gt;</code></strong> ： <strong>行内元素</strong> ，表示标签内容是一个术语（definition），本段或本句包含它的定义。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>用法示例</span></div>    <div class="hide-content"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>通过 TCP/IP 协议连接的全球性计算机网络，叫做<br><span class="hljs-tag">&lt;<span class="hljs-name">dfn</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;全球性计算机网络&quot;</span>&gt;</span>Internet<span class="hljs-tag">&lt;/<span class="hljs-name">dfn</span>&gt;</span>。<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dfn</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;acquired immune deficiency syndrome&quot;</span>&gt;</span>AIDS<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dfn</span>&gt;</span><br>的全称是获得性免疫缺陷综合征。<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></div></div></li><li><p><strong><code>&lt;ruby&gt;</code></strong> ：表示文字的语音注释，主要用于东亚文字，比如汉语拼音和日语的片假名。 <strong>是行内元素，同时也是容器</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>简单示例</span></div>    <div class="hide-content"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html">示例：<span class="hljs-tag">&lt;<span class="hljs-name">ruby</span>&gt;</span><br>汉<span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>han<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><br>字<span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>zi<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><br>勉<span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>べん<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span><br>強<span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>きょう<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ruby</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 下面是兼容的写法 --&gt;</span><br>示例：<span class="hljs-tag">&lt;<span class="hljs-name">ruby</span>&gt;</span><br>汉<span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>(<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>han<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>)<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span><br>字<span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>(<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>zi<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>)<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span><br>勉<span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>(<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>べん<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>)<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span><br>強<span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>(<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>きょう<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rp</span>&gt;</span>)<span class="hljs-tag">&lt;/<span class="hljs-name">rp</span>&gt;</span>　<br><span class="hljs-tag">&lt;/<span class="hljs-name">ruby</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203201740231.png" alt="image-20220320174030111"></p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>具体用法</span></div>    <div class="hide-content"><p><code>&lt;ruby&gt;</code>的内部还有许多配套的标签。</p><p><strong>（1）<code>&lt;rp&gt;</code></strong></p><p><code>&lt;rp&gt;</code>标签的用处，是为不支持语音注释的浏览器，提供一个兼容方案。对于那些支持语音注释的浏览器，该标签的内容不显示。</p><p><code>&lt;rp&gt;</code>标签一般用于放置圆括号，如果遇到不支持的浏览器，就会将语音注释显示在括号里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;ruby&gt;<br>汉&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;<br>字&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;<br>&lt;/ruby&gt;<br></code></pre></td></tr></table></figure><p>上面代码在不支持语音注释的浏览器中，渲染结果为<code>汉(han)字(zi)</code>。遇到支持语音注释的浏览器，就不会显示圆括号。</p><p><strong>（2）<code>&lt;rt&gt;</code></strong></p><p><code>&lt;rt&gt;</code>标签用于放置语音注释。</p><p><strong>（3）<code>&lt;rb&gt;</code></strong></p><p><code>&lt;rb&gt;</code>标签用于划分文字单位，与语音注释一一对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;ruby&gt;<br>  &lt;rb&gt;汉&lt;/rb&gt;&lt;rb&gt;字&lt;/rb&gt;<br>  &lt;rp&gt;(&lt;/rp&gt;<br>  &lt;rt&gt;han&lt;/rt&gt;<br>  &lt;rt&gt;zi&lt;/rt&gt;<br>  &lt;rp&gt;)&lt;/rp&gt;<br>&lt;/ruby&gt;<br></code></pre></td></tr></table></figure><p>上面例子中，<code>汉字</code>这两个字是写在一起的，<code>&lt;rb&gt;</code>标签用于每个字划分出来，跟<code>&lt;rt&gt;</code>标签一一对应。</p><p><strong>（4）<code>&lt;rbc&gt;</code>，<code>&lt;rtc&gt;</code></strong></p><p><code>&lt;rbc&gt;</code>标签表示一组文字，通常包含多个<code>&lt;rb&gt;</code>元素。<code>&lt;rtc&gt;</code>标签表示一组语音注释，跟<code>&lt;rbc&gt;</code>对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;ruby style=&quot;ruby-position: under;&quot;&gt;<br>  &lt;rbc&gt;<br>    &lt;rb&gt;汉&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;<br>    &lt;rb&gt;字&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;<br>  &lt;/rbc&gt;<br>  &lt;rtc style=&quot;ruby-position: over;&quot;&gt;<br>    &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Chinese&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;<br>  &lt;/rtc&gt;<br>&lt;/ruby&gt;<br></code></pre></td></tr></table></figure><p>上面例子中，<code>汉字</code>这两个字有两组语音注释，分别是汉语拼音与英语。一组语音注释放在<code>&lt;rbc&gt;</code>标签中，另一组语音注释放在<code>&lt;rtc&gt;</code>，用来对应<code>&lt;rbc&gt;</code>。同时，分别使用<code>style</code>属性，指定汉语拼音显示在文字下方，英语显示在文字上方。</p><p>注意，Chrome 浏览器目前不支持这两个标签。</p></div></div></li><li><p><strong><code>&lt;bdo&gt;</code>，<code>&lt;bdi&gt;</code></strong></p><ul><li><code>&lt;bdo&gt;</code>标签里面的文字，会以相反的方向渲染。<code>dir</code>属性，指定具体的文字方向。它有两个值，<code>ltr</code>表示从左到右，<code>rtl</code>表示从右到左。</li><li><code>&lt;bdi&gt;</code>标签用于不确定文字方向的情况。由浏览器自己决定。</li></ul></li></ol><h3 id="列表标签">列表标签<a class="header-anchor" href="#列表标签">⁍</a></h3><ol><li><p><code>&lt;ol&gt;</code>：有序列表 <strong>容器</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><p><strong>（1）reversed</strong></p><p><code>reversed</code>属性产生倒序的数字列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">reversed</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，列表项 A、B、C 前面，产生的编号是3、2、1。</p><p><strong>（2）start</strong></p><p><code>start</code>属性的值是一个整数，表示数字列表的起始编号。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，列表项 A、B、C 前面，产生的编号是5、6、7。</p><p><strong>（3）type</strong></p><p><code>type</code>属性指定数字编号的样式。目前，浏览器支持以下样式。</p><ul><li><code>a</code>：小写字母</li><li><code>A</code>：大写字母</li><li><code>i</code>：小写罗马数字</li><li><code>I</code>：大写罗马数字</li><li><code>1</code>：整数（默认值）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，列表项 A、B、C 前面的编号，分别是英文小写字母a、b、c。</p><p>注意，即使编号是字母，<code>start</code>属性也依然使用整数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项 C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>type</code>属性指定编号采用小写英文字母，<code>start</code>属性等于<code>3</code>，表示从<code>c</code>开始编号。</p></div></div></li><li><p><code>&lt;ul&gt;</code>：无序列表 <strong>容器</strong></p></li><li><p><code>&lt;li&gt;</code>：列表项。有序列表<code>&lt;ol&gt;</code>之中，<code>&lt;li&gt;</code>有一个<code>value</code>属性，定义当前列表项的编号，后面列表项会从这个值开始编号。</p></li><li><p><code>&lt;dl&gt;</code>，<code>&lt;dt&gt;</code>，<code>&lt;dd&gt;</code>。 <code>&lt;dl&gt;</code>标签是一个 <strong>块级元素</strong> ，表示一组 <strong>术语</strong> 的列表（description list），常用来定义 <strong>词汇表</strong> 。术语名（description term）由<code>&lt;dt&gt;</code>标签定义，术语解释（description detail）由<code>&lt;dd&gt;</code>标签定义。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>示例</span></div>    <div class="hide-content"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>CPU<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>中央处理器<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Memory<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>内存<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>HD<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Hard Disk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>硬盘<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><dl>  <dt>CPU</dt>  <dd>中央处理器</dd>  <dt>Memory</dt>  <dd>内存</dd>  <dt>HD</dt>  <dt>Hard Disk</dt>  <dd>硬盘</dd></dl><p>多个术语（<code>&lt;dt&gt;</code>）对应一个解释（<code>&lt;dd&gt;</code>），或者多个解释（<code>&lt;dd&gt;</code>）对应一个术语（<code>&lt;dt&gt;</code>），都是合法的。</p></div></div></li></ol><h3 id="图像标签">图像标签<a class="header-anchor" href="#图像标签">⁍</a></h3><h4 id="img-标签和属性"><code>&lt;img&gt;</code>标签和属性<a class="header-anchor" href="#img-标签和属性">⁍</a></h4><p>行内元素，无闭合标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.jpg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>必须属性为<code>src</code>。</p><p>其他属性：</p><ul><li><p><strong>alt 属性</strong></p></li><li><p><strong>width 属性，height 属性</strong>  （更推荐用css样式）</p></li><li><p><strong>srcset，sizes</strong> 见响应式</p></li><li><p><strong>referrerpolicy</strong></p><p><code>&lt;img&gt;</code>导致的图片加载的 HTTP 请求，默认会带有<code>Referer</code>的头信息。<code>referrerpolicy</code>属性对这个行为进行设置。</p></li><li><p><strong>crossorigin</strong> ：跨域请求</p><p><code>crossorigin</code>属性用来告诉浏览器，是否采用跨域的形式下载图片，默认是不采用。</p><p>简单说，只要打开了这个属性，HTTP 请求的头信息里面，就会加入<code>origin</code>字段，给出请求发出的域名，不打开这个属性就不加。</p><p>一旦打开该属性，它可以设为两个值。</p><ul><li><code>anonymous</code>：跨域请求不带有用户凭证（通常是 Cookie），打开属性后的默认值。</li><li><code>use-credentials</code>：跨域请求带有用户凭证。</li></ul><p>详解：<a href="https://www.jianshu.com/p/a82b491ec566">img元素中的crossorigin属性 - 简书 (jianshu.com)</a></p></li><li><p><strong>loading</strong></p><p><code>loading</code>属性改变了这个行为，可以指定图片的懒加载，即图片默认不加载，只有即将滚动进入视口，变成用户可见时才会加载，这样就节省了带宽。</p><p><code>loading</code>属性可以取以下三个值。</p><blockquote><ul><li><code>auto</code>：浏览器默认行为，等同于不使用<code>loading</code>属性。</li><li><code>lazy</code>：启用懒加载。</li><li><code>eager</code>：立即加载资源，无论它在页面上的哪个位置。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.png&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;…&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于行内图片的懒加载，可能会导致页面布局重排，所以使用这个属性的时候，最好指定图片的高和宽。</p></li></ul><h4 id="figure-容器和图形说明figcaption"><code>&lt;figure&gt;</code>容器和图形说明<code>figcaption</code><a class="header-anchor" href="#figure-容器和图形说明figcaption">⁍</a></h4><p><code>&lt;figure&gt;</code>标签是一个 <strong>语义容器</strong> ，可以理解为一个图像区块，将图像和相关信息封装在一起（还可以封装引言、代码、诗歌等等。）</p><p><code>&lt;figcaption&gt;</code>是它的可选子元素，表示图像的文本描述，通常用于放置标题，可以出现多个。</p><h4 id="html响应式图像">HTML响应式图像<a class="header-anchor" href="#html响应式图像">⁍</a></h4><h5 id="img标签的srcset属性和sizes属性"><code>img</code>标签的srcset属性和<code>sizes</code>属性<a class="header-anchor" href="#img标签的srcset属性和sizes属性">⁍</a></h5><p><code>srcset</code>属性用来指定多张图像，适应 <strong>不同像素密度</strong> 的屏幕。</p><p><code>sizes</code>属性列出不同设备的图像显示 <strong>宽度/大小</strong> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;foo-160.jpg 160w,</span></span><br><span class="hljs-string"><span class="hljs-tag">             foo-320.jpg 320w,</span></span><br><span class="hljs-string"><span class="hljs-tag">             foo-640.jpg 640w,</span></span><br><span class="hljs-string"><span class="hljs-tag">             foo-1280.jpg 1280w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 440px) 100vw,</span></span><br><span class="hljs-string"><span class="hljs-tag">            (max-width: 900px) 33vw,</span></span><br><span class="hljs-string"><span class="hljs-tag">            254px&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo-1280.jpg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器根据当前设备的宽度，从<code>sizes</code>属性获得图像的显示宽度，然后从<code>srcset</code>属性找出最接近该宽度的图像，进行加载。</p><p>假定当前设备的屏幕宽度是<code>480px</code>，浏览器从<code>sizes</code>属性查询得到，图片的显示宽度是<code>33vw</code>（即33%），等于<code>160px</code>。<code>srcset</code>属性里面，正好有宽度等于<code>160px</code>的图片，于是加载<code>foo-160.jpg</code>。</p><p>如果省略<code>sizes</code>属性，那么浏览器将根据实际的图像显示宽度，从<code>srcset</code>属性选择最接近的图片。一旦使用<code>sizes</code>属性，就必须与<code>srcset</code>属性搭配使用，单独使用<code>sizes</code>属性是无效的。</p><h4 id="picture-容器标签"><code>&lt;picture&gt;</code>容器标签<a class="header-anchor" href="#picture-容器标签">⁍</a></h4><p>容器标签，内部使用<code>&lt;source&gt;</code>和<code>&lt;img&gt;</code>，指定不同情况下加载的图像。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;homepage-person@desktop.png,</span></span><br><span class="hljs-string"><span class="hljs-tag">                  homepage-person@desktop-2x.png 2x&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 990px)&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;homepage-person@tablet.png,</span></span><br><span class="hljs-string"><span class="hljs-tag">                  homepage-person@tablet-2x.png 2x&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 750px)&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;homepage-person@mobile.png,</span></span><br><span class="hljs-string"><span class="hljs-tag">               homepage-person@mobile-2x.png 2x&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Shopify Merchant, Corrine Anestopoulos&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器按照<code>&lt;source&gt;</code>标签出现的顺序，依次判断当前设备是否满足<code>media</code>属性的媒体查询表达式，如果满足就加载<code>srcset</code>属性指定的图片文件，并且不再执行后面的<code>&lt;source&gt;</code>标签和<code>&lt;img&gt;</code>标签。</p><p>除了响应式图像，<code>&lt;picture&gt;</code>标签还可以用来选择不同格式的图像。<code>&lt;source&gt;</code>标签的<code>type</code>属性给出图像的 MIME 类型，<code>srcset</code>是对应的图像 URL。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/svg+xml&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;logo.xml&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/webp&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;logo.webp&quot;</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;ACME Corp&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="链接标签">链接标签<a class="header-anchor" href="#链接标签">⁍</a></h3><p><code>&lt;a&gt;</code>/<code>&lt;link&gt;</code>/<code>&lt;script&gt;</code>/<code>&lt;noscript&gt;</code></p><h4 id="a"><code>&lt;a&gt;</code><a class="header-anchor" href="#a">⁍</a></h4><p>属性：</p><ul><li><p><strong>href</strong></p><ul><li>特殊值：邮件链接： <code>mailto:xxx@xxx</code>（可不指定邮箱）</li><li>特殊值：电话链接：<code>tel:xxxxxxxxxxx</code></li></ul></li><li><p><strong>hreflang</strong> ：提示语言</p></li><li><p><strong>title</strong> ：鼠标悬停提示说明信息。</p></li><li><p><strong>target</strong> ：如何展示打开的链接。</p><ul><li><code>_self</code>：当前窗口打开，这是默认值。</li><li><code>_blank</code>：新窗口打开。</li><li><code>_parent</code>：上层窗口打开，这通常用于从父窗口打开的子窗口，或者<code>&lt;iframe&gt;</code>里面的链接。如果当前窗口没有上层窗口，这个值等同于<code>_self</code>。</li><li><code>_top</code>：顶层窗口打开。如果当前窗口就是顶层窗口，这个值等同于<code>_self</code>。</li><li>自定义名称：比如两个链接都在名叫test的窗口打开。</li></ul></li><li><p><strong>rel</strong> ：说明链接与当前页面的关系。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>常见属性值</span></div>    <div class="hide-content"><ul><li><code>alternate</code>：当前文档的另一种形式，比如翻译。</li><li><code>author</code>：作者链接。</li><li><code>bookmark</code>：用作书签的永久地址。</li><li><code>external</code>：当前文档的外部参考文档。</li><li><code>help</code>：帮助链接。</li><li><code>license</code>：许可证链接。</li><li><code>next</code>：系列文档的下一篇。</li><li><code>nofollow</code>：告诉搜索引擎忽略该链接，主要用于用户提交的内容，防止有人企图通过添加链接，提高该链接的搜索排名。</li><li><code>noreferrer</code>：告诉浏览器打开链接时，不要将当前网址作为 HTTP 头信息的<code>Referer</code>字段发送出去，这样可以隐藏点击的来源。</li><li><code>noopener</code>：告诉浏览器打开链接时，不让链接窗口通过 JavaScript 的<code>window.opener</code>属性引用原始窗口，这样就提高了安全性。</li><li><code>prev</code>：系列文档的上一篇。</li><li><code>search</code>：文档的搜索链接。</li><li><code>tag</code>：文档的标签链接。</li></ul></div></div></li><li><p><strong>referrerpolicy</strong> ：用于精确设定点击链接时，浏览器发送 HTTP 头信息的<code>Referer</code>字段的行为。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性值</span></div>    <div class="hide-content"><p>该属性可以取下面八个值：<code>no-referrer</code>、<code>no-referrer-when-downgrade</code>、<code>origin</code>、<code>origin-when-cross-origin</code>、<code>unsafe-url</code>、<code>same-origin</code>、<code>strict-origin</code>、<code>strict-origin-when-cross-origin</code>。</p><p>其中，<code>no-referrer</code>表示不发送<code>Referer</code>字段，<code>same-origin</code>表示同源时才发送<code>Referer</code>字段，<code>origin</code>表示只发送源信息（协议+域名+端口）。其他几项的解释，请查阅 HTTP 文档。</p></div></div></li><li><p><strong>ping</strong> ：指定一个网址，用户点击的时候，会向该网址发出一个 POST 请求，通常用于跟踪用户的行为。</p></li><li><p><strong>type</strong> ：提示给出链接 URL 的 MIME 类型</p></li><li><p><strong>download</strong> ：表明当前链接用于下载，而不是跳转到另一个 URL。只在链接与网址同源时，才会生效。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>说明</span></div>    <div class="hide-content"><p>注意，如果链接点击后，服务器的 HTTP 回应的头信息设置了<code>Content-Disposition</code>字段，并且该字段的值与<code>download</code>属性不一致，那么该字段优先，下载时将显示其设置的文件名。</p><p><code>download</code>属性还有一个用途，就是有些地址不是真实网址，而是数据网址，比如<code>data:</code>开头的网址。这时，<code>download</code>属性可以为虚拟网址指定下载的文件名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;data:,Hello%2C%20World!&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面链接点击后，会打开一个虚拟网页，上面显示<code>Hello World!</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><br><span class="hljs-tag">  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;data:,Hello%2C%20World!&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;hello.txt&quot;</span></span><br><span class="hljs-tag">&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面链接点击后，下载的<code>hello.txt</code>文件内容就是“Hello, World!”。</p></div></div></li></ul><h4 id="link"><code>&lt;link&gt;</code><a class="header-anchor" href="#link">⁍</a></h4><p>主要用于加载与网页相关的外部资源文件，通常放在<code>&lt;head&gt;</code>里。</p><p>如css样式、图标文件、相关文档链接等。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>举例</span></div>    <div class="hide-content"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- css样式引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;theme.css&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;default.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Default Style&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;fancy.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate stylesheet&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Fancy&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;basic.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate stylesheet&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Basic&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 图标引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/favicon.ico&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/x-icon&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;114x114&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon114.png&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;72x72&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon72.png&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 文档的相关链接引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/atom+xml&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/blog/news/atom&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></div></div><ol><li><p><code>rel</code>属性：表示外部资源与当前文档之间的关系，是<code>&lt;link&gt;</code>标签的必需属性。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>rel属性值</span></div>    <div class="hide-content"><ul><li><code>alternate</code>：文档的另一种表现形式的链接，比如打印版。</li><li><code>author</code>：文档作者的链接。</li><li><code>dns-prefetch</code>：要求浏览器提前执行指定网址的 DNS 查询。</li><li><code>help</code>：帮助文档的链接。</li><li><code>icon</code>：加载文档的图标文件。</li><li><code>license</code>：许可证链接。</li><li><code>next</code>：系列文档下一篇的链接。</li><li><code>pingback</code>：接收当前文档 pingback 请求的网址。</li><li><code>preconnect</code>：要求浏览器提前与给定服务器，建立 HTTP 连接。</li><li><code>prefetch</code>：要求浏览器提前下载并缓存指定资源，供下一个页面使用。它的优先级较低，浏览器可以不下载。</li><li><code>preload</code>：要求浏览器提前下载并缓存指定资源，当前页面稍后就会用到。它的优先级较高，浏览器必须立即下载。</li><li><code>prerender</code>：要求浏览器提前渲染指定链接。这样的话，用户稍后打开该链接，就会立刻显示，感觉非常快。</li><li><code>prev</code>：表示当前文档是系列文档的一篇，这里给出上一篇文档的链接。</li><li><code>search</code>：提供当前网页的搜索链接。</li><li><code>stylesheet</code>：加载一张样式表。</li></ul></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>更多示例</span></div>    <div class="hide-content"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 作者信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;humans.txt&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 版权信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;license&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;copyright.html&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 另一个语言的版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://es.example.com/&quot;</span> <span class="hljs-attr">hreflang</span>=<span class="hljs-string">&quot;es&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 联系方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://google.com/profiles/someone&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/html&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:name@example.com&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;sms:+15035550125&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 历史资料 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;archives&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/archives/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 目录 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 导航 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;first&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;last&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=42&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prev&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;next&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=3&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></div></div></li><li><p><code>rel</code>、<code>as</code>、<code>type</code>与资源预加载</p><p><code>as</code>属性，告诉浏览器预处理资源的类型</p><ul><li>“script”</li><li>“style”</li><li>“image”</li><li>“media”</li><li>“document”</li></ul><p><code>type</code>属性，进一步明确 MIME 类型。</p><p><strong>5种预加载</strong></p><ol><li><p><code>&lt;link rel=&quot;preload&quot;&gt;</code></p><p>尽快下载并缓存资源（如脚本或样式表），该指令优先级较高，浏览器肯定会执行。</p></li><li><p><code>&lt;link rel=&quot;prefetch&quot;&gt;</code></p><p>后续的页面需要某个资源，并且希望预加载该资源，以便加速页面渲染。该指令不是强制性的，优先级较低</p></li><li><p><code>&lt;link rel=&quot;preconnect&quot;&gt;</code></p><p>提前与某个域名建立 TCP 连接。</p></li><li><p><code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code></p><p>浏览器提前执行某个域名的 DNS 解析</p></li><li><p><code>&lt;link rel=&quot;prerender&quot;&gt;</code></p><p>浏览器加载某个网页，并且提前渲染它。</p></li></ol></li><li><p><code>media</code>属性</p><p>给出外部资源生效的媒介条件。</p><p>例如：</p><ul><li><code>media=&quot;print&quot;</code></li><li><code>media=&quot;screen and (max-width: 600px)&quot;</code></li></ul></li><li><p>其他属性</p><ul><li><code>crossorigin</code>：加载外部资源的跨域设置。</li><li><code>href</code>：外部资源的网址。</li><li><code>referrerpolicy</code>：加载时<code>Referer</code>头信息字段的处理方法。</li><li><code>as</code>：<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>时，设置外部资源的类型。</li><li><code>type</code>：外部资源的 MIME 类型，目前仅用于<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>的情况。</li><li><code>title</code>：加载样式表时，用来标识样式表的名称。</li><li><code>sizes</code>：用来声明图标文件的尺寸，比如加载苹果手机的图标文件。</li></ul></li></ol><h4 id="scipt"><code>&lt;scipt&gt;</code><a class="header-anchor" href="#scipt">⁍</a></h4><p>加载脚本代码，目前主要是加载 JavaScript 代码。</p><p>也可以加载外部脚本，<code>src</code>属性给出外部脚本的地址。</p><p><code>type</code>属性也可以设成<code>module</code>，表示这是一个 ES6 模块，不是传统脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>对于那些不支持 ES6 模块的浏览器，可以设置<code>nomodule</code>属性。支持 ES6 模块的浏览器，会不加载指定的脚本。这个属性通常与<code>type=&quot;module&quot;</code>配合使用，作为老式浏览器的回退方案。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;fallback.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>其他属性</span></div>    <div class="hide-content"><ul><li><code>async</code>：该属性指定 JavaScript 代码为异步执行，不是造成阻塞效果，JavaScript 代码默认是同步执行。</li><li><code>defer</code>：该属性指定 JavaScript 代码不是立即执行，而是页面解析完成后执行。</li><li><code>crossorigin</code>：如果采用这个属性，就会采用跨域的方式加载外部脚本，即 HTTP 请求的头信息会加上<code>origin</code>字段。</li><li><code>integrity</code>：给出外部脚本的哈希值，防止脚本被篡改。只有哈希值相符的外部脚本，才会执行。</li><li><code>nonce</code>：一个密码随机数，由服务器在 HTTP 头信息里面给出，每次加载脚本都不一样。它相当于给出了内嵌脚本的白名单，只有在白名单内的脚本才能执行。</li><li><code>referrerpolicy</code>：HTTP 请求的<code>Referer</code>字段的处理方法。</li></ul></div></div><h4 id="noscript"><code>&lt;noscript&gt;</code><a class="header-anchor" href="#noscript">⁍</a></h4><p>用于浏览器不支持或关闭 JavaScript 时，所要显示的内容。</p><h3 id="多媒体标签">多媒体标签<a class="header-anchor" href="#多媒体标签">⁍</a></h3><h4 id="video"><code>&lt;video&gt;</code><a class="header-anchor" href="#video">⁍</a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.mp4&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频，请下载<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;example.mp4&quot;</span>&gt;</span>视频文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>src</code>：视频文件的网址。</li><li><code>controls</code>：播放器是否显示控制栏。该属性是布尔属性，不用赋值，只要写上属性名，就表示打开。如果不想使用浏览器默认的播放器，而想使用自定义播放器，就不要使用该属性。</li><li><code>width</code>：视频播放器的宽度，单位像素。</li><li><code>height</code>：视频播放器的高度，单位像素。</li><li><code>autoplay</code>：视频是否自动播放，该属性为布尔属性。</li><li><code>loop</code>：视频是否循环播放，该属性为布尔属性。</li><li><code>muted</code>：是否默认静音，该属性为布尔属性。</li><li><code>poster</code>：视频播放器的封面图片的 URL。</li><li><code>preload</code>：视频播放之前，是否缓冲视频文件。这个属性仅适合没有设置<code>autoplay</code>的情况。它有三个值，分别是<code>none</code>（不缓冲）、<code>metadata</code>（仅仅缓冲视频文件的元数据）、<code>auto</code>（可以缓冲整个文件）。</li><li><code>playsinline</code>：iPhone 的 Safari 浏览器播放视频时，会自动全屏，该属性可以禁止这种行为。该属性为布尔属性。</li><li><code>crossorigin</code>：是否采用跨域的方式加载视频。它可以取两个值，分别是<code>anonymous</code>（跨域请求时，不发送用户凭证，主要是 Cookie），<code>use-credentials</code>（跨域时发送用户凭证）。</li><li><code>currentTime</code>：指定当前播放位置（双精度浮点数，单位为秒）。如果尚未开始播放，则会从这个属性指定的位置开始播放。</li><li><code>duration</code>：该属性只读，指示时间轴上的持续播放时间（总长度），值为双精度浮点数（单位为秒）。如果是流媒体，没有已知的结束时间，属性值为<code>+Infinity</code>。</li></ul></div></div><h4 id="audio"><code>&lt;audio&gt;</code><a class="header-anchor" href="#audio">⁍</a></h4><p>用于放置音频。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mp3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 音频，请直接下载<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;foo.mp3&quot;</span>&gt;</span>音频文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="note flat"><p>上次出现<code>source</code>是在<code>&lt;picture&gt;</code>标签那里</p></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>autoplay</code>：是否自动播放，布尔属性。</li><li><code>controls</code>：是否显示播放工具栏，布尔属性。如果不设置，浏览器不显示播放界面，通常用于背景音乐。</li><li><code>crossorigin</code>：是否使用跨域方式请求。</li><li><code>loop</code>：是否循环播放，布尔属性。</li><li><code>muted</code>：是否静音，布尔属性。</li><li><code>preload</code>：音频文件的缓冲设置。</li><li><code>src</code>：音频文件网址。</li></ul></div></div><h4 id="track"><code>&lt;track&gt;</code><a class="header-anchor" href="#track">⁍</a></h4><p>用于指定视频的字幕，格式是 WebVTT （<code>.vtt</code>文件），放置在<code>&lt;video&gt;</code>标签内部。它是一个单独使用的标签，没有结束标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sample.mp4&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">track</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;英文&quot;</span> <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;subtitles&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;subtitles_en.vtt&quot;</span> <span class="hljs-attr">srclang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">track</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;中文&quot;</span> <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;subtitles&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;subtitles_cn.vtt&quot;</span> <span class="hljs-attr">srclang</span>=<span class="hljs-string">&quot;cn&quot;</span> <span class="hljs-attr">default</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>label</code>：播放器显示的字幕名称，供用户选择。</li><li><code>kind</code>：字幕的类型，默认是<code>subtitles</code>，表示将原始声音成翻译外国文字，比如英文视频提供中文字幕。另一个常见的值是<code>captions</code>，表示原始声音的文字描述，通常是视频原始使用的语言，比如英文视频提供英文字幕。</li><li><code>src</code>：vtt 字幕文件的网址。</li><li><code>srclang</code>：字幕的语言，必须是有效的语言代码。</li><li><code>default</code>：是否默认打开，布尔属性。</li></ul></div></div><h4 id="source"><code>&lt;source&gt;</code><a class="header-anchor" href="#source">⁍</a></h4><p><code>&lt;source&gt;</code>标签用于<code>&lt;picture&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>的内部，用于指定一项外部资源。单标签是单独使用的，没有结束标签。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>type</code>：指定外部资源的 MIME 类型。</li><li><code>src</code>：指定源文件，用于<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>。</li><li><code>srcset</code>：指定不同条件下加载的图像文件，用于<code>&lt;picture&gt;</code>。</li><li><code>media</code>：指定媒体查询表达式，用于<code>&lt;picture&gt;</code>。</li><li><code>sizes</code>：指定不同设备的显示大小，用于<code>&lt;picture&gt;</code>，必须跟<code>srcset</code>搭配使用。</li></ul></div></div><h4 id="embed"><code>&lt;embed&gt;</code><a class="header-anchor" href="#embed">⁍</a></h4><p>用于嵌入外部内容，这个外部内容通常由浏览器插件负责控制。</p><p>由于 <strong>浏览器的默认插件都不一致</strong> ，很可能不是所有浏览器的用户都能访问这部分内容， <strong>建议谨慎使用</strong> 。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>height</code>：显示高度，单位为像素，不允许百分比。</li><li><code>width</code>：显示宽度，单位为像素，不允许百分比。</li><li><code>src</code>：嵌入的资源的 URL。</li><li><code>type</code>：嵌入资源的 MIME 类型。</li></ul></div></div><h4 id="object-，-param"><code>&lt;object&gt;</code>，<code>&lt;param&gt;</code><a class="header-anchor" href="#object-，-param">⁍</a></h4><p>可以视为<code>&lt;embed&gt;</code>的替代品，有标准化行为，只限于插入少数几种通用资源，没有历史遗留问题，因此更推荐使用。</p><p><code>&lt;object&gt;</code>标签是一个容器元素，内部可以使用<code>&lt;param&gt;</code>标签，给出插件所需要的运行参数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;movie.swf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/x-shockwave-flash&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>data</code>：嵌入的资源的 URL。</li><li><code>form</code>：当前网页中相关联表单的<code>id</code>属性（如果有的话）。</li><li><code>height</code>：资源的显示高度，单位为像素，不能使用百分比。</li><li><code>width</code>：资源的显示宽度，单位为像素，不能使用百分比。</li><li><code>type</code>：资源的 MIME 类型。</li><li><code>typemustmatch</code>：布尔属性，表示<code>data</code>属性与<code>type</code>属性是否必须匹配。</li></ul></div></div><h3 id="iframe">iframe<a class="header-anchor" href="#iframe">⁍</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.example.com&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">allowfullscreen</span> <span class="hljs-attr">sandbox</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.example.com&quot;</span>&gt;</span>点击打开嵌入页面<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>allowfullscreen</code>：允许嵌入的网页全屏显示，需要全屏 API 的支持，请参考相关的 JavaScript 教程。</li><li><code>frameborder</code>：是否绘制边框，<code>0</code>为不绘制，<code>1</code>为绘制（默认值）。建议尽量少用这个属性，而是在 CSS 里面设置样式。</li><li><code>src</code>：嵌入的网页的 URL。</li><li><code>width</code>：显示区域的宽度。</li><li><code>height</code>：显示区域的高度。</li><li><code>sandbox</code>：设置嵌入的网页的权限，详见下文。</li><li><code>importance</code>：浏览器下载嵌入的网页的优先级，可以设置三个值。<code>high</code>表示高优先级，<code>low</code>表示低优先级，<code>auto</code>表示由浏览器自行决定。</li><li><code>name</code>：内嵌窗口的名称，可以用于<code>&lt;a&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;base&gt;</code>的<code>target</code>属性。</li><li><code>referrerpolicy</code>：请求嵌入网页时，HTTP 请求的<code>Referer</code>字段的设置。参见<code>&lt;a&gt;</code>标签的介绍。</li></ul></div></div><h4 id="sandbox-属性">sandbox 属性<a class="header-anchor" href="#sandbox-属性">⁍</a></h4><p>允许设置嵌入的网页的权限，等同于提供了一个隔离层，即“沙箱”。可以当作布尔属性使用，表示打开所有限制。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性值</span></div>    <div class="hide-content"><ul><li><code>allow-forms</code>：允许提交表单。</li><li><code>allow-modals</code>：允许提示框，即允许执行<code>window.alert()</code>等会产生弹出提示框的 JavaScript 方法。</li><li><code>allow-popups</code>：允许嵌入的网页使用<code>window.open()</code>方法弹出窗口。</li><li><code>allow-popups-to-escape-sandbox</code>：允许弹出窗口不受沙箱的限制。</li><li><code>allow-orientation-lock</code>：允许嵌入的网页用脚本锁定屏幕的方向，即横屏或竖屏。</li><li><code>allow-pointer-lock</code>：允许嵌入的网页使用 Pointer Lock API，锁定鼠标的移动。</li><li><code>allow-presentation</code>：允许嵌入的网页使用 Presentation API。</li><li><code>allow-same-origin</code>：不打开该项限制，将使得所有加载的网页都视为跨域。</li><li><code>allow-scripts</code>：允许嵌入的网页运行脚本（但不创建弹出窗口）。</li><li><code>allow-storage-access-by-user-activation</code>：<code>sandbox</code>属性同时设置了这个值和<code>allow-same-origin</code>的情况下，允许<code>&lt;iframe&gt;</code>嵌入的第三方网页通过用户发起<code>document.requestStorageAccess()</code>请求，经由 Storage Access API 访问父窗口的 Cookie。</li><li><code>allow-top-navigation</code>：允许嵌入的网页对顶级窗口进行导航。</li><li><code>allow-top-navigation-by-user-activation</code>：允许嵌入的网页对顶级窗口进行导航，但必须由用户激活。</li><li><code>allow-downloads-without-user-activation</code>：允许在没有用户激活的情况下，嵌入的网页启动下载。</li></ul></div></div><p>不要同时设置<code>allow-scripts</code>和<code>allow-same-origin</code>属性，这将使得嵌入的网页可以改变或删除<code>sandbox</code>属性。</p><h4 id="loading-属性">loading 属性<a class="header-anchor" href="#loading-属性">⁍</a></h4><p><code>&lt;iframe&gt;</code>滚动进入视口以后再加载，这样会比较节省带宽。</p><p>loading属性可以触发<code>&lt;iframe&gt;</code>网页的懒加载。该属性可以取以下三个值。</p><ul><li>auto：浏览器的默认行为，与不使用loading属性效果相同。</li><li>lazy：<code>&lt;iframe&gt;</code>的懒加载，即将滚动进入视口时开始加载。</li><li>eager：立即加载资源，无论在页面上的位置如何。</li></ul><p>如果<code>&lt;iframe&gt;</code>是隐藏的，则<code>loading</code>属性无效，将会立即加载。只要满足以下任一个条件，Chrome 浏览器就会认为<code>&lt;iframe&gt;</code>是隐藏的。</p><blockquote><ul><li><code>&lt;iframe&gt;</code>的宽度和高度为4像素或更小。</li><li>样式设为<code>display: none</code>或<code>visibility: hidden</code>。</li><li>使用定位坐标为负<code>X</code>或负<code>Y</code>，将<code>&lt;iframe</code>&gt;放置在屏幕外。</li></ul></blockquote><h3 id="表格标签">表格标签<a class="header-anchor" href="#表格标签">⁍</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- caption总是第一个子元素 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>示例表格<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 可选一级子元素，表头、表体、表尾 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>... ...<span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>... ...<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span>... ...<span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 一级子元素colgroup --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 表格的一行（table row） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 标题单元格 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>学号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 标题单元格 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>001<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>大型表格内部可以使用多个<code>&lt;tbody&gt;</code>，表示连续的多个部分。</li><li><code>&lt;col&gt;</code>不仅是一个单独使用的标签，没有结束标志，而且还是一个 <strong>空元素</strong> ，没有子元素。它的主要作用，除了申明表格结构，还可以为表格附加样式。</li><li><code>&lt;col&gt;</code>有一个<code>span</code>属性，值为正整数，默认为<code>1</code>。如果大于1，就表示该列的宽度包含连续的多列。</li><li>如果表格有<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code>，那么<code>&lt;tr&gt;</code>就放在这些容器元素之中，否则直接放在<code>&lt;table&gt;</code>的下一级。</li><li>通过<code>colspan</code>属性和<code>rowspan</code>属性设置 <strong>单元格</strong> 跨越的栏/行数</li><li>可以使用<code>headers</code>属性表示哪个单元格对应哪个表头。对于跨行的情况，可以是一个空格分隔的字符串，对应多个<code>id</code>属性的值。</li><li><code>scope</code>属性只有<code>&lt;th&gt;</code>标签支持，一般不在<code>&lt;td&gt;</code>标签使用，表示该<code>&lt;th&gt;</code>单元格到底是栏的标题，还是列的标题。<ul><li>可取属性值：<code>row</code>/<code>col</code>/<code>rowgroup</code>/<code>colgroup</code>/<code>auto</code></li></ul></li></ul><h3 id="表单标签">表单标签<a class="header-anchor" href="#表单标签">⁍</a></h3><h4 id="容器元素-form">容器元素<code>&lt;form&gt;</code><a class="header-anchor" href="#容器元素-form">⁍</a></h4><p>属性：</p><ul><li><code>name</code>：表单的名称，应该在网页中是 <strong>唯一且必须</strong> 的。注意，如果一个控件没有设置<code>name</code>属性，那么这个控件的值就不会作为键值对，向服务器发送。</li><li><code>action</code>：服务器接收数据的 URL。</li><li><code>method</code>：提交数据的 HTTP 方法，可能的值有<code>post</code>（表单数据作为 HTTP 数据体发送），<code>get</code>（表单数据作为 URL 的查询字符串发送），<code>dialog</code>（表单位于<code>&lt;dialog&gt;</code>内部使用）。</li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>其他属性</span></div>    <div class="hide-content"><ul><li><code>accept-charset</code>：服务器接受的字符编码列表，使用空格分隔，默认与网页编码相同。</li><li><code>autocomplete</code>：如果用户没有填写某个控件，浏览器是否可以自动填写该值。它的可能取值分别为<code>off</code>（不自动填写）和<code>on</code>（自动填写）。</li><li><code>enctype</code>：当<code>method</code>属性等于<code>post</code>时，该属性指定提交给服务器的 MIME 类型。可能的值为<code>application/x-www-form-urlencoded</code>（默认值），<code>multipart/form-data</code>（文件上传的情况），<code>text/plain</code>。详见<a href="https://wangdoc.com/html/form.html#enctype-%E5%B1%9E%E6%80%A7">表单标签 - HTML 教程 - 网道 (wangdoc.com)</a></li><li><code>novalidate</code>：布尔属性，表单提交时是否取消验证。</li><li><code>target</code>：在哪个窗口展示服务器返回的数据，可能的值有<code>_self</code>（当前窗口），<code>_blank</code>（新建窗口），<code>_parent</code>（父窗口），<code>_top</code>（顶层窗口），<code>&lt;iframe&gt;</code>标签的<code>name</code>属性（即表单返回结果展示在<code>&lt;iframe&gt;</code>窗口）。</li></ul></div></div><h4 id="fieldset-，-legend"><code>&lt;fieldset&gt;</code>，<code>&lt;legend&gt;</code><a class="header-anchor" href="#fieldset-，-legend">⁍</a></h4><p><code>&lt;fieldset&gt;</code>是一个容器元素，表示控件的集合，用于将一组相关控件组合成一组。</p><p>有以下属性。</p><ul><li><code>disabled</code>：布尔属性，一旦设置会使得<code>&lt;fieldset&gt;</code>内部包含的控件都不可用，都变成灰色状态。</li><li><code>form</code>：指定控件组所属的<code>&lt;form&gt;</code>，它的值等于<code>&lt;form&gt;</code>的<code>id</code>属性。</li><li><code>name</code>：该控件组的名称。</li></ul><p><code>&lt;legend&gt;</code>标签用来设置<code>&lt;fieldset&gt;</code>控件组的标题，通常是<code>&lt;fieldset&gt;</code>内部的第一个元素，会嵌入显示在控件组的上边框里面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>学生情况登记<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203202341637.png" alt="image-20220320234141574"></p><h4 id="label"><code>&lt;label&gt;</code><a class="header-anchor" href="#label">⁍</a></h4><p><strong>行内元素</strong></p><p>点击<code>&lt;label&gt;</code>，就相当于控件本身的<code>click</code>事件。</p><p><code>&lt;label&gt;</code>的<code>for</code>属性关联相对应的控件，它的值是对应控件的<code>id</code>属性。所以，控件最好设置<code>id</code>属性。</p><p>控件也可以放在<code>&lt;label&gt;</code>之中，这时不需要<code>for</code>属性和<code>id</code>属性。</p><p><code>&lt;label&gt;</code>的属性如下。</p><ul><li><code>for</code>：关联控件的<code>id</code>属性。</li><li><code>form</code>：关联表单的<code>id</code>属性。设置了该属性后，<code>&lt;label&gt;</code>可以放置在页面的任何位置，否则只能放在<code>&lt;form&gt;</code>内部。</li></ul><h4 id="input"><code>&lt;input&gt;</code><a class="header-anchor" href="#input">⁍</a></h4><p>不用闭合</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>共同属性</span></div>    <div class="hide-content"><ul><li><code>autofocus</code>：布尔属性，是否在页面加载时自动获得焦点。</li><li><code>disabled</code>：布尔属性，是否禁用该控件。一旦设置，该控件将变灰，用户可以看到，但是无法操作。</li><li><code>form</code>：关联表单的<code>id</code>属性。设置了该属性后，控件可以放置在页面的任何位置，否则只能放在<code>&lt;form&gt;</code>内部。</li><li><code>list</code>：关联的<code>&lt;datalist&gt;</code>的<code>id</code>属性，设置该控件相关的数据列表，详见后文。</li><li><code>name</code>：控件的名称，主要用于向服务器提交数据时，控件键值对的键名。注意，只有设置了<code>name</code>属性的控件，才会向服务器提交，不设置就不会提交。</li><li><code>readonly</code>：布尔属性，是否为只读。</li><li><code>required</code>：布尔属性，是否为必填。</li><li><code>type</code>：控件类型，详见下文。</li><li><code>value</code>：控件的值。</li></ul></div></div><p><code>type</code>属性决定了<code>&lt;input&gt;</code>的形式：</p><p>详细的属性解说见<a href="https://wangdoc.com/html/form.html#%E7%B1%BB%E5%9E%8B">表单标签 - HTML 教程 - 网道 (wangdoc.com)</a></p><h5 id="1-text">1. text<a class="header-anchor" href="#1-text">⁍</a></h5><h5 id="2-search">2. search<a class="header-anchor" href="#2-search">⁍</a></h5><h5 id="3-button">3. button<a class="header-anchor" href="#3-button">⁍</a></h5><p>建议尽量不使用这个类型，而使用<code>&lt;button&gt;</code>标签代替</p><h5 id="4-submit">4. submit<a class="header-anchor" href="#4-submit">⁍</a></h5><p>可用配套属性来覆盖<code>&lt;form&gt;</code>标签的相应设置。</p><h5 id="5-image">5. image<a class="header-anchor" href="#5-image">⁍</a></h5><p>将图像作为submit按钮</p><h5 id="6-reset">6. reset<a class="header-anchor" href="#6-reset">⁍</a></h5><p>用处不大，用户点错了还会使得所有已经输入的值都被重置，建议不要使用。</p><h5 id="7-checkbox">7. checkbox<a class="header-anchor" href="#7-checkbox">⁍</a></h5><p>多个相关的复选框，可以放在<code>&lt;fieldset&gt;</code>里面。<code>name</code>要一致。</p><h5 id="8-radio">8. radio<a class="header-anchor" href="#8-radio">⁍</a></h5><p>多个单选框的<code>name</code>属性的值，应该都是一致的。</p><h5 id="9-email">9. email<a class="header-anchor" href="#9-email">⁍</a></h5><p>该类型还可以搭配<code>&lt;datalist&gt;</code>标签，提供输入的备选项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">list</span>=<span class="hljs-string">&quot;defaultEmails&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;defaultEmails&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jbond007@mi6.defence.gov.uk&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jbourne@unknown.net&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;nfury@shield.org&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tony@starkindustries.com&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hulk@grrrrrrrr.arg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="10-password">10. password<a class="header-anchor" href="#10-password">⁍</a></h5><p>浏览器会自动将换行符（<code>U+000A</code>）和回车符（<code>U+000D</code>）过滤掉。</p><h5 id="11-file">11. file<a class="header-anchor" href="#11-file">⁍</a></h5><h5 id="12-hidden">12. hidden<a class="header-anchor" href="#12-hidden">⁍</a></h5><div class="note morden flat"><p>TODO: 详细过程？</p></div><p><code>type=&quot;hidden&quot;</code>是一个不显示在页面的控件，用户无法输入它的值，主要用来向服务器传递一些隐藏信息。比如，CSRF 攻击会伪造表单数据，那么使用这个控件，可以为每个表单生成一个独一无二的隐藏编号，防止伪造表单提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;prodId&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prodId&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xm234jq&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面这个控件，页面上是看不见的。用户提交表单的时候，浏览器会将<code>prodId=xm234jq</code>发给服务器。</p><blockquote><p>CSRF（Cross-Site Request Forgery）的全称是“跨站请求伪造”，也被称为“One Click Attack”或者“Session Riding”，通常缩写为CSRF或者XSRF。</p><p><a href="https://www.cnblogs.com/54chensongxia/p/11693666.html">CSRF 攻击详解 - 程序员自由之路 - 博客园 (cnblogs.com)</a></p></blockquote><h5 id="13-number">13. number<a class="header-anchor" href="#13-number">⁍</a></h5><p>数字输入框，只能输入数字。浏览器通常会在输入框的最右侧，显示一个可以点击的上下箭头，点击向上箭头，数字会递增，点击向下箭头，数字会递减。</p><h5 id="14-range">14. range<a class="header-anchor" href="#14-range">⁍</a></h5><p><code>type=&quot;range&quot;</code>是一个滑块，用户拖动滑块，选择给定范围之中的一个数值。因为拖动产生的值是不精确的，如果需要精确数值，不建议使用这个控件。常见的例子是调节音量。</p><p>该类型的配套属性如下，用法与<code>type=&quot;number&quot;</code>一致。</p><ul><li><code>max</code>：允许的最大值，默认为100。</li><li><code>min</code>：允许的最小值，默认为0。</li><li><code>step</code>：步长值，默认为1。</li></ul><p>该类型与<code>&lt;datalist&gt;</code>标签配合使用，可以在滑动区域产生刻度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">list</span>=<span class="hljs-string">&quot;tickmarks&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tickmarks&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;0%&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;40&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;60&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;70&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;100%&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码会在0～100之间产生11个刻度。其中，<code>0%</code>、<code>50%</code>和<code>100%</code>三个位置会有文字提示，不过浏览器很可能不支持。</p><p>注意，浏览器生成的都是水平滑块。如果想要生成垂直滑块，可以使用 CSS 改变滑块区域的方向。</p><h5 id="15-url">15. url<a class="header-anchor" href="#15-url">⁍</a></h5><p>与<code>&lt;datalist&gt;</code>标签搭配使用，可以形成下拉列表供用户选择。</p><h5 id="16-tel">16. tel<a class="header-anchor" href="#16-tel">⁍</a></h5><p>大多数时候需要自定义验证。</p><h5 id="17-color">17. color<a class="header-anchor" href="#17-color">⁍</a></h5><p>选择颜色的控件，它的值一律都是<code>#rrggbb</code>格式。</p><h5 id="18-date-time-month-week-datetime-local">18. date/time/month/week/datetime-local<a class="header-anchor" href="#18-date-time-month-week-datetime-local">⁍</a></h5><p>日期/时间/月份/周/日期时间输入框</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>date: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;start&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;start&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2018-07-22&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;2018-01-01&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;2018-12-31&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>time: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;time&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;appt&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;appt&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;9:00&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;18:00&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>month: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;month&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;start&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;start&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;2018-03&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2018-05&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>week: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;week&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;week&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;camp-week&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;2018-W18&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;2018-W26&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>datetime-local: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime-local&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;meeting-time&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;meeting-time&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2018-06-12T19:30&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;2018-06-07T00:00&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;2018-06-14T00:00&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203211721264.png" alt="image-20220321172126115"></p><h4 id="button"><code>&lt;button&gt;</code><a class="header-anchor" href="#button">⁍</a></h4><p>是一个容器标签（？）通常需要用<code>type</code>属性或脚本指定按钮的功能。</p><p><code>&lt;button&gt;</code>内部不仅放置文字，还可以放置图像，这可以形成图像按钮。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>autofocus</code>：布尔属性，表示网页加载时，焦点就在这个按钮。网页里面只能有一个元素，具有这个属性。</li><li><code>disabled</code>：布尔属性，表示按钮不可用，会导致按钮变灰，不可点击。</li><li><code>name</code>：按钮的名称（与<code>value</code>属性配合使用），将以<code>name=value</code>的形式，随表单一起提交到服务器。</li><li><code>value</code>：按钮的值（与<code>name</code>属性配合使用），将以<code>name=value</code>的形式，随表单一起提交到服务器。</li><li><code>type</code>：按钮的类型，可能的值有三种：<code>submit</code>（点击后将数据提交给服务器），<code>reset</code>（将所有控件的值重置为初始值），<code>button</code>（没有默认行为，由脚本指定按钮的行为）。</li><li><code>form</code>：指定按钮关联的<code>&lt;form&gt;</code>表单，值为<code>&lt;form&gt;</code>的<code>id</code>属性。如果省略该属性，默认关联按钮所在父表单。</li></ul><hr><p>下面是覆盖form的属性：</p><ul><li><code>formaction</code>：数据提交到服务器的目标 URL，会覆盖<code>&lt;form&gt;</code>元素的<code>action</code>属性。</li><li><code>formenctype</code>：数据提交到服务器的编码方式，会覆盖<code>&lt;form&gt;</code>元素的<code>enctype</code>属性。可能的值有三种：<code>application/x-www-form-urlencoded</code>（默认值），<code>multipart/form-data</code>（只用于文件上传），<code>text/plain</code>。</li><li><code>formmethod</code>：数据提交到服务器使用的 HTTP 方法，会覆盖<code>&lt;form&gt;</code>元素的<code>method</code>属性，可能的值为<code>post</code>或<code>get</code>。</li><li><code>formnovalidate</code>：布尔属性，数据提交到服务器时关闭本地验证，会覆盖<code>&lt;form&gt;</code>元素的<code>novalidate</code>属性。</li><li><code>formtarget</code>：数据提交到服务器后，展示服务器返回数据的窗口，会覆盖<code>&lt;form&gt;</code>元素的<code>target</code>属性。可能的值有<code>_self</code>（当前窗口），<code>_blank</code>（新的空窗口）、<code>_parent</code>（父窗口）、<code>_top</code>（顶层窗口）。</li></ul></div></div><h4 id="option-，-optgroup"><code>&lt;option&gt;</code>，<code>&lt;optgroup&gt;</code><a class="header-anchor" href="#option-，-optgroup">⁍</a></h4><p><code>&lt;option&gt;</code>标签用在<code>&lt;select&gt;</code>、<code>&lt;optgroup&gt;</code>、<code>&lt;datalist&gt;</code>里面，表示一个菜单项，参见<code>&lt;select&gt;</code>的示例。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>disabled</code>：布尔属性，是否禁用该项。</li><li><code>label</code>：该项的说明。如果省略，则等于该项的文本内容。</li><li><code>selected</code>：布尔属性，是否为默认值。显然，一组菜单中，只能有一个菜单项设置该属性。</li><li><code>value</code>：该项提交到服务器的值。如果省略，则等于该项的文本内容。</li></ul></div></div><p><code>&lt;optgroup&gt;</code>表示菜单项的分组，通常用在<code>&lt;select&gt;</code>内部。</p><ul><li><code>disabled</code>：布尔设置，是否禁用该组。一旦设置，该组所有的菜单项都不可选。</li><li><code>label</code>：菜单项分组的标题。</li></ul><h4 id="select"><code>&lt;select&gt;</code><a class="header-anchor" href="#select">⁍</a></h4><p>用于生成一个下拉菜单。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>autofocus</code>：布尔属性，页面加载时是否自动获得焦点。</li><li><code>disabled</code>：布尔属性，是否禁用当前控件。</li><li><code>form</code>：关联表单的<code>id</code>属性。</li><li><code>multiple</code>：布尔属性，是否可以选择多个菜单项。默认情况下，只能选择一项。一旦设置，多数浏览器会显示一个滚动列表框。用户可能需要按住<code>Shift</code>或其他功能键，选中多项。</li><li><code>name</code>：控件名。</li><li><code>required</code>：布尔属性，是否为必填控件。</li><li><code>size</code>：设置了<code>multiple</code>属性时，页面显示时一次可见的行数，其他行需要滚动查看。</li></ul></div></div><h4 id="datalist"><code>&lt;datalist&gt;</code><a class="header-anchor" href="#datalist">⁍</a></h4><p>为指定控件提供一组相关数据，通常用于生成输入提示。它的内部使用<code>&lt;option&gt;</code>，生成每个菜单项。</p><p><strong>注意，<code>&lt;option&gt;</code>在这里可以不需要闭合标签。</strong></p><h4 id="textarea"><code>&lt;textarea&gt;</code><a class="header-anchor" href="#textarea">⁍</a></h4><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>autofocus</code>：布尔属性，是否自动获得焦点。</li><li><code>cols</code>：文本框的宽度，单位为字符，默认值为20。</li><li><code>disabled</code>：布尔属性，是否禁用该控件。</li><li><code>form</code>：关联表单的<code>id</code>属性。</li><li><code>maxlength</code>：允许输入的最大字符数。如果未指定此值，用户可以输入无限数量的字符。</li><li><code>minlength</code>：允许输入的最小字符数。</li><li><code>name</code>：控件的名称。</li><li><code>placeholder</code>：输入为空时显示的提示文本。</li><li><code>readonly</code>：布尔属性，控件是否为只读。</li><li><code>required</code>：布尔属性，控件是否为必填。</li><li><code>rows</code>：文本框的高度，单位为行。</li><li><code>spellcheck</code>：是否打开浏览器的拼写检查。可能的值有<code>true</code>（打开），<code>default</code>（由父元素或网页设置决定），<code>false</code>（关闭）。</li><li><code>wrap</code>：输入的文本是否自动换行。可能的值有<code>hard</code>（浏览器自动插入换行符<code>CR + LF</code>，使得每行不超过控件的宽度），<code>soft</code>（输入内容超过宽度时自动换行，但不会加入新的换行符，并且浏览器保证所有换行符都是<code>CR + LR</code>，这是默认值），<code>off</code>（关闭自动换行，单行长度超过宽度时，会出现水平滚动条）。</li></ul></div></div><h4 id="output"><code>&lt;output&gt;</code><a class="header-anchor" href="#output">⁍</a></h4><p>行内元素，用于显示用户操作的结果。一般是计算结果（？</p><form oninput="x.value=parseInt(a.value)+parseInt(b.value)">0<input type="range" id="a" value="50">100+<input type="number" id="b" value="50">=<output name="x" for="a b"></output></form><h4 id="progress"><code>&lt;progress&gt;</code><a class="header-anchor" href="#progress">⁍</a></h4><p>任务完成进度</p><p><progress id="file" max="100" value="70"> 70% </progress></p><h4 id="meter"><code>&lt;meter&gt;</code><a class="header-anchor" href="#meter">⁍</a></h4><p>行内元素，表示指示器，用来显示已知范围内的一个值，很适合用于任务的当前进度、磁盘已用空间、充电量等带有比例性质的场合。浏览器通常会将其显示为一个不会滚动的指示条。</p><p>示例：</p><p>烤箱的当前温度是<meter min="200" max="500" value="350">350度</meter>。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>属性</span></div>    <div class="hide-content"><ul><li><code>min</code>：范围的下限，必须小于<code>max</code>属性。如果省略，则默认为<code>0</code>。</li><li><code>max</code>：范围的上限，必须大于<code>min</code>属性。如果省略，则默认为<code>1</code>。</li><li><code>value</code>：当前值，必须在<code>min</code>属性和<code>max</code>属性之间。如果省略，则默认为<code>0</code>。</li><li><code>low</code>：表示“低端”的上限门槛值，必须大于<code>min</code>属性，小于<code>high</code>属性和<code>max</code>属性。如果省略，则等于<code>min</code>属性。</li><li><code>high</code>：表示“高端”的下限门槛值，必须小于<code>max</code>属性，大于<code>low</code>属性和<code>min</code>属性。如果省略，则等于<code>max</code>属性。</li><li><code>optimum</code>：指定最佳值，必须在<code>min</code>属性和<code>max</code>属性之间。它应该与<code>low</code>属性和<code>high</code>属性一起使用，表示最佳范围。如果<code>optimum</code>小于<code>low</code>属性，则表示“低端”是最佳范围；如果大于<code>high</code>属性，则表示“高端”是最佳范围；如果在<code>low</code>和<code>high</code>之间，则表示“中间地带”是最佳范围。如果省略，则等于<code>min</code>和<code>max</code>的中间值。</li><li><code>form</code>：关联表单的<code>id</code>属性。</li></ul></div></div><h3 id="其他标签">其他标签<a class="header-anchor" href="#其他标签">⁍</a></h3><h4 id="dialog"><code>&lt;dialog&gt;</code><a class="header-anchor" href="#dialog">⁍</a></h4><div class="note flat"><p>或许这就是模态框。。</p></div><p><code>&lt;dialog&gt;</code>元素里面，可以放入其他 HTML 元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span> <span class="hljs-attr">open</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的对话框里面，有一个输入框和提交按钮。</p><p>注意，上例中<code>&lt;form&gt;</code>的<code>method</code>属性设为<code>dialog</code>，这时点击提交按钮，对话框就会消失。但是，表单不会提交到服务器，浏览器会将表单元素的<code>returnValue</code>属性设为 Submit 按钮的<code>value</code>属性（上例是<code>foo</code>）。</p><h5 id="js-api">JS API<a class="header-anchor" href="#js-api">⁍</a></h5><p>提供<code>Dialog.showModal()</code>和<code>Dialog.close()</code>两个方法，用于打开/关闭对话框。</p><h5 id="事件">事件<a class="header-anchor" href="#事件">⁍</a></h5><p>有两个事件，可以监听。</p><ul><li><code>close</code>：对话框关闭时触发</li><li><code>cancel</code>：用户按下<code>esc</code>键关闭对话框时触发</li></ul><p>如果希望用户点击透明层，就关闭对话框，可以用下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">modal.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.target === modal) &#123;<br>    modal.close(<span class="hljs-string">&#x27;cancelled&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="details-，-summary"><code>&lt;details&gt;</code>，<code>&lt;summary&gt;</code><a class="header-anchor" href="#details-，-summary">⁍</a></h4><details>    <summary>这是summary</summary>    这是details</details><p>CSS 设置<code>summary::-webkit-details-marker</code>，可以改变标题前面的三角箭头。</p><h5 id="js-api-2">JS API<a class="header-anchor" href="#js-api-2">⁍</a></h5><p><code>Details</code>元素的<code>open</code>属性返回<code>&lt;details&gt;</code>当前是打开还是关闭。</p><p><code>Details</code>元素有一个<code>toggle</code>事件，打开或关闭折叠时，都会触发这个事件。</p><p>详细见<a href="https://wangdoc.com/html/elements.html">其他标签 - HTML 教程 - 网道 (wangdoc.com)</a></p><h2 id="html的演变过程与对应的文档类型定义-dtd">HTML的演变过程与对应的文档类型定义(DTD)<a class="header-anchor" href="#html的演变过程与对应的文档类型定义-dtd">⁍</a></h2><ul><li><p>HTML4</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">htm1</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta"><span class="hljs-meta-string">&quot;-//w3C//DTD HTML 4.01 Transitiona1 //EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/TR/htm14/1oose.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>XHTML 1.0</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">htm1</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta"><span class="hljs-meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitiona1 //EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/TR/xhtm11/DTD/</span></span><br><span class="hljs-meta-string"><span class="hljs-meta">xhtm11-transitiona1.dtd&quot;</span>&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">htm1</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta"><span class="hljs-meta-string">&quot;-//W3C//DTD XHTML 1.0 Strict/ /EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/TR/xhtm11/DTD/xhtm11-strict.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>是依据XML标准重新制定的，有着严格的规则（也有过渡板的XHTML，其中仍可以使用一些表示性元素）</p></li><li><p>XML：可扩展标记性语言，定义数据传输的格式，标签需要自定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version-&quot;1.0”?&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>HTML5</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;! DOCTYPE htm1&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="搜索引擎优化seo">搜索引擎优化SEO<a class="header-anchor" href="#搜索引擎优化seo">⁍</a></h2><p>搜索引擎优化(或者叫SEO)是一种利用 <strong>搜索引擎的搜索规则</strong> 来 <strong>提高网站在有关搜索引擎内的排名</strong> 的方式</p><p>SEO的核心是，找到人们在搜索你的网站时可能会输入到搜索引擎的 <strong>关键词</strong> ,然后在你的网站中将这些关键词应用到合适的位置，以此来增加你的网站在搜索引擎结果中显示的机会。</p><h3 id="站内优化">站内优化<a class="header-anchor" href="#站内优化">⁍</a></h3><p>关注站内网页文本</p><ul><li><strong>关键词插入：</strong></li></ul><ol><li><strong>页面标题</strong> <code>&lt;head&gt;</code>-<code>&lt;title&gt;</code></li><li><strong>URL/网址</strong> ：文件名属于URL的一部分，如果允许的话在文件名中加入关键词</li><li><strong>标题</strong> <code>&lt;h1&gt;</code>~<code>&lt;hn&gt;</code></li><li><strong>正文</strong> 不要出现段与段之间生硬的植入关键词，要保持关键词布局的合理性</li><li><strong>链接文本</strong></li><li><strong>图像的alt特性</strong></li><li><strong>页面描述</strong>  <code>&lt;head&gt;</code>-<code>&lt;meta&gt;</code> description描述标签/keywords关键词标签</li></ol><div class="note danger modern"><p>永远不要试图欺骗搜索引擎！例如，不要添加颜色与背景色相同的文本，因为搜索引擎可以检测到这一点。</p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203211854499.png" style="zoom:33%;" /></div><ul><li><strong>内容的更新</strong> 等</li></ul><h3 id="站外优化">站外优化<a class="header-anchor" href="#站外优化">⁍</a></h3><p>获得来自其他内容相关的网站的链接（其他网站引用了你的网站的链接），可以做友链交换</p><p>可以通过Google Analytics等工具分析来访者</p><p>通过发布外链等方式吸引来访者</p><p>通过服务器优化提高访问速度等等方式留住来访者</p><p>其他可参考： <a href="https://blog.naibabiji.com/google-seo">Google SEO教程，谷歌搜索引擎优化新手入门指南 - 奶爸建站笔记 (naibabiji.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder-前端面试题-HTML部分</title>
      <link href="/augu1sto/efb254aacb6e/"/>
      <url>/augu1sto/efb254aacb6e/</url>
      
        <content type="html"><![CDATA[<div class="note no-icon flat"><p>该文章由自制脚本抓取 <a href="https://github.com/Augu1sto/getNowcoder-interviewList">Augu1sto/getNowcoder-interviewList: 将牛客上的面试题集锦保存为markdown文件 (github.com)</a></p><p>对格式进行了一定调整，详细内容有待细化更新</p></div><h2 id="浏览器页面有哪三层构成，分别是什么，作用是什么">浏览器页面有哪三层构成，分别是什么，作用是什么?<a class="header-anchor" href="#浏览器页面有哪三层构成，分别是什么，作用是什么">⁍</a></h2><ul><li>构成：结构层、表示层、行为层</li><li>分别是：HTML、CSS、JavaScript</li><li>作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。<br><a href="https://www.nowcoder.com/questionTerminal/09ad0bbbee75416189e665df9095507f">Discussion</a></li></ul><h2 id="html5的优点与缺点？">HTML5的优点与缺点？<a class="header-anchor" href="#html5的优点与缺点？">⁍</a></h2><p><strong>优点：</strong></p><ul><li>a、网络标准统一、HTML5本身是由W3C推荐出来的。</li><li>b、多设备、跨平台</li><li>c、即时更新。</li><li>d、提高可用性和改进用户的友好体验；</li><li>e、有几个新的标签，这将有助于开发人员定义重要的内容；</li><li>f、可以给站点带来更多的多媒体元素(视频和音频)；</li><li>g、可以很好的替代Flash和Silverlight；</li><li>h、涉及到网站的抓取和索引的时候，对于SEO很友好；</li><li>i、被大量应用于移动应用程序和游戏。</li></ul><p><strong>缺点：</strong></p><ul><li>a、安全：像之前Firefox4的websocket和透明代理的实现存在严重的安全问题，同时webstorage、websocket这样的功能很容易被黑客利用，来盗取用户的信息和资料。</li><li>b、完善性：许多特性各浏览器的支持程度也不一样。</li><li>c、技术门槛：HTML5简化开发者工作的同时代表了有许多新的属性和API需要开发者学习，像webworker、websocket、webstorage等新特性，后台甚至浏览器原理的知识，机遇的同时也是巨大的挑战</li><li>d、性能：某些平台上的引擎问题导致HTML5性能低下。</li><li>e、浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。<br><a href="https://www.nowcoder.com/questionTerminal/590a510de9bd49d491e6afd8088403d8">Discussion</a></li></ul><h2 id="doctype作用-严格模式与混杂模式如何区分？它们有何意义">Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?<a class="header-anchor" href="#doctype作用-严格模式与混杂模式如何区分？它们有何意义">⁍</a></h2><p><strong>回答1：</strong></p><ul><li>（1）、声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档。</li><li>（2）、严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。</li><li>（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li><li>（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</li></ul><p><strong>回答2：</strong></p><ul><li>doctype声明指出阅读程序应该用什么规则集来解释文档中的标记。在Web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是W3C所发布的一个 <strong>文档类型定义（DTD）</strong> 中包含的规则。</li><li>(1)声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</li><li>(2)所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。严格模式是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，如</li><li>。严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行混杂模式则是一种向后兼容的解析方法，说的透明点就是可以实现IE5.5以下版本浏览器的渲染模式。</li><li>(3)浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式。<br><a href="https://www.nowcoder.com/questionTerminal/b982fd49d6ce4ff39b10dd6b5476199b">Discussion</a></li></ul><h2 id="html5有哪些新特性、移除了哪些元素？">HTML5有哪些新特性、移除了哪些元素？<a class="header-anchor" href="#html5有哪些新特性、移除了哪些元素？">⁍</a></h2><ul><li><p>Html5新增了27个元素，废弃了16个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素4大类。</p></li><li><p><strong>结构性元素</strong> 主要负责web上下文结构的定义</p></li><li><p>section：在web页面应用中，该元素也可以用于区域的章节描述。</p></li><li><p>header：页面主体上的头部，header元素往往在一对body元素中。</p></li><li><p>footer：页面的底部（页脚），通常会标出网站的相关信息。</p></li><li><p>nav：专门用于菜单导航、链接导航的元素，是navigator的缩写。</p></li><li><p>article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。</p></li><li><p><strong>级块性元素</strong> 主要完成web页面区域的划分，确保内容的有效分割。</p></li><li><p>aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。</p></li><li><p>figure：是对多个元素进行组合并展示的元素，通常与figcaption联合使用。</p></li><li><p>code：表示一段代码块。</p></li><li><p>dialog：用于表达人与人之间的对话，该元素包含dt和dd这两个组合元素，dt用于表示说话者，而dd用来表示说话内容。</p></li><li><p><strong>行内语义性元素</strong> 主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。</p></li><li><p>meter：表示特定范围内的数值，可用于工资、数量、百分比等。</p></li><li><p>time：表示时间值。</p></li><li><p>progress：用来表示进度条，可通过对其max、min、step等属性进行控制，完成对进度的表示和监视。</p></li><li><p>video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。</p></li><li><p>audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。</p></li><li><p><strong>交互性元素</strong> 主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。</p></li><li><p>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与legend交互才会显示出来。</p></li><li><p>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。</p></li><li><p>menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。</p></li><li><p>command：用来处理命令按钮。</p></li></ul><p><a href="https://www.nowcoder.com/questionTerminal/a99c642a9fd94424a68b03c7675a05b8">Discussion</a></p><h2 id="你做的网页在哪些浏览器测试过-这些浏览器的内核分别是什么">你做的网页在哪些浏览器测试过,这些浏览器的内核分别是什么?<a class="header-anchor" href="#你做的网页在哪些浏览器测试过-这些浏览器的内核分别是什么">⁍</a></h2><ul><li>a、IE: trident内核</li><li>b、Firefox：gecko内核</li><li>c、Safari: webkit内核</li><li>d、Opera: 以前是presto内核，Opera现已改用GoogleChrome的Blink内核</li><li>e、Chrome: Blink(基于webkit，Google与OperaSoftware共同开发)</li></ul><p><a href="https://www.nowcoder.com/questionTerminal/b0885d300d0f4229bb3f28e91bfcc065">Discussion</a></p><h2 id="每个html文件里开头都有个很重要的东西，doctype，知道这是干什么的吗？">每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？<a class="header-anchor" href="#每个html文件里开头都有个很重要的东西，doctype，知道这是干什么的吗？">⁍</a></h2><ul><li>声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种HTML或XHTML规范。（重点：告诉浏览器按照何种规范解析页面）<br><a href="https://www.nowcoder.com/questionTerminal/d35ebf720e89492bac565582878ad356">Discussion</a></li></ul><h2 id="说说你对html5认识-（是什么-为什么）">说说你对HTML5认识?（是什么,为什么）<a class="header-anchor" href="#说说你对html5认识-（是什么-为什么）">⁍</a></h2><p><strong>是什么</strong></p><ul><li>HTML5指的是包括HTML、CSS和JavaScript在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（Plug-in-BasedRichInternetApplication，RIA），例如：AdobeFlash、MicrosoftSilverlight与OracleJavaFX的需求，并且提供更多能有效加强网络应用的标准集。HTML5是HTML最新版本，2014年10月由万维网联盟（W3C）完成标准制定。目标是替换1999年所制定的HTML4.01和XHTML1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。</li></ul><p><strong>为什么</strong></p><ul><li>HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能Flash被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。</li><li>HTML5增强了浏览器的原生功能，符合HTML5规范的浏览器功能将更加强大，减少了Web应用对插件的依赖，让用户体验更好，让开发更加方便，另外W3C从推出HTML4.0到5.0之间共经历了17年，HTML的变化很小，这并不符合一个好产品的演进规则。<br><a href="https://www.nowcoder.com/questionTerminal/b05a61f9e66b4ccaa15d092131c78e4c">Discussion</a></li></ul><h2 id="对web标准以及w3c的理解与认识">对WEB标准以及W3C的理解与认识?<a class="header-anchor" href="#对web标准以及w3c的理解与认识">⁍</a></h2><ul><li>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。<br><a href="https://www.nowcoder.com/questionTerminal/1a9aea79311f4789bfd381acfe8810b2">Discussion</a></li></ul><h2 id="html5行内元素有哪些-块级元素有哪些-空元素有哪些">HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?<a class="header-anchor" href="#html5行内元素有哪些-块级元素有哪些-空元素有哪些">⁍</a></h2><ol><li><p><strong>行内元素</strong></p><ul><li><p>a-锚点</p></li><li><p>*abbr-缩写</p></li><li><p>*acronym-首字</p></li><li><p>*b-粗体(不推荐)</p></li><li><p>*bdo-bidioverride</p></li><li><p>*big-大字体</p></li><li><p>*br-换行</p></li><li><p>*cite-引用</p></li><li><p>*code-计算机代码(在引用源码的时候需要)</p></li><li><p>*dfn-定义字段</p></li><li><p>*em-强调</p></li><li><p>*font-字体设定(不推荐)</p></li><li><p>*i-斜体</p></li><li><p>*img-图片</p></li><li><p>*input-输入框</p></li><li><p>*kbd-定义键盘文本</p></li><li><p>*label-表格标签</p></li><li><p>*q-短引用</p></li><li><p>*s-中划线(不推荐)</p></li><li><p>*samp-定义范例计算机代码</p></li><li><p>*select-项目选择</p></li><li><p>*small-小字体文本</p></li><li><p>*span-常用内联容器，定义文本内区块</p></li><li><p>*strike-中划线</p></li><li><p>*strong-粗体强调</p></li><li><p>*sub-下标</p></li><li><p>*sup-上标</p></li><li><p>*textarea-多行文本输入框</p></li><li><p>*tt-电传文本</p></li><li><p>*u-下划线</p></li><li><p>*var-定义变量</p></li></ul></li><li><p><strong>块元素</strong> (blockelement)</p></li></ol><ul><li><p>*address-地址</p></li><li><p>*blockquote-块引用</p></li><li><p>*center-居中对齐块</p></li><li><p>*dir-目录列表</p></li><li><p>*div-常用块级容易，也是csslayout的主要标签</p></li><li><p>*dl-定义列表</p></li><li><p>*fieldset-form控制组</p></li><li><p>*form-交互表单</p></li><li><p>*h1-大标题</p></li><li><p>*h2-副标题</p></li><li><p>*h3-3级标题</p></li><li><p>*h4-4级标题</p></li><li><p>*h5-5级标题</p></li><li><p>*h6-6级标题</p></li><li><p>*hr-水平分隔线</p></li><li><p>*isindex-inputprompt</p></li><li><p>*menu-菜单列表</p></li><li><p>*noframes-frames可选内容，（对于不支持frame的浏览器显示此区块内容</p></li><li><p>*noscript-）可选脚本内容（对于不支持script的浏览器显示此内容）</p></li><li><p>*ol-排序表单</p></li><li><p>*p-段落</p></li><li><p>*pre-格式化文本</p></li><li><p>*table-表格</p></li><li><p>*ul-非排序列表</p></li><li><p><strong>可变元素</strong></p><p>可变元素为根据上下文语境决定该元素为块元素或者内联元素。</p><ul><li>*applet-javaapplet</li><li>*button-按钮</li><li>*del-删除文本</li><li>*iframe-inlineframe</li><li>*ins-插入的文本</li><li>*map-图片区块(map)</li><li>*object-object对象</li><li>*script-客户端脚本</li></ul></li></ul><ol start="3"><li><strong>空元素</strong> (在HTML[1]元素中，没有内容的HTML元素被称为空元素)</li></ol><ul><li><p>&lt;br/&gt;//换行</p></li><li><p>&lt;hr&gt;//分隔线</p></li><li><p>&lt;input&gt;//文本框等</p></li><li><p>&lt;img&gt;//图片</p></li><li><p>&lt;link&gt;&lt;meta&gt;<br><a href="https://www.nowcoder.com/questionTerminal/82be034e331a47c9893b2ceef5b8b8b3">Discussion</a></p></li></ul><h2 id="什么是webgl-它有什么优点">什么是WebGL,它有什么优点?<a class="header-anchor" href="#什么是webgl-它有什么优点">⁍</a></h2><ul><li>WebGL（全写WebGraphicsLibrary）是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGLES2.0结合在一起，通过增加OpenGLES2.0的一个JavaScript绑定，WebGL可以为HTML5Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。</li><li>WebGL完美地解决了现有的Web交互式三维动画的两个问题：<ul><li>第一，它通过HTML脚本本身实现Web交互式三维动画的制作，无需任何浏览器插件支持;</li><li>第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。</li></ul></li><li>通俗说WebGL中canvas绘图中的3D版本。因为原生的WebGL很复杂，我们经常会使用一些三方的库，如three.js等，这些库多数用于HTML5游戏开发。<br><a href="https://www.nowcoder.com/questionTerminal/b981e41cb07549f0bc8ef75c5a8d4690">Discussion</a></li></ul><h2 id="请你描述一下-cookies，sessionstorage-和-localstorage-的区别">请你描述一下 cookies，sessionStorage 和 localStorage 的区别?<a class="header-anchor" href="#请你描述一下-cookies，sessionstorage-和-localstorage-的区别">⁍</a></h2><ul><li>sessionStorage和localStorage是HTML5WebStorageAPI提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</li><li>sessionStorage、localStorage、cookie都是在 <strong>浏览器端</strong> 存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念。sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的</li><li>cookies会发送到 <strong>服务器端</strong> 。其余两个不会。</li><li>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。Firefox每个域名cookie限制为50个。Opera每个域名cookie限制为30个。Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。Opera许cookie多达4096个字节，包括：名（name）、值（value）和等号。InternetExplorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。</li></ul><p><strong>区别</strong></p><ul><li>-Cookie<ul><li>+每个域名存储量比较小（各浏览器不同，大致4K）</li><li>+所有域名的存储量有限制（各浏览器不同，大致4K）</li><li>+有个数限制（各浏览器不同）</li><li>+会随请求发送到服务器</li></ul></li><li>-LocalStorage<ul><li>+永久存储</li><li>+单个域名存储量比较大（推荐5MB，各浏览器不同）</li><li>+总体数量无限制</li></ul></li><li>-SessionStorage<ul><li>+只在Session内有效</li><li>+存储量更大（推荐没有限制，但是实际上各浏览器也不同）<br><a href="https://www.nowcoder.com/questionTerminal/27c08b3666e84e69874ea6e97e40afdb">Discussion</a></li></ul></li></ul><h2 id="说说你对html语义化的理解">说说你对HTML语义化的理解?<a class="header-anchor" href="#说说你对html语义化的理解">⁍</a></h2><p>(1)什么是HTML语义化？</p><ul><li>&lt;基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等&gt;</li><li>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</li></ul><p>(2)为什么要语义化？</p><ul><li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</li><li>用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li><li>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ul><p>(3)语义化标签</p><ul><li>&lt;header&gt;&lt;/header&gt;</li><li>&lt;footer&gt;&lt;/footer&gt;</li><li>&lt;nav&gt;&lt;/nav&gt;</li><li>&lt;section&gt;&lt;/section&gt;</li><li>&lt;article&gt;&lt;/article&gt;SM:用来在页面中表示一套结构完整且独立的内容部分</li><li>&lt;aside&gt;&lt;/aside&gt;SM:主题的附属信息(用途很广，主要就是一个附属内容)，如果article里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了</li><li>&lt;figure&gt;&lt;/figure&gt;SM:媒体元素，比如一些视频，图片啊等等</li><li>&lt;datalist&gt;&lt;/datalist&gt;</li><li>SM:选项列表，与input元素配合使用，来定义input可能的值</li><li>&lt;details&gt;&lt;/details&gt;</li><li>SM:用于描述文档或者文档某个部分的细节，默认属性为open</li><li>ps:配合summary一起使用<br><a href="https://www.nowcoder.com/questionTerminal/fe26e5b66a394139a61be8266689c7ea">Discussion</a></li></ul><h2 id="link和-import的区别">link和@import的区别?<a class="header-anchor" href="#link和-import的区别">⁍</a></h2><ul><li>XML/HTML代码</li><li>&lt;linkrel=‘stylesheet’ rev=‘stylesheet’ href='CSS文件’type='text/css’media=‘all’/&gt;</li><li>XML/HTML代码</li><li>&lt;styletype='text/css’media=‘screen’&gt;</li><li>@importurl(‘CSS文件’);</li><li>&lt;/style&gt;</li><li>两者都是外部引用CSS的方式，但是存在一定的区别：</li><li>区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。<br><a href="https://www.nowcoder.com/questionTerminal/ae9f71f950e64c9d82b1b396b7f3bec5">Discussion</a></li></ul><h2 id="说说你对svg理解">说说你对SVG理解?<a class="header-anchor" href="#说说你对svg理解">⁍</a></h2><ul><li>SVG可缩放矢量图形（ScalableVectorGraphics）是基于可扩展标记语言（XML），用于描述二维矢量图形的一种图形格式。SVG是W3C(‘WorldWideWebConSortium’即’国际互联网标准组织’)在2000年8月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。SVG严格遵从XML语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。SVG于2003年1月14日成为W3C推荐标准。</li><li>特点：</li><li>(1)任意放缩</li><li>用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。</li><li>(2)文本独立</li><li>SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。</li><li>(3)较小文件</li><li>总体来讲，SVG文件比那些GIF和JPEG格式的文件要小很多，因而下载也很快。</li><li>(4)超强显示效果</li><li>SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。</li><li>(5)超级颜色控制</li><li>SVG图像提供一个1600万种颜色的调色板，支持ICC颜色描述文件标准、RGB、线X填充、渐变和蒙版。</li><li>(6)交互X和智能化。SVG面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式Flash竞争的问题，另一个问题就是SVG的本地运行环境下的厂家支持程度。</li><li>浏览器支持：</li><li>InternetExplorer9，火狐，谷歌Chrome，Opera和Safari都支持SVG。</li><li>IE8和早期版本都需要一个插件-如AdobeSVG浏览器，这是免费提供的。<br><a href="https://www.nowcoder.com/questionTerminal/c5982f8b70ba427aab804643e12ab44d">Discussion</a></li></ul><h2 id="html全局属性-global-attribute-有哪些">HTML全局属性(global attribute)有哪些?<a class="header-anchor" href="#html全局属性-global-attribute-有哪些">⁍</a></h2><ul><li>参考资料：MDN:htmlglobalattribute或者W3CHTMLglobal-attributesaccesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt+shift+a可激活元素class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素contenteditable:指定元素内容是否可编辑contextmenu:自定义鼠标右键弹出菜单内容data-*:为元素增加自定义属性dir:设置元素文本方向draggable:设置元素是否可拖拽dropzone:设置元素拖放类型：copy,move,linkhidden:表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果id:元素id，文档内唯一lang:元素内容的的语言spellcheck:是否启动拼写和语法检查style:行内css样式tabindex:设置元素可以获得焦点，通过tab可以导航title:元素相关的建议信息translate:元素和子孙节点内容是否需要本地化<br><a href="https://www.nowcoder.com/questionTerminal/5505ebcd04df48dd91e32977cb9a9b11">Discussion</a></li></ul><h2 id="说说超链接target属性的取值和作用？">说说超链接target属性的取值和作用？<a class="header-anchor" href="#说说超链接target属性的取值和作用？">⁍</a></h2><ul><li>target这个属性指定所链接的页面在浏览器窗口中的打开方式。</li><li>它的参数值主要有：</li><li>a、_blank：在新浏览器窗口中打开链接文件</li><li>b、_parent：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象_self参数一。</li><li>c、_self：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。但是我不太理解。</li><li>d、_top：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。<br><a href="https://www.nowcoder.com/questionTerminal/e79c30255a4844028998097f4f75c85e">Discussion</a></li></ul><h2 id="data-属性的作用是什么？"><code>data-</code>属性的作用是什么？<a class="header-anchor" href="#data-属性的作用是什么？">⁍</a></h2><ul><li><code>data-</code>为H5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的<code>dataset</code>属性获取，不支持该属性的浏览器可以通过<code>getAttribute</code>方法获取:</li><li>需要注意的是：<code>data-</code>之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。所有主流浏览器都支持data-*属性。</li><li>即：当没有合适的属性和元素时，自定义的data属性是能够存储页面或App的私有的自定义数据。<br><a href="https://www.nowcoder.com/questionTerminal/6b7dbb4ce186400b857a7afd64b72346">Discussion</a></li></ul><h2 id="介绍一下你对浏览器内核的理解？">介绍一下你对浏览器内核的理解？<a class="header-anchor" href="#介绍一下你对浏览器内核的理解？">⁍</a></h2><ul><li>主要分成两部分：渲染引擎(layoutengineer或RenderingEngine)和JS引擎。渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。<br><a href="https://www.nowcoder.com/questionTerminal/595df24f5af2428480ba6ef3c392fc34">Discussion</a></li></ul><h2 id="常见的浏览器内核有哪些？">常见的浏览器内核有哪些？<a class="header-anchor" href="#常见的浏览器内核有哪些？">⁍</a></h2><ul><li>viewsourceprint?</li><li><ol><li></li></ol></li><li>Trident内核：IE,MaxThon,TT,TheWorld,360,搜狗浏览器等。[又称MSHTML]</li><li><ol start="2"><li></li></ol></li><li>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li><li><ol start="3"><li></li></ol></li><li>Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]</li><li><ol start="4"><li></li></ol></li><li>Webkit内核：Safari,Chrome等。[Chrome的：Blink（WebKit的分支）]<br><a href="https://www.nowcoder.com/questionTerminal/9ed05e37c04e45b2a2d95ebe087c4be5">Discussion</a></li></ul><h2 id="iframe有那些缺点？">iframe有那些缺点？<a class="header-anchor" href="#iframe有那些缺点？">⁍</a></h2><ul><li>*iframe会阻塞主页面的Onload事件；</li><li>*搜索引擎的检索程序无法解读这种页面，不利于SEO;</li><li>*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript</li><li>动态给iframe添加src属性值，这样可以绕开以上两个问题。<br><a href="https://www.nowcoder.com/questionTerminal/ec1a7ecc8a0c4150b6df6f9a485bc26f">Discussion</a></li></ul><h2 id="label的作用是什么，是怎么用的？">Label的作用是什么，是怎么用的？<a class="header-anchor" href="#label的作用是什么，是怎么用的？">⁍</a></h2><ul><li>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</li><li>&lt;labelfor=‘Name’&gt;Number:&lt;/label&gt;</li><li>&lt;inputtype=“text“name='Name’id=‘Name’/&gt;<br><a href="https://www.nowcoder.com/questionTerminal/87786e5d47b9417caa2e1dc93b5f7037">Discussion</a></li></ul><h2 id="如何实现浏览器内多个标签页之间的通信">如何实现浏览器内多个标签页之间的通信?<a class="header-anchor" href="#如何实现浏览器内多个标签页之间的通信">⁍</a></h2><ul><li>WebSocket、SharedWorker；</li><li>我们通过监听事件，控制它的值来进行页面信息通信；</li><li>注意quirks：Safari在无痕模式下设置localstorge值时会抛出QuotaExceededError的异常；<br><a href="https://www.nowcoder.com/questionTerminal/cffb77bcd4f54671aa22a861cb8b6bcb">Discussion</a></li></ul><h2 id="如何在页面上实现一个圆形的可点击区域？">如何在页面上实现一个圆形的可点击区域？<a class="header-anchor" href="#如何在页面上实现一个圆形的可点击区域？">⁍</a></h2><ul><li>a、map+area或者svg</li><li>b、border-radius</li><li>c、纯js实现需要求一个点在不在圆上简单算法、获取鼠标坐标等等<br><a href="https://www.nowcoder.com/questionTerminal/fe155273580e46dfa2b15875e94a8b96">Discussion</a></li></ul><h2 id="title与h3的区别、b与strong的区别、i与em的区别？">title与h3的区别、b与strong的区别、i与em的区别？<a class="header-anchor" href="#title与h3的区别、b与strong的区别、i与em的区别？">⁍</a></h2><ul><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li><li>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。</li><li>i内容展示为斜体，em表示强调的文本；</li><li>PhysicalStyleElements–自然样式标签</li><li>b,i,u,s,pre</li><li>SemanticStyleElements–语义样式标签</li><li>strong,em,ins,del,code</li><li>应该准确使用语义样式标签,但不能滥用,如果不能确定时首选使用自然样式标签。<br><a href="https://www.nowcoder.com/questionTerminal/ec2d3e0107014c4ca9647ad91d0907c5">Discussion</a></li></ul><h2 id="实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？">实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？<a class="header-anchor" href="#实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？">⁍</a></h2><ul><li>&lt;divstyle=“width:100%;height:1px;background-color:black”&gt;&lt;/div&gt;<br><a href="https://www.nowcoder.com/questionTerminal/d92f26f2b98a4e2f9d150c8c123c1724">Discussion</a></li></ul><h2 id="html5标签的作用-用途">HTML5标签的作用?(用途)<a class="header-anchor" href="#html5标签的作用-用途">⁍</a></h2><ul><li>a、使Web页面的内容更加有序和规范</li><li>b、使搜索引擎更加容易按照HTML5规则识别出有效的内容</li><li>c、使Web页面更接近于一种数据字段和表<br><a href="https://www.nowcoder.com/questionTerminal/8198277d51e740b290a1ec08d1e5812c">Discussion</a></li></ul><h2 id="简述一下src与href的区别？">简述一下src与href的区别？<a class="header-anchor" href="#简述一下src与href的区别？">⁍</a></h2><ul><li>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</li><li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。</li><li>&lt;scriptsrc=‘js.js’&gt;&lt;/script&gt;</li><li>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</li><li>href是HypertextReference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li><li>&lt;linkhref='common.css’rel=‘stylesheet’/&gt;</li><li>那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。<br><a href="https://www.nowcoder.com/questionTerminal/9c8efb898bb244f88f2a5ab1b27b972c">Discussion</a></li></ul><h2 id="谈谈你对canvas的理解？">谈谈你对canvas的理解？<a class="header-anchor" href="#谈谈你对canvas的理解？">⁍</a></h2><ul><li>canvas是HTML5中新增一个HTML5标签与操作canvas的javascriptAPI，它可以实现在网页中完成动态的2D与3D图像技术。标记和SVG以及VML之间的一个重要的不同是，有一个基于JavaScript的绘图API，而SVG和VML使用一个XML文档来描述绘图。SVG绘图很容易编辑与生成，但功能明显要弱一些。canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。<br><a href="https://www.nowcoder.com/questionTerminal/05745bf27bce4b9a9b19831934a839f9">Discussion</a></li></ul><h2 id="websocket与消息推送？">WebSocket与消息推送？<a class="header-anchor" href="#websocket与消息推送？">⁍</a></h2><ul><li>B/S架构的系统多使用HTTP协议，</li><li>HTTP协议的特点：1无状态协议2用于通过Internet发送请求消息和响应消息3使用端口接收和发送消息，默认为80端口底层通信还是使用Socket完成。</li><li>HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（F5已坏）,一些变相的解决办法：</li><li>双向通信与消息推送</li><li>轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。优点：后端程序编写比较容易。缺点：请求中有大半是无用，浪费带宽和服务器资源。实例：适于小型应用。</li><li>长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。优点：在无消息的情况下不会频繁的请求，耗费资小。缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。Comet异步的ashx，实例：WebQQ、Hi网页版、FacebookIM。</li><li>长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。优点：消息即时到达，不发无用请求；管理起来也相对便。缺点：服务器维护一个长连接会增加开销。实例：Gmail聊天</li><li>FlashSocket：在页面中内嵌入一个使用了Socket类的Flash程序JavaScript通过调用此Flash程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。优点：实现真正的即时通信，而不是伪即时。缺点：客户端必须安装Flash插件；非HTTP协议，无法自动穿越防火墙。实例：网络互动游戏。</li><li>Websocket:</li><li>WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。</li><li>特点:</li><li>a、事件驱动</li><li>b、异步</li><li>c、使用ws或者wss协议的客户端socket</li><li>d、能够实现真正意义上的推送功能</li><li>缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。<br><a href="https://www.nowcoder.com/questionTerminal/bd4d40203dd04f048870d5ff76d5d709">Discussion</a></li></ul><h2 id="img的title和alt有什么区别？">img的title和alt有什么区别？<a class="header-anchor" href="#img的title和alt有什么区别？">⁍</a></h2><ul><li>Alt用于图片无法加载时显示Title为该属性提供信息，通常当鼠标滑动到元素上的时候显示<br><a href="https://www.nowcoder.com/questionTerminal/01fb7926a0c8462eb5567801c8f67ba3">Discussion</a></li></ul><h2 id="表单的基本组成部分有哪些，表单的主要用途是什么？">表单的基本组成部分有哪些，表单的主要用途是什么？<a class="header-anchor" href="#表单的基本组成部分有哪些，表单的主要用途是什么？">⁍</a></h2><ul><li>组成：表单标签、表单域、表单按钮</li><li>a、表单标签：这里面包含了处理表单数据所用CGI程序的URL,以及数据提交到服务器的方法。</li><li>b、表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。</li><li>c、表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。</li><li>主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。<br><a href="https://www.nowcoder.com/questionTerminal/ce5f3f096db94858bbd96a7d9585a48c">Discussion</a></li></ul><h2 id="表单提交中get和post方式的区别？">表单提交中Get和Post方式的区别？<a class="header-anchor" href="#表单提交中get和post方式的区别？">⁍</a></h2><ul><li>(1)、get是从服务器上获取数据，post是向服务器传送数据。</li><li>(2)、get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTPpost机制，将表单内各个字段与其内容放置在HTMLHEADER内一起传送到ACTION属性所指的URL地址,用户看不到这个过程。</li><li>(3)、对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li><li>(4)、get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li><li>(5)、get安全性低，post安全性较高。<br><a href="https://www.nowcoder.com/questionTerminal/a558b2de11a34d2f83910f7d83220290">Discussion</a></li></ul><h2 id="html5-有哪些新增的表单元素？">HTML5 有哪些新增的表单元素？<a class="header-anchor" href="#html5-有哪些新增的表单元素？">⁍</a></h2><ul><li>HTML5新增了很多表单元素让开发者构建更优秀的Web应用程序，主要有：datalistkeygenoutput<br><a href="https://www.nowcoder.com/questionTerminal/7ffb0dfd4a944c2898c98148dee56c55">Discussion</a></li></ul><h2 id="html5-废弃了哪些-html4-标签？">HTML5 废弃了哪些 HTML4 标签？<a class="header-anchor" href="#html5-废弃了哪些-html4-标签？">⁍</a></h2><ul><li>HTML5废弃了一些过时的，不合理的HTML标签：</li><li>·frame</li><li>·frameset</li><li>·noframe</li><li>·applet</li><li>·big</li><li>·center</li><li>·basefont<br><a href="https://www.nowcoder.com/questionTerminal/61c01db3031a4d91a3c4df6de1fddd91">Discussion</a></li></ul><h2 id="html5-标准提供了哪些新的-api？">HTML5 标准提供了哪些新的 API？<a class="header-anchor" href="#html5-标准提供了哪些新的-api？">⁍</a></h2><ul><li>HTML5提供的应用程序API主要有：</li><li>·MediaAPI</li><li>·TextTrackAPI</li><li>·ApplicationCacheAPI</li><li>·UserInteraction</li><li>·DataTransferAPI</li><li>·CommandAPI</li><li>·ConstraintValidationAPI</li><li>·HistoryAPI<br><a href="https://www.nowcoder.com/questionTerminal/021a9a324bb04123abd2094a085a1865">Discussion</a></li></ul><h2 id="html5-存储类型有什么区别？">HTML5 存储类型有什么区别？<a class="header-anchor" href="#html5-存储类型有什么区别？">⁍</a></h2><ul><li>HTML5能够本地存储数据，在之前都是使用cookies使用的。HTML5提供了下面两种本地存储方案：</li><li>·localStorage用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。</li><li>·sessionStorage同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储<br><a href="https://www.nowcoder.com/questionTerminal/e0ba391887af4cb78d2d7de958f57eac">Discussion</a></li></ul><h2 id="html5-应用程序缓存和浏览器缓存有什么区别？">HTML5 应用程序缓存和浏览器缓存有什么区别？<a class="header-anchor" href="#html5-应用程序缓存和浏览器缓存有什么区别？">⁍</a></h2><ul><li>应用程序缓存是HTML5的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如HTML、CSS、图片以及JavaScript。这个特性可以提高网站性能，它的实现借助于manifest文件，如下：</li><li>&lt;!doctypehtml&gt;</li><li>&lt;htmlmanifest=”example.appcache”&gt;</li><li>……</li><li>&lt;/html&gt;</li><li>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。<br><a href="https://www.nowcoder.com/questionTerminal/af6801e0e4c844e8a07590c58a313784">Discussion</a></li></ul><h2 id="html5-canvas-元素有什么用？">HTML5 Canvas 元素有什么用？<a class="header-anchor" href="#html5-canvas-元素有什么用？">⁍</a></h2><ul><li>Canvas元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在HTML上进行图形操作，</li><li>&lt;canvasid=”canvas1″width=”300″height=”100″&gt;</li><li>&lt;/canvas&gt;<br><a href="https://www.nowcoder.com/questionTerminal/77602347b5ea4a7aa1f5d81064176795">Discussion</a></li></ul><h2 id="除了-audio-和-video，html5-还有哪些媒体标签？">除了 audio 和 video，HTML5 还有哪些媒体标签？<a class="header-anchor" href="#除了-audio-和-video，html5-还有哪些媒体标签？">⁍</a></h2><ul><li>HTML5对于多媒体提供了强有力的支持，除了audio和video标签外，还支持以下标签：</li><li>&lt;embed&gt;标签定义嵌入的内容，比如插件。</li><li>&lt;embedtype=”video/quicktime”src=”Fishing.mov”&gt;</li><li>&lt;source&gt;对于定义多个数据源很有用。</li><li>&lt;videowidth=”450″height=”340″controls&gt;</li><li>&lt;sourcesrc=”jamshed.mp4″type=”video/mp4″&gt;</li><li>&lt;sourcesrc=”jamshed.ogg”type=”video/ogg”&gt;</li><li>&lt;/video&gt;</li><li>&lt;track&gt;标签为诸如video元素之类的媒介规定外部文本轨道。用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</li><li>&lt;videowidth=”450″height=”340″controls&gt;</li><li>&lt;sourcesrc=”jamshed.mp4″type=”video/mp4″&gt;</li><li>&lt;sourcesrc=”jamshed.ogg”type=”video/ogg”&gt;</li><li>&lt;trackkind=”subtitles”label=”English”src=”jamshed_en.vtt”srclang=”en”default&gt;&lt;/track&gt;</li><li>&lt;trackkind=”subtitles”label=”Arabic”src=”jamshed_ar.vtt”srclang=”ar”&gt;&lt;/track&gt;</li><li>&lt;/video&gt;<br><a href="https://www.nowcoder.com/questionTerminal/ccea2548d5994150a77c1f9c869bf674">Discussion</a></li></ul><h2 id="html5-中如何嵌入视频？">HTML5 中如何嵌入视频？<a class="header-anchor" href="#html5-中如何嵌入视频？">⁍</a></h2><ul><li>和音频类似，HTML5支持MP4、WebM和Ogg格式的视频，下面是简单示例：</li><li>&lt;videowidth=”450″height=”340″controls&gt;</li><li>&lt;sourcesrc=”jamshed.mp4″type=”video/mp4″&gt;</li><li>Yourbrowserdoes’ntsupportvideoembeddingfeature.</li><li>&lt;/video&gt;<br><a href="https://www.nowcoder.com/questionTerminal/f45c7428912646369697623c00bb4412">Discussion</a></li></ul><h2 id="html5-中如何嵌入音频？">HTML5 中如何嵌入音频？<a class="header-anchor" href="#html5-中如何嵌入音频？">⁍</a></h2><ul><li>HTML5支持MP3、Wav和Ogg格式的音频，下面是在网页中嵌入音频的简单示例：</li><li>&lt;audiocontrols&gt;</li><li>&lt;sourcesrc=”jamshed.mp3″type=”audio/mpeg”&gt;</li><li>Yourbrowserdoes’ntsupportaudioembeddingfeature.</li><li>&lt;/audio&gt;<br><a href="https://www.nowcoder.com/questionTerminal/cc8e8d4db9d94d078011c4401dd6ac01">Discussion</a></li></ul><h2 id="新的-html5-文档类型和字符集是？">新的 HTML5 文档类型和字符集是？<a class="header-anchor" href="#新的-html5-文档类型和字符集是？">⁍</a></h2><ul><li>HTML5文档类型很简单：</li><li>&lt;!doctypehtml&gt;</li><li>HTML5使用UTF-8编码示例：</li><li>&lt;metacharset=”UTF-8″&gt;<br><a href="https://www.nowcoder.com/questionTerminal/31dfd4d499bf4d0cb3362cbae7abeee8">Discussion</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习资源与计划</title>
      <link href="/augu1sto/46167eae39eb/"/>
      <url>/augu1sto/46167eae39eb/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>写在前面：</strong></p><p>写这篇文章主要是为了激励自己x</p><p>其实之前一直从众想做java后端来着，但我发现我为数不多的项目经历无一不会关注界面怎么写。</p><p>最近面了一个开发岗之后决定直视自己的内心。</p><p>但是我对前端的了解也只是局限于不是很熟练的HTML/CSS，虽然写Electron-vue的项目有用Js和vue，但其实并不了解。。一边用一遍搜索来着。。还是要打好基础才好！</p><p>下面整理一下看到的资源和课程，加油努力啦！</p></blockquote><hr><h2 id="学习资源">学习资源<a class="header-anchor" href="#学习资源">⁍</a></h2><h3 id="要学什么">要学什么<a class="header-anchor" href="#要学什么">⁍</a></h3><h4 id="html-css">HTML/CSS<a class="header-anchor" href="#html-css">⁍</a></h4><p>因为本科学过网页设计的课程，有一定HTML和CSS的基础，决定遵循<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的建议，快速把下面几本书（前三本）先过一遍。当然CSS的基础会相对弱一些，因为记不住qaq，可能会码一些<a href="https://chinese.freecodecamp.org/learn/">freecodecamp.org</a>上的练习，记录在github仓库中，再找一些网站的总结。同时根据一些常见面试题查漏补缺。</p><p>代码环境主要是VSCode+Live server本地热启动服务器的方式实时预览。</p><ul class="contains-task-list"><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 《HTML&amp;CSS设计与构建网站》（1-9&amp;最后两章？）</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://wangdoc.com/html/index.html">HTML 教程 - 网道 (wangdoc.com)</a></li></ul></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 《HTML5秘籍》（1-4）</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 《CSS揭秘》（相对比较新的一本书）</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://www.baidu.com/link?url=w-a1twkjllUiZDwXVJ0JeS58ZcHBVZt6JmGXuLy9FqyDyPqJmbd03P2SAKNN273AAEfo2d5XtSeYszlzjE7NSa&amp;wd=&amp;eqid=ecb977750006deb5000000066236c1ba">GitHub - cssmagic/CSS-Secrets: 《CSS 揭秘》这本书的大… (baidu.com)</a></li></ul></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 《CSS实战手册》</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 《CSS权威指南》</p></li></ul><h4 id="javascript-es6">Javascript -&gt; ES6<a class="header-anchor" href="#javascript-es6">⁍</a></h4><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/BV18a4y1L7kD?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">微软官方 JavaScript 入门教程【完结撒花】_哔哩哔哩_bilibili</a></li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://wangdoc.com/javascript/">JavaScript 教程 - 网道 (wangdoc.com)</a> （包含AJAX等）</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://wangdoc.com/es6/">ES6 教程 - 网道 (wangdoc.com)</a></li></ul><p><a href="http://www.amazon.cn/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%B3%BD%E5%8D%A1%E6%96%AF/dp/B007OQQVMY/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1414744358&amp;sr=1-1&amp;keywords=javascript+%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">《javascript高级程序设计》</a>，然后<a href="http://www.amazon.cn/O-Reilly%E7%B2%BE%E5%93%81%E5%9B%BE%E4%B9%A6%E7%B3%BB%E5%88%97-JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%BC%97%E5%85%B0%E7%BA%B3%E6%A0%B9/dp/B007VISQ1Y/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1414744401&amp;sr=1-1&amp;keywords=javascript+%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97">《javascript权威指南》</a></p><h4 id="axios">axios<a class="header-anchor" href="#axios">⁍</a></h4><p><a href="https://www.axios-http.cn/">Axios 中文文档 | Axios 中文网 | Axios 是一个基于 promise 的网络请求库，可以用于浏览器和 node.js (axios-http.cn)</a></p><h5 id="webapi">webapi<a class="header-anchor" href="#webapi">⁍</a></h5><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://wangdoc.com/webapi/">Web API 教程 - 网道 (wangdoc.com)</a></li></ul><h4 id="vue">vue<a class="header-anchor" href="#vue">⁍</a></h4><ul class="contains-task-list"><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 官网文档：  <a href="https://v3.cn.vuejs.org/">Vue.js (vuejs.org)</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 官方入门视频：<a href="https://www.bilibili.com/video/BV1zZ4y1R7H8?from=search&amp;seid=14382011260230935067&amp;spm_id_from=333.337.0.0">【译】Vue Mastery Intro to Vue3 — Vue3 入门教程_哔哩哔哩_bilibili</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/BV12J411m7MG?p=2">黑马程序员vue前端基础教程-4个小时带你快速入门vue_哔哩哔哩_bilibili</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox">  简单的mini-vue: <a href="https://www.bilibili.com/video/BV1Rt4y1B7sC/?spm_id_from=333.788.recommend_more_video.7">手写 mini-vue_哔哩哔哩_bilibili</a></p><ul><li><a href="https://github.com/cuixiaorui/mini-vue">GitHub - cuixiaorui/mini-vue: 实现最简 vue3 模型( Help you learn more efficiently vue3 source code )</a></li></ul></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 作者教学亲自讲解vue高级特性：<a href="https://www.bilibili.com/video/BV1d4411v7UX/?spm_id_from=333.788.recommend_more_video.0">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p><ul><li>讲义： <a href="https://vue-course-doc.vercel.app/">https://vue-course-doc.vercel.app/</a></li><li>github源码： <a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></li></ul></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/BV1rC4y187Vw?spm_id_from=333.999.0.0">跟尤雨溪一起解读Vue3源码【中英字幕】- Vue Mastery_哔哩哔哩_bilibili</a></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/BV1SZ4y1x7a9/?spm_id_from=333.788.recommend_more_video.3">【课程】Vue 3响应式原理 (Vue 3 Reactivity)【中英字幕】- Vue Mastery_哔哩哔哩_bilibili</a></p></li></ul><p>react</p><p>nodejs</p><p>echarts等</p><p>可以参考<a href="https://www.bilibili.com/read/cv10431130">2022年web前端开发学习路线图 - 哔哩哔哩 (bilibili.com)</a></p><h3 id="网站">网站<a class="header-anchor" href="#网站">⁍</a></h3><p><a href="https://chinese.freecodecamp.org/learn/">免费学习编程 - Python、JavaScript、Java、Git 等 (freecodecamp.org)</a></p><p>一个可以学习html/css/javascript/nodejs/react等并在线编程测试的网站，同时可以实现一些小项目并获取认证</p><h2 id="面试">面试<a class="header-anchor" href="#面试">⁍</a></h2><p>几个前端面试知识库：（待探索和整理）</p><p><a href="https://lucifer.ren/fe-interview/#/">大前端面试宝典 - 图解前端 (lucifer.ren)</a></p><p><a href="http://www.h-camel.com/index.html">前端面试每日3+1-以前端面试题来驱动学习，提倡每日学习与思考，每天进步一点！ (h-camel.com)</a></p><p><a href="https://lgwebdream.github.io/FE-Interview/">前端面试 (lgwebdream.github.io)</a></p><p><a href="https://mitianyi.gitbook.io/frontend-interview-guide/">序章 - 前端面试指南 (gitbook.io)</a></p><p><a href="https://www.nowcoder.com/ta/review-frontend">前端校招面试题目合集_HTML/CSS/前端基础_牛客网 (nowcoder.com)</a></p><p><a href="https://docs.chenqaq.com/">介绍 - 前端面试小册 (chenqaq.com)</a></p><h2 id="项目计划">项目计划<a class="header-anchor" href="#项目计划">⁍</a></h2><h2 id="其他">其他<a class="header-anchor" href="#其他">⁍</a></h2><p>⭐ <a href="https://github.com/helloqingfeng/Awsome-Front-End-learning-resource">helloqingfeng/Awsome-Front-End-learning-resource: GitHub最全的前端资源汇总仓库（包括前端学习、开发资源、求职面试等）</a></p><p><a href="https://www.kwgg2020.com/">前端导航 (kwgg2020.com)</a></p><p><a href="https://dwqs.gitbooks.io/frontenddevhandbook/content/">前端开发者手册 · Front-end Developer HandBook (gitbooks.io)</a></p><p><a href="https://github.com/nicejade/Front-end-tutorial">nicejade/Front-end-tutorial: 最全的资源教程-前端涉及的所有知识体系，并在 Nice Front-end Tutorial 持续更新； (github.com)</a></p><p><a href="https://github.com/helloqingfeng/Awsome-Front-End-learning-resource">helloqingfeng/Awsome-Front-End-learning-resource: GitHub最全的前端资源汇总仓库（包括前端学习、开发资源、求职面试等）</a></p><p><a href="https://www.ruanyifeng.com/blog/javascript/">https://www.ruanyifeng.com/blog/javascript/</a></p><p>⭐ <a href="https://www.ruanyifeng.com/blog/2016/11/javascript.html">JavaScript 全栈工程师培训教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://wangdoc.com/">网道 - 互联网开发文档 (wangdoc.com)</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com/qiu-deqing/FE-learning">GitHub - qiu-deqing/FE-learning: 结合个人经历总结的前端入门方法</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> FE学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo建站与美化 | 关于Butterfly主题一些高级功能和修改方法的记录</title>
      <link href="/augu1sto/743ac4e0b3e7/"/>
      <url>/augu1sto/743ac4e0b3e7/</url>
      
        <content type="html"><![CDATA[<h2 id="标签外挂">标签外挂<a class="header-anchor" href="#标签外挂">⁍</a></h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安裝文檔(三) 主題配置-1 | Butterfly</a></p><h3 id="tab">Tab<a class="header-anchor" href="#tab">⁍</a></h3><h4 id="使用方法">使用方法<a class="header-anchor" href="#使用方法">⁍</a></h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% tabs Unique name, [index] %&#125;<br>&lt;!-- tab [Tab caption] [@icon] --&gt;<br>Any content (support inline tags too).<br>&lt;!-- endtab --&gt;<br>&#123;% endtabs %&#125;<br><br>Unique name   : Unique name of tabs block tag without comma.<br><span class="hljs-code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span><br><span class="hljs-code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span><br><span class="hljs-code">                Only for current url of post/page must be unique!</span><br><span class="hljs-code">[index]       : Index number of active tab.</span><br><span class="hljs-code">                If not specified, first tab (1) will be selected.</span><br><span class="hljs-code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span><br><span class="hljs-code">                Optional parameter.</span><br><span class="hljs-code">[Tab caption] : Caption of current tab.</span><br><span class="hljs-code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span><br><span class="hljs-code">                If not caption specified, but specified icon, caption will empty.</span><br><span class="hljs-code">                Optional parameter.</span><br><span class="hljs-code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)</span><br><span class="hljs-code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span><br><span class="hljs-code">                Optional parameter.</span><br></code></pre></td></tr></table></figure><h4 id="实例">实例<a class="header-anchor" href="#实例">⁍</a></h4><div class="tabs" id="example"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#example-1">源码</button></li><li class="tab"><button type="button" data-href="#example-2"><i class="fas fa-font"></i>icon</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="example-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% tabs example, -1 %&#125;<br>&lt;!-- tab 源码 --&gt;<br><span class="hljs-strong">**Hello world**</span><br>&lt;!-- endtab --&gt;<br><br>&lt;!-- tab icon@fas fa-font --&gt;<br>icon test<br>&lt;!-- endtab --&gt;<br>&#123;% endtabs %&#125;<br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="example-2"><p>icon test</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="hidetoggle-折叠">hideToggle 折叠<a class="header-anchor" href="#hidetoggle-折叠">⁍</a></h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>示例</span></div>    <div class="hide-content"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% hideToggle 示例 %&#125;<br>来，试试看吧<br>&#123;% endhideToggle %&#125;<br></code></pre></td></tr></table></figure></div></div><h3 id="note">note<a class="header-anchor" href="#note">⁍</a></h3><div class="tabs" id="note"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#note-1">设置默认配置</button></li><li class="tab"><button type="button" data-href="#note-2">基本用法</button></li><li class="tab"><button type="button" data-href="#note-3">效果预览</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="note-1"><p>在主题文件中修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">note:</span><br>  <span class="hljs-comment"># Note tag style values:</span><br>  <span class="hljs-comment">#  - simple    bs-callout old alert style. Default.</span><br>  <span class="hljs-comment">#  - modern    bs-callout new (v2-v3) alert style.</span><br>  <span class="hljs-comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br>  <span class="hljs-comment">#  - disabled  disable all CSS styles import of note tag.</span><br>  <span class="hljs-attr">style:</span> <span class="hljs-string">flat</span><br>  <span class="hljs-attr">icons:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">border_radius:</span> <span class="hljs-number">3</span><br>  <span class="hljs-comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br>  <span class="hljs-comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span><br>  <span class="hljs-attr">light_bg_offset:</span> <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="note-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note [color] [icon] [style] %&#125;<br>Any content (support inline tags too.io).<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>名稱</th><th>用法</th></tr></thead><tbody><tr><td>color</td><td>【可选】顔色(default /  blue / pink / red / purple / orange / green)</td></tr><tr><td>icon</td><td>【可选】可配置自定义icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td>【可选】可覆盖配置中的 style（simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="note-3"><div class="note default simple"><p>default simple</p></div><div class="note primary flat"><p>primary flat</p></div><div class="note pink morden flat"><p>pink morden</p></div><div class="note warning no-icon flat"><p>note warning no-icon flat</p></div><div class="note green icon disabled"><i class="note-icon fab fa-internet-explorer"></i><p>green ‘fab fa-internet-explorer’ disabled</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="音乐播放">音乐播放<a class="header-anchor" href="#音乐播放">⁍</a></h2><p><a href="https://akilar.top/posts/3afa069a/">引入Aplayer播放音乐 | Akilarの糖果屋</a></p><h3 id="安装aplayer插件">安装Aplayer插件<a class="header-anchor" href="#安装aplayer插件">⁍</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-tag-aplayer --save<br></code></pre></td></tr></table></figure><h3 id="配置">配置<a class="header-anchor" href="#配置">⁍</a></h3><ol><li><p>在站点配置文件<code>[Blogroot]\_config.yml</code>中新增配置项，建议直接加在最底下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-comment"># APlayer</span><br><span class="hljs-comment"># https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md</span><br><span class="hljs-attr">aplayer:</span><br>  <span class="hljs-attr">meting:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">asset_inject:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>修改主题配置文件<code>[Blogroot]\_config.butterfly.yml</code>中关于 Aplayer 的配置内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-comment"># Inject the css and script (aplayer/meting)</span><br><span class="hljs-attr">aplayerInject:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="插入-aplayer-html">插入 Aplayer html<a class="header-anchor" href="#插入-aplayer-html">⁍</a></h3><ol><li><p>aplayer html例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aplayer no-destroy&quot;</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;6990698783&quot;</span> <span class="hljs-attr">data-server</span>=<span class="hljs-string">&quot;netease&quot;</span> <span class="hljs-attr">data-type</span>=<span class="hljs-string">&quot;playlist&quot;</span> <span class="hljs-attr">data-fixed</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">data-mini</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">data-listFolded</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">data-order</span>=<span class="hljs-string">&quot;random&quot;</span> <span class="hljs-attr">data-preload</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">data-autoplay</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">muted</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>参数一览</span></div>    <div class="hide-content"><table><thead><tr><th>option</th><th>default</th><th>description</th></tr></thead><tbody><tr><td><strong>data-id</strong></td><td><strong>require</strong></td><td><code>song id</code> / <code>playlist id</code> / <code>album id</code> / <code>search keyword</code></td></tr><tr><td><strong>data-server</strong></td><td><strong>require</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>,<code> baidu</code></td></tr><tr><td><strong>data-type</strong></td><td><strong>require</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>data-fixed</td><td>FALSE</td><td>enable fixed mode</td></tr><tr><td>data-mini</td><td>FALSE</td><td>enable mini mode</td></tr><tr><td>data-autoplay</td><td>FALSE</td><td>是否自动播放 audio autoplay</td></tr><tr><td>data-theme</td><td>#2980b9</td><td>main color</td></tr><tr><td>data-loop</td><td>all</td><td>循环播放，参数可选: ‘all’, ‘one’, ‘none’</td></tr><tr><td>data-order</td><td>list</td><td>播放顺序，参数可选: ‘list’, ‘random’</td></tr><tr><td>data-preload</td><td>auto</td><td>values: ‘none’, ‘metadata’, ‘auto’</td></tr><tr><td>data-volume</td><td>0.7</td><td>默认音量，播放器会记录用户设定的音量，用户设定后，默认音量失效。</td></tr><tr><td>data-mutex</td><td>TRUE</td><td>prevent to play multiple player at the same time, pause other players  when this player start play</td></tr><tr><td>data-lrctype</td><td>0</td><td>lyric type 歌词类型（？</td></tr><tr><td>data-listfolded</td><td>FALSE</td><td>list一开始是否是折叠的 indicate whether list should folded at first</td></tr><tr><td>data-listmaxheight</td><td>340px</td><td>list max height</td></tr><tr><td>data-storagename</td><td>metingjs</td><td>localStorage key that store player setting</td></tr></tbody></table></div></div></li><li><p>在主题配置文件<code>[Blogroot]\_config.butterfly.yml</code>的 inject 配置项中添加 Aplayer 的容器。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-attr">inject:</span><br>  <span class="hljs-attr">head:</span><br>  <span class="hljs-attr">bottom:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&lt;div</span> <span class="hljs-string">class=&quot;aplayer</span> <span class="hljs-literal">no</span><span class="hljs-string">-destroy&quot;</span> <span class="hljs-string">data-id=&quot;6990698783&quot;</span> <span class="hljs-string">data-server=&quot;netease&quot;</span> <span class="hljs-string">data-type=&quot;playlist&quot;</span> <span class="hljs-string">data-fixed=&quot;true&quot;</span> <span class="hljs-string">data-mini=&quot;true&quot;</span> <span class="hljs-string">data-listFolded=&quot;false&quot;</span> <span class="hljs-string">data-order=&quot;random&quot;</span> <span class="hljs-string">data-preload=&quot;none&quot;</span> <span class="hljs-string">data-autoplay=&quot;false&quot;</span> <span class="hljs-string">muted&gt;&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="样式修改-靠边隐藏">样式修改-靠边隐藏<a class="header-anchor" href="#样式修改-靠边隐藏">⁍</a></h3><ol><li><p>添加一下 CSS 样式使其自动缩进隐藏。在 <code>[Blogroot]\themes\butterfly\source\css\custom.css</code> 中 (没有这个文件就按照路径自己新建) 添加如下内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.aplayer</span><span class="hljs-selector-class">.aplayer-fixed</span><span class="hljs-selector-class">.aplayer-narrow</span> <span class="hljs-selector-class">.aplayer-body</span> &#123;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">66px</span> <span class="hljs-meta">!important</span>;<br>  <span class="hljs-comment">/* 默认情况下缩进左侧66px，只留一点箭头部分 */</span><br>&#125;<br><br><span class="hljs-selector-class">.aplayer</span><span class="hljs-selector-class">.aplayer-fixed</span><span class="hljs-selector-class">.aplayer-narrow</span> <span class="hljs-selector-class">.aplayer-body</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>  <span class="hljs-comment">/* 鼠标悬停是左侧缩进归零，完全显示按钮 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不要忘了到主题配置文件引入自定义样式，修改 <code>[Blogroot]_config.butterfly.yml</code> 的 <code>inject</code> 配置项：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">inject:</span><br>  <span class="hljs-attr">head:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&lt;link</span> <span class="hljs-string">rel=&quot;stylesheet&quot;</span> <span class="hljs-string">href=&quot;/css/custom.css&quot;</span>  <span class="hljs-string">media=&quot;defer&quot;</span> <span class="hljs-string">onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="一些可以参考的资源">一些可以参考的资源<a class="header-anchor" href="#一些可以参考的资源">⁍</a></h2><p><a href="https://blog.imzjw.cn/posts/b74f504f">https://blog.imzjw.cn/posts/b74f504f</a></p><p><a href="https://akilar.top/posts/615e2dec/">Tag Plugins Plus | Akilarの糖果屋</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo建站与美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode方法总结</title>
      <link href="/augu1sto/a149dab80ba2/"/>
      <url>/augu1sto/a149dab80ba2/</url>
      
        <content type="html"><![CDATA[<h2 id="数组-字符串">数组/字符串<a class="header-anchor" href="#数组-字符串">⁍</a></h2><h3 id="区间问题">区间问题<a class="header-anchor" href="#区间问题">⁍</a></h3><ul><li>数组不变，区间查询：<strong>前缀和</strong>、树状数组、线段树；</li><li>数组单点修改，区间查询：<strong>树状数组</strong>、线段树；</li><li>数组区间修改，单点查询：<strong>差分</strong>、线段树； ✔</li><li>数组区间修改，区间查询：<strong>线段树</strong>。</li></ul><h4 id="前缀和">前缀和<a class="header-anchor" href="#前缀和">⁍</a></h4><h5 id="思路">思路<a class="header-anchor" href="#思路">⁍</a></h5><p><strong>区间和</strong> --》前缀和</p><ul><li>定义 prefixSum 数组，prefixSum[x]：第 0 项到 第 x 项 的和。<br>$$prefixSum[x] = nums[0] + nums[1] +…+nums[x]$$</li><li>nums 的某项 = 两个相邻前缀和的差：<br>$nums[x] = prefixSum[x] - prefixSum[x - 1]$</li><li><strong>nums 的 第 i 到 j 项 的和</strong> ，有：<br>$$nums[i] +…+nums[j]=prefixSum[j] - prefixSum[i - 1]$$</li></ul><h5 id="例题">例题<a class="header-anchor" href="#例题">⁍</a></h5><h5 id="2055-蜡烛之间的盘子-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/plates-between-candles">2055. 蜡烛之间的盘子 (leetcode-cn.com)</a><a class="header-anchor" href="#2055-蜡烛之间的盘子-leetcode-cn-com">⁍</a></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">platesBetweenCandles</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        <span class="hljs-comment"># count the plates , preSum</span><br>        countPlates = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(s)<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:<br>                countPlates[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> item ==<span class="hljs-string">&#x27;|&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> item == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                countPlates[i] = countPlates[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                countPlates[i] = countPlates[i-<span class="hljs-number">1</span>]<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># find the nearest candle from the right</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        right = [n]*n <span class="hljs-comment"># right[n-1] = n</span><br>        <span class="hljs-keyword">if</span> s[n-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>            right[n-<span class="hljs-number">1</span>] = n-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s[j] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>                right[j] = j<br>            <span class="hljs-keyword">else</span>:<br>                right[j] = right[j+<span class="hljs-number">1</span>]<br>                <span class="hljs-built_in">print</span>(j)<br>        <span class="hljs-comment"># find the nearest candle from the left</span><br>        left = [-<span class="hljs-number">1</span>]*n<br>        <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>            left[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            <span class="hljs-keyword">if</span> s[j] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>                left[j] = j<br>            <span class="hljs-keyword">else</span>:<br>                left[j] = left[j-<span class="hljs-number">1</span>]<br>        <br>        <span class="hljs-comment"># check the query</span><br>        res = []<br>        <span class="hljs-keyword">for</span> query <span class="hljs-keyword">in</span> queries:<br>            m = right[query[<span class="hljs-number">0</span>]]<br>            n = left[query[<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">if</span> n&lt;=m:<br>                res.append(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                res.append(countPlates[n]-countPlates[m])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="差分数组">差分数组<a class="header-anchor" href="#差分数组">⁍</a></h4><p>「差分」可以看做是求「前缀和」的逆向过程。</p><p>对于一个「 <strong>将区间$[l,r]$ 整体增加一个值$v$</strong> 」操作，我们可以对差分数组$c$ 的影响看成两部分：</p><ul><li>对 $c[l]+=v$ ：由于差分是前缀和的逆向过程，这个操作对于将来的查询而言，带来的影响是对于所有的下标 <strong>大于等于</strong> $l$ 的位置都增加了值 $v$ ；</li><li>对 $c[r+1]-=v$ ：由于我们期望只对$[l,r]$产生影响，因此需要对下标大于$r$的位置进行减值操作，从而抵消“影响”。</li></ul><p>对于最后的构造答案，可看做是对每个下标做“单点查询”操作，只需要 <strong>对差分数组求前缀和</strong> 即可。</p><h5 id="例题-2">例题<a class="header-anchor" href="#例题-2">⁍</a></h5><p><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">corpFlightBookings</span>(<span class="hljs-params">self, bookings: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        diff = [<span class="hljs-number">0</span>]*n<br>        <span class="hljs-keyword">for</span> booking <span class="hljs-keyword">in</span> bookings:<br>            i = booking[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span><br>            j = booking[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>            diff[i] += booking[<span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span> &lt; n:<br>                diff[j+<span class="hljs-number">1</span>] -= booking[<span class="hljs-number">2</span>]<br>        <br>        ans = [<span class="hljs-number">0</span>]*n<br>        ans[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            ans[i] += ans[i-<span class="hljs-number">1</span>]+diff[i]<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="滑动窗口">滑动窗口<a class="header-anchor" href="#滑动窗口">⁍</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">problemName</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-comment"># Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span><br>        x, y = ..., ...<br><br>        <span class="hljs-comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span><br>        start = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span><br>            x = new_x<br>            <span class="hljs-keyword">if</span> condition:<br>                y = new_y<br><span class="hljs-comment"># 举例</span><br>            hashmap[s[end]] = hashmap.get(s[end], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(hashmap) == end - start + <span class="hljs-number">1</span>:<br>                max_len = <span class="hljs-built_in">max</span>(max_len, end - start + <span class="hljs-number">1</span>)<br><br>            <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            ------------- 下面是两种情况，读者请根据题意二选1 -------------</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span><br>            <span class="hljs-comment"># Step 4 - 情况1</span><br>            <span class="hljs-comment"># 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 </span><br>            <span class="hljs-comment"># 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, </span><br>            <span class="hljs-comment"># 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 </span><br>            <span class="hljs-keyword">if</span> 窗口长度达到了限定长度:<br>                <span class="hljs-comment"># 更新 (部分或所有) 维护变量 </span><br>                <span class="hljs-comment"># 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变</span><br><br>            <span class="hljs-comment"># Step 4 - 情况2</span><br>            <span class="hljs-comment"># 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span><br>            <span class="hljs-comment"># 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span><br>            <span class="hljs-comment"># 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span><br>            <span class="hljs-keyword">while</span> 不合法:<br>                <span class="hljs-comment"># 更新 (部分或所有) 维护变量 </span><br>                <span class="hljs-comment"># 不断移动窗口左指针直到窗口再次合法</span><br>            <span class="hljs-comment"># 举例</span><br>            <span class="hljs-keyword">while</span> end - start + <span class="hljs-number">1</span> &gt; <span class="hljs-built_in">len</span>(hashmap):<br>                head = s[start]<br>                hashmap[head] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> hashmap[head] == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">del</span> hashmap[head]<br>                start += <span class="hljs-number">1</span><br><br><br>        <span class="hljs-comment"># Step 5: 返回答案</span><br>        <span class="hljs-keyword">return</span> ...<br><br>作者：eason734<br>链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h3 id="二分查找">二分查找<a class="header-anchor" href="#二分查找">⁍</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/414598-27417f3323288d71.png" alt="img"></p><p><a href="https://www.jianshu.com/p/b6ad653fb2e1">十分好用的二分查找法模板（Python 代码、Java 代码） - 简书 (jianshu.com)</a></p><p><img src="https://upload-images.jianshu.io/upload_images/414598-22d9deba0cda758e.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/414598-5df9718092158486.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><h4 id="找第一个大于target的数">找第一个大于target的数<a class="header-anchor" href="#找第一个大于target的数">⁍</a></h4><h5 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置</a><a class="header-anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置">⁍</a></h5><p>将问题转化为 找 <code>target-1</code>和<code>target</code>的最右侧值a和b，最后的区间是（a+1,b）。需要思考的是，此处的<code>target-1</code>代表的是仅次于<code>target</code>大小的数（也有可能是target-2之类的），<strong>故<code>binarySearch</code>寻找的是第一个大于<code>target</code>的数，接收完返回值只需<code>-1</code>即可</strong></p><p>注意细节（转化后的问题可以理解为<a href="https://leetcode-cn.com/problems/search-insert-position/description/">35. 搜索插入位置</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> a = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> b = -<span class="hljs-number">1</span>;<br><br>    a = binaryFind(nums, target - <span class="hljs-number">1</span>); <span class="hljs-comment">//target的左界=第一个大于target-1的数</span><br>    b = binaryFind(nums, target) - <span class="hljs-number">1</span>; <span class="hljs-comment">//target的右界=第一个大于target的数-1</span><br>    <span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; nums[b] == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; a, b &#125;;<br>    <span class="hljs-comment">// a&lt;b的情况，low&gt;high（空集）时，res直接返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binaryFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">//返回第一个大于target的数的下标</span><br>    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> high = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = nums.length; <span class="hljs-comment">//考虑到空集的情况，结果还要-1，故这里取nums.length</span><br><br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-keyword">int</span> mid = (high + low) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>        high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//不断向target逼近，若此时刚好跳出，则mid比target坐标刚好大1</span><br>        res = mid;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回溯">回溯<a class="header-anchor" href="#回溯">⁍</a></h2><h3 id="回溯法模板">回溯法模板<a class="header-anchor" href="#回溯法模板">⁍</a></h3><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分类">分类<a class="header-anchor" href="#分类">⁍</a></h4><ul><li><p><a href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98">组合问题</a>：N个数里面按一定规则找出k个数的集合</p><ul><li><pre><code class="language-java">  public void backtracking(int n, int k, int startIndex) &#123;    if (comb.size() == k) &#123;      res.add(new ArrayList&lt;&gt;(comb));      return;    &#125;    for (int i = startIndex; i &lt;= n - (k - comb.size()) + 1; i++) &#123;      comb.add(i);      backtracking(n, k, i + 1);      comb.removeLast();    &#125;  &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>- [切割问题](#切割问题)：一个字符串按一定规则有几种切割方式<br><br>  - 从startIndex循环，确定长度<br><br>    切割条件的判断，不满足条件就continue<br><br>- [子集问题](#子集问题)：一个N个数的集合里有多少符合条件的子集<br><br>  - 组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点<br><br>- [排列问题](#排列问题)：N个数按一定规则全排列，有几种排列方式<br><br>  - 不需要startIndex，但是要去重，记录哪些元素用过了(?)<br><br>- [棋盘问题](#棋盘问题)：N皇后，解数独等等<br><br>#### 去重<br><br>- 对于排序后的数组，有重复的话就去掉与上个一样的数<br><br>  - ```java<br>    for (int i = startIndex; i &lt; nums.length; i++) &#123;<br>      if (i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1]) &#123; //去重<br>        continue;<br>      &#125;<br>      path.add(nums[i]);<br>      backtracking(nums, i + 1);<br>      path.removeLast();<br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>记录有没有被访问过（注意在哪里更新visited表）</p><ul><li><p>递增子序列</p></li><li><pre><code class="language-java">    int[] visited = new int[201]; //记录数是否被访问过，访问过的(数+100)对应置1    for (int i = startIndex; i &lt; nums.length; i++) &#123;      if (        !path.isEmpty() &amp;&amp;        nums[i] &lt; path.getLast() ||        (visited[nums[i] + 100] == 1)      ) &#123;        continue;      &#125;      visited[nums[i] + 100] = 1;      path.add(nums[i]);      backtracking(nums, i + 1);      path.removeLast();    &#125;  &#125;</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode | Python刷Leetcode注意点</title>
      <link href="/augu1sto/b18cb629c043/"/>
      <url>/augu1sto/b18cb629c043/</url>
      
        <content type="html"><![CDATA[<p>想尝试拿python刷刷leetcode，随手记一点注意事项</p><h2 id="一些不一样的写法">一些不一样的写法<a class="header-anchor" href="#一些不一样的写法">⁍</a></h2><h3 id="三元表达式">三元表达式<a class="header-anchor" href="#三元表达式">⁍</a></h3><p><code>r = a if condition else b </code></p><h3 id="true-or-false">True or False<a class="header-anchor" href="#true-or-false">⁍</a></h3><p>大写</p><h3 id="没有自增和自减">没有自增和自减<a class="header-anchor" href="#没有自增和自减">⁍</a></h3><p><code>i += 1</code>/<code>i -= 1</code></p><h3 id="最大值-最小值">最大值/最小值<a class="header-anchor" href="#最大值-最小值">⁍</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">max_value = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-comment"># math.inf</span><br>min_value = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>) <span class="hljs-comment"># -math.inf</span><br></code></pre></td></tr></table></figure><h3 id="进制转换">进制转换<a class="header-anchor" href="#进制转换">⁍</a></h3><ul><li><p>转10进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>, base)<br></code></pre></td></tr></table></figure></li><li><p>转2进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>) -&gt; <span class="hljs-built_in">str</span> <span class="hljs-comment"># &#x27;0b10&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>转8进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">oct</span>(<span class="hljs-built_in">int</span>) -&gt; <span class="hljs-built_in">str</span> <span class="hljs-comment"># &#x27;0o77&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>转16进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>) -&gt; <span class="hljs-built_in">str</span> <span class="hljs-comment"># &#x27;0xff&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="运算">运算<a class="header-anchor" href="#运算">⁍</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 除法</span><br>a = <span class="hljs-number">3</span>/<span class="hljs-number">2</span> <span class="hljs-comment"># 1.5</span><br>a = <span class="hljs-built_in">int</span>(-<span class="hljs-number">3</span>/<span class="hljs-number">2</span>) <span class="hljs-comment"># -1</span><br>a = math.floor(-<span class="hljs-number">3</span>/<span class="hljs-number">2</span>) <span class="hljs-comment"># -2</span><br>a = math.ceil(-<span class="hljs-number">3</span>/<span class="hljs-number">2</span>) <span class="hljs-comment"># -1</span><br><span class="hljs-comment"># 幂</span><br>x**y == <span class="hljs-built_in">pow</span>(x,y)<br><span class="hljs-comment"># 根号</span><br>math.sqrt(<span class="hljs-number">4</span>) <span class="hljs-comment"># 2.0</span><br><span class="hljs-comment"># 绝对值</span><br><span class="hljs-built_in">abs</span>(-<span class="hljs-number">4</span>) <span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure><h3 id="指定排序">指定排序<a class="header-anchor" href="#指定排序">⁍</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取列表的第二个元素</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeSecond</span>(<span class="hljs-params">elem</span>):</span><br>    <span class="hljs-keyword">return</span> elem[<span class="hljs-number">1</span>]<br><span class="hljs-comment"># 列表</span><br>random = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)]<br><span class="hljs-comment"># 指定第二个元素排序</span><br>random.sort(key=takeSecond)<br><br><span class="hljs-comment">####</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-built_in">sorted</span>(b,key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>c<br>[[<span class="hljs-number">4</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = <span class="hljs-built_in">sorted</span>(b) <span class="hljs-comment"># x[0] by default</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>]]<br></code></pre></td></tr></table></figure><h3 id="二维数组赋值">二维数组赋值<a class="header-anchor" href="#二维数组赋值">⁍</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp = [[<span class="hljs-number">0</span>]*target <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><h2 id="数据结构">数据结构<a class="header-anchor" href="#数据结构">⁍</a></h2><h3 id="str-1">str[^1]<a class="header-anchor" href="#str-1">⁍</a></h3><p>不可变有序序列</p><p><strong>常用函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">format</span>(*args, **kwargs)  <span class="hljs-comment"># 用法丰富多样, 算法中可用于字符串形式的进制转换(练习: LeetCode [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/))</span><br>split(sep=<span class="hljs-literal">None</span>, maxsplit=-<span class="hljs-number">1</span>)  <span class="hljs-comment"># 以sep来分割字符串</span><br>strip([chars])  <span class="hljs-comment"># 去除首末两端的字符, 默认是 \r,\n,&quot; &quot;</span><br>join(iterable)  <span class="hljs-comment"># 将iterable内的元素拼接成字符串,如&#x27;,&#x27;.join([&#x27;leet&#x27;, &#x27;code&#x27;]) #=&quot;leet,code&quot;</span><br>replace(old, new[, count])  <span class="hljs-comment"># 字符串替换, old to new</span><br>count(sub[, start[, end]])  <span class="hljs-comment"># 统计子字符串sub的个数</span><br>startswith(prefix[, start[, end]])  <span class="hljs-comment"># 以prefix开始的字符串</span><br>endswith(suffix[, start[, end]])  <span class="hljs-comment"># 以suffix结束的字符串</span><br></code></pre></td></tr></table></figure><p><strong>常用的功能</strong></p><ul><li>拼接(加), <code>s1 + s2</code></li><li>切片, <code>s[start: end: space]</code></li><li>重复(乘), <code>s * 10</code></li></ul><h3 id="tuple"><strong>tuple</strong><a class="header-anchor" href="#tuple">⁍</a></h3><p>元组, 也叫静态列表. 内置的数据结构, 可以直接使用, 无须导入.</p><ul><li>元组常用于<strong>多变量赋值</strong>和<strong>多值返回</strong>, 只是一般在使用的时候没有加上小括号, 以显得python的牛逼之处.</li><li>需要注意的是, 当tuple里只有一个元素时, 需要在该元素之后加上<code>,</code>, 如 <code>t=(1,)</code>, 否则它就不是tuple, 而是该元素的类型.</li><li>同样支持拼接, 切片, 重复等操作</li><li>提供的函数仅有<code>index</code>和<code>count</code></li></ul><h3 id="list">list<a class="header-anchor" href="#list">⁍</a></h3><p>经常使用的数据结构, 可以实现简单的队列, 栈等.</p><p><strong>常用功能</strong>: 拼接, 重复, 切片</p><p><strong>强大的切片功能</strong>, 可用于取值, 替换, 删除等</p><ul><li><code>lst[i:j] = t</code>, 其中 t 是可迭代序列</li><li><code>del lst[i:j]</code>, 相当于 <code>lst[i:j] = []</code>.</li></ul><p><strong>常用函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">lst.sort(*, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)<br>lst.append(val)  <span class="hljs-comment"># 也可以 lst = lst + [val]</span><br>lst.clear()  <span class="hljs-comment"># 清空列表</span><br>lst.count(val)  <span class="hljs-comment"># val个数</span><br>lst.extend(t)  <span class="hljs-comment"># or s += t  # += 其实调用的是 __iadd__ 方法</span><br>lst.pop(val=lst[-<span class="hljs-number">1</span>])  <span class="hljs-comment"># (默认)从末端移除一个值</span><br>lst.remove(val)  <span class="hljs-comment"># 移除 val</span><br>lst.reverse()  <span class="hljs-comment"># 反转</span><br>lst.insert(i, val)  <span class="hljs-comment"># 在 i 处插入 val</span><br></code></pre></td></tr></table></figure><h3 id="字典-哈希表">字典/哈希表<a class="header-anchor" href="#字典-哈希表">⁍</a></h3><h4 id="dict">dict<a class="header-anchor" href="#dict">⁍</a></h4><ul><li>初始化： <code>map=&#123;&#125;</code></li><li>查找key： <code>value=map[key]</code></li><li>加入key或更改key的值： <code>map[key]=value</code></li><li>判断key是否存在： <code>if key in/not in map</code></li><li>遍历key：<code>for key in map</code></li></ul><p><strong>常用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">pop(key[, default])  <span class="hljs-comment"># 通过键去删除键值对(若没有该键则返回default(没有设置default则报错))</span><br>setdefault(key[, default])  <span class="hljs-comment"># 设置默认值</span><br>update([other])  <span class="hljs-comment"># 批量添加</span><br>get(key[, default])  <span class="hljs-comment"># 通过键获取值(若没有该键可设置默认值, 预防报错)</span><br>clear()  <span class="hljs-comment"># 清空字典</span><br>keys()  <span class="hljs-comment"># 将字典的键组成新的可迭代对象</span><br>values()  <span class="hljs-comment"># 将字典中的值组成新的可迭代对象</span><br>items()  <span class="hljs-comment"># 将字典的键值对凑成一个个元组, 组成新的可迭代对象</span><br></code></pre></td></tr></table></figure><h4 id="ordereddict">OrderedDict<a class="header-anchor" href="#ordereddict">⁍</a></h4><p>有序字典, 使得插入的顺序有序. (官方解释: Dictionary that remembers insertion order)</p><p>同样也继承于 <code>dict</code>, 所以可以使用 <code>dict</code> 所拥有的方法.</p><p>添加的方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">popitem(last=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># (默认)从末尾去除一个元素</span><br>move_to_end(key, last=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将key移到(默认)末尾</span><br></code></pre></td></tr></table></figure><h3 id="集合"><strong>集合</strong><a class="header-anchor" href="#集合">⁍</a></h3><p>set, 主要用于去重的操作.</p><p><strong>需要注意</strong>的是</p><ul><li>它的定义. 只能使用实例的方式定义, 如<code>s= set();s=&#123;1,2,4,8&#125;</code>, 而不能这样定义<code>s=&#123;&#125;</code>. 因为这样定义的是一个字典, 不能使用集合的方法.</li><li>无序特性. 有时候你会在 N 次输出同一个集合的时候, 发现它是有序的, 但是请你也一定不要相信集合是有序的.</li></ul><p><strong>常用函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">add(elem)  <span class="hljs-comment"># 向集合中添加数据</span><br>update(*others)  <span class="hljs-comment"># 迭代着增加</span><br>clear()  <span class="hljs-comment"># 清空集合</span><br>discard(elem)  <span class="hljs-comment"># 删除集合中指定的值(不存在则不删除)</span><br></code></pre></td></tr></table></figure><h3 id="队列">队列<a class="header-anchor" href="#队列">⁍</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Python 通常使用双端队列 collections.deque</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>queue = deque()<br><br>queue.append(<span class="hljs-number">1</span>) <span class="hljs-comment"># 元素 1 入队</span><br>queue.append(<span class="hljs-number">2</span>) <span class="hljs-comment"># 元素 2 入队</span><br>queue.popleft() <span class="hljs-comment"># 出队 -&gt; 元素 1</span><br>queue.popleft() <span class="hljs-comment"># 出队 -&gt; 元素 2</span><br><br><span class="hljs-comment"># deque的其他一些方法</span><br>queue.clear()  <span class="hljs-comment"># 清空队列</span><br>queue.count(val)  <span class="hljs-comment"># 返回指定元素的出现次数</span><br>queue.extend(iterable)  <span class="hljs-comment"># 从队列右边扩展一个序列的元素</span><br>queue.extendleft(iterable)  <span class="hljs-comment">#  从队列左边扩展一个列表的元素</span><br>queue.insert(val[, start[, stop]])  <span class="hljs-comment"># 在指定位置插入元素</span><br>queue.pop()  <span class="hljs-comment"># 获取最右边一个元素，并在队列中删除</span><br>queue.reverse()  <span class="hljs-comment"># 队列反转</span><br>queue.remove(val)  <span class="hljs-comment"># 删除指定元素</span><br>queue.rotate(n=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 把右边元素放到左边</span><br></code></pre></td></tr></table></figure><h2 id="堆队列"><strong>堆队列</strong><a class="header-anchor" href="#堆队列">⁍</a></h2><p>可实现优先级队列的数据结构. 可以解决 <code>top n</code> 问题, 如从1亿个数里面找出最大或最小的100个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>nums = [randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br><span class="hljs-built_in">print</span>(heapq.nlargest(<span class="hljs-number">3</span>, nums))<br><span class="hljs-built_in">print</span>(heapq.nsmallest(<span class="hljs-number">3</span>, nums))<br></code></pre></td></tr></table></figure><p><strong>常用函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>heap = []  <span class="hljs-comment"># 建堆</span><br>heapq.heappush(heap,item)  <span class="hljs-comment"># 往堆中插入新值</span><br>item = heapq.heappop(heap)  <span class="hljs-comment"># 弹出最小的值</span><br>item = heap[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 查看堆中最小的值, 不弹出</span><br>heapq.heapify(x)  <span class="hljs-comment"># 以线性时间将一个列表转为堆</span><br>item = heapq.heapreplace(heap,item)  <span class="hljs-comment"># 弹出一个最小的值, 然后将 item 插入到堆当中. 堆的整体的结构不会发生改变.</span><br>heapq.heappoppush(heap, item)  <span class="hljs-comment"># 弹出最小的值.并且将新的值插入其中.</span><br>heapq.merge(*iterables, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 将多个堆进行合并</span><br>heapq.nlargest(n, iterable, key=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 从堆中找出最大的 n 个数，key的作用和sorted( )方法里面的key类似, 用列表元素的某个属性和函数作为关键字</span><br>heapq.nsmallest(n, iterable, key=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 从堆中找出最小的 n 个数, 与 nlargest 相反</span><br></code></pre></td></tr></table></figure><h3 id="二叉树">二叉树<a class="header-anchor" href="#二叉树">⁍</a></h3><h4 id="初始化">初始化<a class="header-anchor" href="#初始化">⁍</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h3 id="遍历">遍历<a class="header-anchor" href="#遍历">⁍</a></h3><h4 id="深度遍历">深度遍历<a class="header-anchor" href="#深度遍历">⁍</a></h4><h5 id="递归">递归<a class="header-anchor" href="#递归">⁍</a></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        result = []<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preOrder</span>(<span class="hljs-params">root</span>):</span><br>            <span class="hljs-keyword">if</span> root==<span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            result.append(root.val) <span class="hljs-comment"># 前序</span><br>            preOrder(root.left)<br>            preOrder(root.right)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h5 id="迭代">迭代<a class="header-anchor" href="#迭代">⁍</a></h5><p>先出最左的就要遍历到最左！中间的就直接处理</p><ul><li><p>前序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        result = []<br>        stack = []<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        stack.append(root)<br>        <span class="hljs-keyword">while</span> st:<br>            node = stack.pop() <br>            result.append(node.val) <span class="hljs-comment"># 中</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                result.append(node.right.val) <span class="hljs-comment"># 右</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                result.append(node.left.val) <span class="hljs-comment"># 左</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li><li><p>中序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        result = []<br>        stack = []<br>        <span class="hljs-comment"># 注意循环条件</span><br>        <span class="hljs-keyword">while</span> root <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-keyword">if</span> root:<br>                <span class="hljs-comment"># 先将中节点压栈，等会处理</span><br>                stack.append(root)<br>                root = root.left<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 左节点全部遍历完</span><br>                <span class="hljs-comment"># 中节点出栈，加入结果集</span><br>                root = stack.pop()<br>                result.append(root.val)<br>                root = root.right<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li><li><p>后序</p><p>一种思路是按前序处理，最后数组翻转<code>return result[::-1]</code></p><p>这里尝试用栈来写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        res = []<br>        stack = []<br>        <span class="hljs-comment"># 前置节点</span><br>        prev = []<br><br>        <span class="hljs-keyword">while</span> root <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-keyword">if</span> root:<br>                stack.append(root)<br>                root = root.left<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 遍历完左节点</span><br>                <span class="hljs-comment"># 取出节点</span><br>                root = stack.pop()<br>                <span class="hljs-comment"># 下一个就是看右节点</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.right <span class="hljs-keyword">or</span> root.right == prev:<br>                    <span class="hljs-comment"># 如果右节点已经遍历过了</span><br>                    <span class="hljs-comment"># 将结果加进去（中）</span><br>                    res.append(root.val)<br>                    <span class="hljs-comment"># 中节点变右节点</span><br>                    prev = root<br>                    root = <span class="hljs-literal">None</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 否则系欸但入栈</span><br>                    stack.append(root)<br>                    root = root.right<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li><p>统一写法：在后面加上<code>None</code>节点，调整顺序即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        result = []<br>        st = []<br>        <span class="hljs-keyword">if</span> root:<br>            st.append(root)<br>        <span class="hljs-keyword">while</span> st:<br>            node = st.pop()<br>            <span class="hljs-keyword">if</span> node != <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> node.right: <span class="hljs-comment">#添加右节点（空节点不入栈）</span><br>                    st.append(node.right)<br>                <br>                st.append(node) <span class="hljs-comment">#添加中节点</span><br>                st.append(<span class="hljs-literal">None</span>) <span class="hljs-comment">#中节点访问过，但是还没有处理，加入空节点做为标记。</span><br>                <br>                <span class="hljs-keyword">if</span> node.left: <span class="hljs-comment">#添加左节点（空节点不入栈）</span><br>                    st.append(node.left)<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment">#只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                node = st.pop() <span class="hljs-comment">#重新取出栈中元素</span><br>                result.append(node.val) <span class="hljs-comment">#加入到结果集</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h4 id="层序">层序<a class="header-anchor" href="#层序">⁍</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;二叉树层序遍历迭代解法&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        result = []<br>        <span class="hljs-keyword">if</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-comment"># 引入队列</span><br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>        que = deque([root])<br>        <br>        <span class="hljs-keyword">while</span> que:<br>            levelRes = []<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(que)):<br>                node = que.popleft()<br>                levelRes.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    que.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    que.append(node.right)<br>            res.append(levelRes)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/75557421">python 在LeetCode中常用的数据结构 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战Ⅱ（二）| 实现markdown实时渲染的三种方法</title>
      <link href="/augu1sto/229fc5f4c8a3/"/>
      <url>/augu1sto/229fc5f4c8a3/</url>
      
        <content type="html"><![CDATA[<p>项目中采用marked.js用来实现对textarea区域的markdown文本进行实时渲染。具体的实现细节以后有空更。下面总结一下，我看到的多种可以用来进行实时渲染的方案。主要途径就是electron(调用webAPI)或者vue的一些功能。</p><h2 id="通过webapi使用addeventlistener-api">通过webAPI使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener">addEventListener() API</a><a class="header-anchor" href="#通过webapi使用addeventlistener-api">⁍</a></h2><p>之前说过，electron是结合了node.js和chromium，这意味着它可以处理DOM对象</p><p>因此，我们可以获取到相应的对象<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> markdownView = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#markdown&#x27;</span>);<br></code></pre></td></tr></table></figure><p>通过调用<code>addEventListener()</code>，检测<code>keyup</code>事件，即监听输入区域内是否有按完键盘的事情发生，来达到实时渲染的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">markdownView.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> currentContent = event.target.value;<br>  renderMarkdownToHtml(currentContent);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="vue-表单输入绑定">vue: 表单输入绑定<a class="header-anchor" href="#vue-表单输入绑定">⁍</a></h2><p>可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><blockquote><p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p></blockquote><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;textarea :value=&quot;input&quot; @input=&quot;update&quot;&gt;&lt;/textarea&gt;<br></code></pre></td></tr></table></figure><p>定义<code>update</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">methods: &#123;<br>  update (e) &#123;<br>    <span class="hljs-built_in">this</span>.input = e.target.value<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vue：监听内容变化">vue：监听内容变化<a class="header-anchor" href="#vue：监听内容变化">⁍</a></h2><p>有时也需要一个自定义的侦听器。Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>代码参考<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;notebook&#x27;</span>,<br>  <span class="hljs-comment">// CSS selector of the root DOM element</span><br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#notebook&#x27;</span>,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">content</span>: <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;content&#x27;</span>) || <span class="hljs-string">&#x27;You can write in **markdown**&#x27;</span>,<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//全写：notePreview: function () &#123;</span><br>    notePreview () &#123;<br>      <span class="hljs-comment">// Markdown rendered to HTML</span><br>      <span class="hljs-keyword">return</span> marked(<span class="hljs-built_in">this</span>.content)<br>    &#125;,<br>  &#125;,<br> <br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">content</span>: &#123;<span class="hljs-comment">//content一变就执行handler</span><br>      <span class="hljs-attr">handler</span>: <span class="hljs-string">&#x27;saveNote&#x27;</span>,<br>      <span class="hljs-comment">// immediate: true,</span><br>      <span class="hljs-comment">// deep:true,</span><br>    &#125;,<br>  &#125;,<br><br>  <span class="hljs-attr">methods</span>: &#123;<br>    saveNote (val, oldVal) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;new note:&#x27;</span>, val, <span class="hljs-string">&#x27;old note:&#x27;</span>, oldVal)<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;saving note:&#x27;</span>, <span class="hljs-built_in">this</span>.content)<br>      <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-built_in">this</span>.content)<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>《Electron跨平台开发实战》 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://cn.vuejs.org/v2/guide/forms.html">表单输入绑定 — Vue.js (vuejs.org)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8">计算属性和侦听器 — Vue.js (vuejs.org)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://blog.csdn.net/weixin_43342290/article/details/115324109">VUE实现一个Markdown笔记本_hhhh-CSDN博客_vue 开发markdown</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> electron </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战Ⅱ（一） | PicGo代码结构分析与代码重构</title>
      <link href="/augu1sto/a4de88a9fc0e/"/>
      <url>/augu1sto/a4de88a9fc0e/</url>
      
        <content type="html"><![CDATA[<h2 id="picgo代码结构分析">PicGo代码结构分析<a class="header-anchor" href="#picgo代码结构分析">⁍</a></h2><h3 id="main进程">main进程<a class="header-anchor" href="#main进程">⁍</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">├─apis<br>│  ├─app 【Provide key API interfaces for PicGo application, including uploader, window management, shortcut key system, remotes handler, etc】<br>│  │  ├─shortKey 快捷键相关<br>│  │  ├─system 封装createMenu/createContextMenu/createTray等内容（⭐主入口）<br>│  │  ├─uploader 上传图片的相关内容<br>│  │  └─window <br>│  │     ├─contants.ts 一些常量，存放window的地址（根据是否是开发环境选择）<br>│  │     ├─windowList.ts 用Map来声明window列表<br>│  │     └─windowManager.ts 管理window列表<br>│  ├─core 【The lowest level APIs that are not dependent on each other. The upper APIs depend on them.】<br>│  │  ├─bus<br>│  │  ├─datastore 数据库路径相关配置<br>│  │  ├─picgo 获取picgo整体的配置及日志<br>│  │  └─utils 日志<br>│  └─gui 【GuiApi for PicGo plugins.】<br>├─events<br>│  ├─remotes<br>│  │  └─menu.ts<br>│  ├─busEventLists.ts<br>│  ├─ipcList.ts ipc事件管理<br>│  └─picgoCoreIPC.ts<br>├─lifeCycle 一些错误处理？<br>├─migrate<br>├─server 处理一些httpServer相关内容，router等<br>└─utils<br></code></pre></td></tr></table></figure><h3 id="renderer进程">renderer进程<a class="header-anchor" href="#renderer进程">⁍</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">├─assets<br>│  └─fonts<br>├─components 页面部件（子页面？）<br>├─layouts 主要框架<br>├─pages<br>│  └─picbeds 页面<br>├─router 路由<br>├─store 框架自带<br>│  └─modules<br>└─utils<br></code></pre></td></tr></table></figure><p>另外还有一个universal的文件加存放一些全局通用的常量和接口</p><h2 id="项目代码重构">项目代码重构<a class="header-anchor" href="#项目代码重构">⁍</a></h2><p>考虑到短期内的功能和目前的需求，主要将窗口和事件监听等主要功能先拆分出来</p><p>目前重构后的代码结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">├─main<br>│  ├─core 核心功能<br>│  ├─events 事件监听<br>│  ├─store 配置存储<br>│  └─window 窗口管理<br>└─renderer<br>    ├─assets<br>    ├─components 主要页面<br>    │  └─Entry<br>    ├─router 路由<br>    └─store<br>        └─modules<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron-vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm和yarn命令对照</title>
      <link href="/augu1sto/cbb2ba50fc66/"/>
      <url>/augu1sto/cbb2ba50fc66/</url>
      
        <content type="html"><![CDATA[<p><strong>Install dependencies</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install =&gt; yarn <br></code></pre></td></tr></table></figure><p><strong>Install a package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install [package_name] =&gt; yarn add [package_name]<br></code></pre></td></tr></table></figure><p><strong>Install a package globally</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install -g [package_name] =&gt; yarn global add [package_name]<br></code></pre></td></tr></table></figure><p><strong>Install a package as a development dependency</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install --save-dev [package_name] =&gt; yarn add --dev [package_name]<br></code></pre></td></tr></table></figure><p><strong>Uninstall a package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm uninstall [package_name] =&gt; yarn remove [package_name]<br></code></pre></td></tr></table></figure><p><strong>Uninstall a package globally</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm uninstall -g [package_name] =&gt; yarn global remove [package_name]<br></code></pre></td></tr></table></figure><p><strong>Uninstall a development dependency package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm uninstall --save-dev [package_name] =&gt; yarn remove [package_name]<br></code></pre></td></tr></table></figure><p><strong>Update the dependencies</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm update =&gt; yarn upgrade <br></code></pre></td></tr></table></figure><p><strong>Update a package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm update [package_name] =&gt; yarn upgrade [package_name]<br></code></pre></td></tr></table></figure><p><strong>Create a new package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm init =&gt; yarn init<br></code></pre></td></tr></table></figure><p><strong>Run a script defined in the package.json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm run =&gt; yarn run<br></code></pre></td></tr></table></figure><p><strong>Test a package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm test =&gt; yarn test<br></code></pre></td></tr></table></figure><p><strong>Publish a package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm publish =&gt; yarn publish<br></code></pre></td></tr></table></figure><p><strong>Remove all data from the cache</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm cache clean =&gt; yarn cache clean<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试 | Java并发编程</title>
      <link href="/augu1sto/497c016db9bd/"/>
      <url>/augu1sto/497c016db9bd/</url>
      
        <content type="html"><![CDATA[<h2 id="线程和进程">线程和进程<a class="header-anchor" href="#线程和进程">⁍</a></h2><p>进程是程序的一次执行过程，是系统运行程序的基本单位.</p><p>线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程</p><p>启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>线程共享进程的堆和方法区（JDK 1.8 之后的元空间），同时维护自己的程序计数器、虚拟机栈和本地方法栈</p><h2 id="线程的生命周期和状态">线程的生命周期和状态<a class="header-anchor" href="#线程的生命周期和状态">⁍</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> MyThread();<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 方法三 lamda表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>        &#125;);<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java 线程的状态 "></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203110929444.png" alt="image-20220311092948997"></p><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="什么是上下文切换">什么是上下文切换?<a class="header-anchor" href="#什么是上下文切换">⁍</a></h2><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的 <strong>程序计数器，栈信息</strong> 等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|单调栈</title>
      <link href="/augu1sto/44694074b950/"/>
      <url>/augu1sto/44694074b950/</url>
      
        <content type="html"><![CDATA[<p>要寻找任一个元素的 <strong>右边或者左边第一个比自己大或者小的元素的位置</strong> ，此时我们就要想到可以用单调栈了。</p><p>时间复杂度 $O(n)$</p><ul><li><p>单调栈里存放的是下标 $i$</p></li><li><p>以右边第一个比自己大的元素为例，需要维护一个从 栈顶到栈底 递增 的栈</p></li><li><p>使用单调栈主要有三个判断条件（以右边第一个比自己大的元素为例）</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况<ul><li>i入栈</li></ul></li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况<ul><li>i入栈， <strong>因为是大于，不用记录</strong></li></ul></li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况<ul><li>弹出栈顶元素st.top()，i压栈，记录 res[st.top]与i的关系</li></ul></li></ul><h2 id="739-每日温度"><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a><a class="header-anchor" href="#739-每日温度">⁍</a></h2></li></ul><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指在第 <code>i</code> 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: temperatures = [30,40,50,60]<br>输出: [1,1,1,0]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><p>找右边第一个比temp[i]大的元素的坐标j</p><p>ans[i] = j-i</p><p>维护栈顶到栈底递增单调栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[temperatures.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                stack.push(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> temp = temperatures[i];<br>                <span class="hljs-keyword">int</span> top = stack.peek();<br>                <span class="hljs-comment">// 不断和栈顶元素比较，直到不比栈顶元素大</span><br>                <span class="hljs-keyword">while</span> (temp &gt; temperatures[top]) &#123;<br>                    top = stack.pop();<br>                    ans[top] = i-top;<br>                    <span class="hljs-comment">// 如果栈空，也跳出循环</span><br>                    <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    top = stack.peek();<br>                &#125;<br>                stack.push(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考，中间的循环更简单的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[temperatures.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 取出下标进行元素值的比较</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br>            <span class="hljs-keyword">int</span> preIndex = stack.pop();<br>            res[preIndex] = i - preIndex;<br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 注意 放入的是元素位置</span><br><span class="hljs-comment">         */</span><br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="496-下一个更大的元素i"><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大的元素i</a><a class="header-anchor" href="#496-下一个更大的元素i">⁍</a></h2><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br>- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。<br>- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums1 = [2,4], nums2 = [1,2,3,4].<br>输出：[3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。<br>- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p>**进阶：**你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p><blockquote><p><strong>思路</strong></p></blockquote><p>先遍历nums2，找到每个值对应的下一个元素，并用哈希表记录</p><p>再遍历nums2，按顺序将每个值的下一个元素添加到结果中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElement(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 记录nums2中的元素x的下一个更大元素</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length];<br><br>        <span class="hljs-comment">// 先遍历nums2，找到每个元素的下一个更大元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i]&gt;nums2[stack.peek()]) &#123;<br>                <span class="hljs-keyword">int</span> top = stack.pop();<br>                map.put(nums2[top],nums2[i]);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> n = map.getOrDefault(nums1[i],-<span class="hljs-number">1</span>); <span class="hljs-comment">// 不存在则置-1</span><br>            res[i] = n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="503-下一个更大元素ii"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503.下一个更大元素II</a><a class="header-anchor" href="#503-下一个更大元素ii">⁍</a></h2><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数； <br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [1,2,3,4,3]<br>输出: [2,3,4,-1,4]<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-109 &lt;= nums[i] &lt;= 10^9</code></li></ul><blockquote><p><strong>思路：</strong></p></blockquote><p>最多循环一轮，所以循环到2n结束，算坐标的时候mod n</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElements(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(res,-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*n; i++) &#123; <span class="hljs-comment">// 设为2*n即可</span><br>            <span class="hljs-keyword">int</span> j = i%n;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()&amp;&amp;nums[j]&gt; nums[stack.peek()])&#123;<br>                <span class="hljs-keyword">int</span> top = stack.pop();<br>                res[top] = nums[j];<br>            &#125;<br>            stack.push(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试 | Java部分知识点-基础</title>
      <link href="/augu1sto/9543bf68a7d1/"/>
      <url>/augu1sto/9543bf68a7d1/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p>JavaGuide<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、《Java核心计数及面试指南》<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h2 id="静态变量和实例变量的区别">静态变量和实例变量的区别<a class="header-anchor" href="#静态变量和实例变量的区别">⁍</a></h2><p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。</p><p>==&gt; 无论修改哪个实例的静态字段，所有实例的静态字段都被修改了，原因是静态字段并不属于实例<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><h2 id="静态方法和实例方法区别">静态方法和实例方法区别<a class="header-anchor" href="#静态方法和实例方法区别">⁍</a></h2><ol><li><p>调用方式</p><p><strong>调用静态方法可以无需创建对象</strong></p><ul><li>静态方法： <code>类名.方法名</code>/<code>对象.方法名</code>(不建议)</li><li>实例方法： <code>对象.方法名</code></li></ul></li><li><p>访问类成员是否存在限制</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法）</p><p>实例方法不存在这个限制。</p></li></ol><h2 id="静态方法为什么不能调用非静态成员">静态方法为什么不能调用非静态成员<a class="header-anchor" href="#静态方法为什么不能调用非静态成员">⁍</a></h2><ol><li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而</p><p>非静态成员属于实例对象， <strong>只有在对象实例化之后才存在，</strong> 需要通过类的实例对象去访问。</p></li><li><p>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在 <strong>内存中还不存在</strong> 的非静态成员，属于非法操作</p></li></ol><h2 id="重载-overload-和覆盖-重写-override-的差别">重载(overload)和覆盖/重写(override)的差别<a class="header-anchor" href="#重载-overload-和覆盖-重写-override-的差别">⁍</a></h2><p>重载是多态的一种体现，表现形式是方法同名但参数不同，而覆盖是子类方法覆盖掉父类方法</p><table><thead><tr><th style="text-align:left">区别点</th><th style="text-align:left">重载方法</th><th style="text-align:left">重写方法</th></tr></thead><tbody><tr><td style="text-align:left">发生范围</td><td style="text-align:left">同一个类</td><td style="text-align:left">子类</td></tr><tr><td style="text-align:left">参数列表</td><td style="text-align:left">必须修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">返回类型</td><td style="text-align:left">可修改</td><td style="text-align:left">子类方法返回值类型应比父类方法返回值类型 <strong>更小或相等</strong></td></tr><tr><td style="text-align:left">异常</td><td style="text-align:left">可修改</td><td style="text-align:left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类 <strong>更小或相等；</strong></td></tr><tr><td style="text-align:left">访问修饰符</td><td style="text-align:left">可修改</td><td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td style="text-align:left">发生阶段</td><td style="text-align:left">编译期</td><td style="text-align:left">运行期</td></tr></tbody></table><h2 id="请说出作用域public，private，protected，以及不写时的区别。">请说出作用域public，private，protected，以及不写时的区别。<a class="header-anchor" href="#请说出作用域public，private，protected，以及不写时的区别。">⁍</a></h2><p>不写就是default（默认）：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203101443294.png" alt="image-20220310144341946"></p><h2 id="jvm、jdk和jre">JVM、JDK和JRE<a class="header-anchor" href="#jvm、jdk和jre">⁍</a></h2><ul><li><strong>JVM：</strong> Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言 <strong>“一次编译，随处可以运行”</strong> 的关键所在。</li><li><strong>JDK：</strong> Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</li><li><strong>JRE：</strong>  Java 运行时环境。它是 <strong>运行</strong> <mark>已编译</mark> Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是， <strong>它不能用于创建新程序。</strong>**</li></ul><h2 id="什么是字节码-采用字节码的好处是什么">什么是字节码?采用字节码的好处是什么?<a class="header-anchor" href="#什么是字节码-采用字节码的好处是什么">⁍</a></h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机（ <strong>跨平台、解释性、可移植</strong> ）。</p><p><img src="https://javaguide.cn/assets/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.a75e6fc0.png" alt="Java程序转变为机器代码的过程"></p><ul><li><strong>Java 是编译与解释共存的语言</strong></li><li>编译为 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li><li>引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</li></ul><h3 id="为什么说-java-语言“编译与解释并存”？">为什么说 Java 语言“编译与解释并存”？<a class="header-anchor" href="#为什么说-java-语言“编译与解释并存”？">⁍</a></h3><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。</p><ul><li><strong>编译型</strong> ：一次性编译完毕。执行速度较快，开发效率较低。</li><li><strong>解释型</strong> ：将代码逐句解释（interpret）为机器代码后再执行。执行速度较慢，开发效率较高。（python\js\php等）</li></ul><p>因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行</p><h2 id="java和c-区别">Java和C++区别<a class="header-anchor" href="#java和c-区别">⁍</a></h2><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>…</li></ul><h2 id="final">final<a class="header-anchor" href="#final">⁍</a></h2><ul><li><p>final修饰的方法可以阻止被覆写；</p><p>final修饰的class可以阻止被继承；</p><p>final修饰的field必须在创建对象时初始化，随后不可修改。</p></li></ul><h2 id="抽象类和接口">抽象类和接口<a class="header-anchor" href="#抽象类和接口">⁍</a></h2><p>抽象类和接口的对比如下：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">abstract class</th><th style="text-align:left">interface</th></tr></thead><tbody><tr><td style="text-align:left">理解</td><td style="text-align:left">对概念逻辑的抽象</td><td style="text-align:left">对功能的抽象</td></tr><tr><td style="text-align:left">继承</td><td style="text-align:left">只能extends一个class</td><td style="text-align:left">可以implements多个interface</td></tr><tr><td style="text-align:left">字段</td><td style="text-align:left">可以定义实例字段</td><td style="text-align:left">不能定义实例字段</td></tr><tr><td style="text-align:left">抽象方法</td><td style="text-align:left">可以定义抽象方法</td><td style="text-align:left">可以定义抽象方法</td></tr><tr><td style="text-align:left">非抽象方法</td><td style="text-align:left">可以定义非抽象方法</td><td style="text-align:left">可以定义default方法</td></tr></tbody></table><p><strong>共同点</strong> ：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键在接口中定义默认方法，抽象类的实现方法？）。</li></ul><p><strong>区别</strong> ：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋</li></ul><h2 id="hashcode-与-equals">hashCode() 与 equals()<a class="header-anchor" href="#hashcode-与-equals">⁍</a></h2><blockquote><p>当你把对象加入 <code>HashSet</code> 时，</p><ul><li><code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。</li><li>但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</li></ul></blockquote><ol><li><code>hashCode()</code>方法要严格遵循以下规范：<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></li></ol><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul><p>换而言之：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><ol start="2"><li>编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是</li></ol><ul><li><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；</li><li><code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</li></ul><h2 id="可变长参数">可变长参数<a class="header-anchor" href="#可变长参数">⁍</a></h2><p>方法重载时是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p><h2 id="包装类型的常量池技术">包装类型的常量池技术<a class="header-anchor" href="#包装类型的常量池技术">⁍</a></h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h2 id="创建一个对象用什么运算符-对象实体与对象引用有何不同">创建一个对象用什么运算符?对象实体与对象引用有何不同?<a class="header-anchor" href="#创建一个对象用什么运算符-对象实体与对象引用有何不同">⁍</a></h2><p>new 运算符，new 创建对象实例。</p><ul><li>对象实例在堆内存中</li><li>对象引用指向对象实例，对象引用存放在栈内存中。</li></ul><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h2 id="面向对象的三大特征">面向对象的三大特征<a class="header-anchor" href="#面向对象的三大特征">⁍</a></h2><ul><li><strong>封装：</strong> 例如java bean 不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li><li><strong>继承：</strong> 通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</li><li><strong>多态：</strong></li><li>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。<ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul></li></ul><h2 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？<a class="header-anchor" href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？">⁍</a></h2><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong> ：简单来说，引用拷贝就是两个不同的引用指向同一个对象。</li></ul><p><img src="https://javaguide.cn/assets/shallow&amp;deep-copy.08611c43.png" alt="img"></p><h2 id="java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？">Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？<a class="header-anchor" href="#java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？">⁍</a></h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ul><h2 id="反射">反射<a class="header-anchor" href="#反射">⁍</a></h2><p>通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h3 id="反射机制优缺点">反射机制优缺点<a class="header-anchor" href="#反射机制优缺点">⁍</a></h3><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li></ul><h3 id="反射的应用场景">反射的应用场景<a class="header-anchor" href="#反射的应用场景">⁍</a></h3><p>注解</p><h2 id="exception-和-error-有什么区别？">Exception 和 Error 有什么区别？<a class="header-anchor" href="#exception-和-error-有什么区别？">⁍</a></h2><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">                     ┌───────────┐<br>                     │  Object   │<br>                     └───────────┘<br>                           ▲<br>                           │<br>                     ┌───────────┐<br>                     │ Throwable │<br>                     └───────────┘<br>                           ▲<br>                 ┌─────────┴─────────┐<br>                 │                   │<br>           ┌───────────┐       ┌───────────┐<br>           │   Error   │       │ Exception │<br>           └───────────┘       └───────────┘<br>                 ▲                   ▲<br>         ┌───────┘              ┌────┴──────────┐<br>         │                      │               │<br>┌─────────────────┐    ┌─────────────────┐┌───────────┐<br>│OutOfMemoryError │... │RuntimeException ││IOException│...<br>└─────────────────┘    └─────────────────┘└───────────┘<br>                                ▲<br>                    ┌───────────┴─────────────┐<br>                    │                         │<br>         ┌─────────────────────┐ ┌─────────────────────────┐<br>         │NullPointerException │ │IllegalArgumentException │...<br>         └─────────────────────┘ └─────────────────────────┘<br></code></pre></td></tr></table></figure><h3 id="checked-exception-和-unchecked-exception-有什么区别？">Checked Exception 和 Unchecked Exception 有什么区别？<a class="header-anchor" href="#checked-exception-和-unchecked-exception-有什么区别？">⁍</a></h3><ul><li><p><strong>Checked Exception</strong> 即受检查异常，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。</p></li><li><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p></li></ul><p><code>RuntimeException</code> 及其子类都统称为非受检查异常</p><h2 id="什么是序列化-什么是反序列化">什么是序列化?什么是反序列化?<a class="header-anchor" href="#什么是序列化-什么是反序列化">⁍</a></h2><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)</p><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰</p><h2 id="java-中-io-流分为几种">Java 中 IO 流分为几种?<a class="header-anchor" href="#java-中-io-流分为几种">⁍</a></h2><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流(音频文件、图片等媒体文件)和字符流(字符，涉及到编码)；</li><li>按照流的角色划分为节点流和处理流。</li></ul><h2 id="java只有值传递">Java只有值传递<a class="header-anchor" href="#java只有值传递">⁍</a></h2><p><a href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java.html">为什么 Java 中只有值传递？ | JavaGuide</a></p><h2 id="bigdecimal解决浮点数运算精度丢失问题">BigDecimal解决浮点数运算精度丢失问题<a class="header-anchor" href="#bigdecimal解决浮点数运算精度丢失问题">⁍</a></h2><p>为了避免精度丢失，可以使用 <code>BigDecimal</code> 来进行浮点数的运算</p><p><a href="https://javaguide.cn/java/basis/bigdecimal.html#bigdecimal-%E4%BB%8B%E7%BB%8D">BigDecimal解决浮点数运算精度丢失问题 | JavaGuide</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://javaguide.cn/">主页 | JavaGuide</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.cnblogs.com/JavaArchitect/tag/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/">Java核心技术及面试指南 - 标签 - hsm_computer - 博客园 (cnblogs.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://augu1sto.gitee.io/3043589ab29c/#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">9. 静态字段和静态方法 (gitee.io)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://augu1sto.gitee.io/e49df870bd32/#%E7%BC%96%E5%86%99equals%E5%92%8Chashcode">5. 编写equals和hashCode (gitee.io)</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（十六）| 函数式编程（Lambda计算）</title>
      <link href="/augu1sto/7fc9024cd2c5/"/>
      <url>/augu1sto/7fc9024cd2c5/</url>
      
        <content type="html"><![CDATA[<p>函数式编程(Functional Programming)就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数 <strong>没有变量</strong> ，因此，任意一个函数， <strong>只要输入是确定的，输出就是确定的</strong>， 这种纯函数我们称之为 <strong>没有副作用</strong> 。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><p>函数式编程的一个特点就是， <strong>允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</strong></p><p>常把函数式编程称为Lambda计算</p><h2 id="lambda基础">Lambda基础<a class="header-anchor" href="#lambda基础">⁍</a></h2><h3 id="functionalinterface">FunctionalInterface<a class="header-anchor" href="#functionalinterface">⁍</a></h3><p>我们把只定义了单方法的接口称之为<code>FunctionalInterface</code>，用注解<code>@FunctionalInterface</code>标记。</p><ul><li>Comparator</li><li>Runnable</li><li>Callable</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（十五）| XML与JSON | JDBC</title>
      <link href="/augu1sto/68c8fc57c8ac/"/>
      <url>/augu1sto/68c8fc57c8ac/</url>
      
        <content type="html"><![CDATA[<h2 id="xml与json">XML与JSON<a class="header-anchor" href="#xml与json">⁍</a></h2><h3 id="xml（extensible-markup-language）">XML（eXtensible Markup Language）<a class="header-anchor" href="#xml（extensible-markup-language）">⁍</a></h3><ul><li><p>可扩展标记语言，常通过网络作为消息传输</p></li><li><p>特点</p><ul><li>纯文本，默认使用UTF-8编码</li><li>可嵌套，适合表示结构化数据</li></ul></li><li><p>结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">note</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;book.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Java核心技术<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Cay S. Horstmann<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">isbn</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;CN&quot;</span>&gt;</span>1234567<span class="hljs-tag">&lt;/<span class="hljs-name">isbn</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tags</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>Network<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tags</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pubDate</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>第一行固定</li><li>第二行声明的是文档定义类型，如（DTD：Document Type Definition），可选。可以指定一系列规则，来验证XML的数据结构，例如：<ul><li>根元素必须是<code>book</code></li><li><code>book</code>元素必须包含<code>name</code>，<code>author</code>等指定元素</li><li><code>isbn</code>元素必须包含属性<code>lang</code></li><li>…</li></ul></li><li>后面是文件内容，特殊符号需转义</li></ul></li><li><p>和结构类似的HTML不同，浏览器对HTML有一定的“容错性”，缺少关闭标签也可以被解析，但 <strong>XML要求严格的格式，任何没有正确嵌套的标签都会导致错误。</strong></p></li><li><p>除了我们经常用到的XML文档本身外，XML还支持：</p><ul><li>DTD和XSD：验证XML结构和数据是否有效；</li><li>Namespace：XML节点和属性的名字空间；</li><li>XSLT：把XML转化为另一种文本；</li><li>XPath：一种XML节点查询语言；</li></ul></li></ul><h3 id="解析xml-dom">解析XML:DOM<a class="header-anchor" href="#解析xml-dom">⁍</a></h3><p>XML是一种树形结构的文档，它有两种标准的解析API：</p><ul><li>DOM：一次性读取XML，并在内存中表示为树形结构；</li><li>SAX：以流的形式读取XML，使用事件回调。</li></ul><p>DOM是Document Object Model的缩写，DOM模型就是把XML结构作为一个 <strong>树形结构</strong> 处理，从根节点开始，每个节点都可以包含任意个子节点。</p><p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p><ul><li><code>Document</code>：代表整个XML文档；</li><li><code>Element</code>：代表一个XML元素；</li><li><code>Attribute</code>：代表一个元素的某个属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream input = Main.class.getResourceAsStream(<span class="hljs-string">&quot;/book.xml&quot;</span>);<br>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();<br>DocumentBuilder db = dbf.newDocumentBuilder(); <br>Document doc = db.parse(input); <span class="hljs-comment">// 用于解析一个XML，它可以接收InputStream，File或者URL</span><br><span class="hljs-comment">// 返回Document对象，这个对象代表了整个XML文档的树形结构</span><br></code></pre></td></tr></table></figure><p>可以遍历结点获取指定元素值<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>DOM解析速度慢，内存占用大。</p><h3 id="解析xml-sax">解析XML:SAX<a class="header-anchor" href="#解析xml-sax">⁍</a></h3><p>SAX是Simple API for XML的缩写，它是一种基于流的解析方式， <strong>边读取XML边解析</strong> ，并以 <strong>事件回调</strong> 的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p><p>SAX解析会触发一系列事件：</p><ul><li>startDocument：开始读取XML文档；</li><li>startElement：读取到了一个元素，例如<code>&lt;book&gt;</code>；</li><li>characters：读取到了字符；</li><li>endElement：读取到了一个结束的元素，例如<code>&lt;/book&gt;</code>；</li><li>endDocument：读取XML文档结束。</li></ul><p>用SAX API解析XML</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream input = Main.class.getResourceAsStream(<span class="hljs-string">&quot;/book.xml&quot;</span>);<br>SAXParserFactory spf = SAXParserFactory.newInstance();<br>SAXParser saxParser = spf.newSAXParser();<br>saxParser.parse(input, <span class="hljs-keyword">new</span> MyHandler()); <span class="hljs-comment">// 回调对象MuHandler,继承自DefaultHandler</span><br></code></pre></td></tr></table></figure><p>调用方必须通过回调方法获得解析过程中的数据。</p><h3 id="解析xml-jackson">解析XML:Jackson<a class="header-anchor" href="#解析xml-jackson">⁍</a></h3><p>把XML文档解析成一个JavaBean<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h3 id="json">json<a class="header-anchor" href="#json">⁍</a></h3><p>XML的特点是功能全面，但标签繁琐，格式复杂。</p><p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。</p><p>优点：</p><ul><li>JSON只允许使用UTF-8编码，不存在编码问题；</li><li>JSON只允许使用双引号作为key，特殊字符用<code>\</code>转义，格式简单；</li><li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li></ul><p>因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p><ul><li>键值对：<code>&#123;&quot;key&quot;: value&#125;</code></li><li>数组：<code>[1, 2, 3]</code></li><li>字符串：<code>&quot;abc&quot;</code></li><li>数值（整数和浮点数）：<code>12.34</code></li><li>布尔值：<code>true</code>或<code>false</code></li><li>空值：<code>null</code></li></ul><p>绝大多数REST API都选择JSON作为数据传输格式。</p><h4 id="使用jackson解析json">使用jackson解析JSON<a class="header-anchor" href="#使用jackson解析json">⁍</a></h4><p>引入以下Maven依赖：</p><ul><li>com.fasterxml.jackson.core:jackson-databind:2.12.0</li></ul><p>把JSON解析为JavaBean的过程称为 <strong>反序列化</strong> 。如果把JavaBean变为JSON，那就是 <strong>序列化</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream input = Main.class.getResourceAsStream(<span class="hljs-string">&quot;/book.json&quot;</span>);<br>ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br><span class="hljs-comment">// 反序列化时忽略不存在的JavaBean属性:</span><br>mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="hljs-keyword">false</span>);<br>Book book = mapper.readValue(input, Book.class);<br><span class="hljs-comment">// 序列化</span><br>String json = mapper.writeValueAsString(book);<br></code></pre></td></tr></table></figure><p>可以通过Module扩展Jackson能处理的数据类型；</p><p>可以自定义<code>JsonSerializer</code>和<code>JsonDeserializer</code>来定制序列化和反序列化。</p><h2 id="jdbc编程">JDBC编程<a class="header-anchor" href="#jdbc编程">⁍</a></h2><p>Java为 <strong>关系数据库</strong> 定义了一套标准的访问接口：JDBC（Java Database Connectivity）</p><p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p><p>通过JDBC接口来访问，这样保证了Java程序编写的是一套数据库访问代码，却可以访问各种不同的数据库，因为他们都提供了标准的JDBC驱动：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203082341700.png" alt="image-20220308234109650"></p><p>SQL (Structured Query Language) 是具有数据操纵和数据定义等多种功能的数据库语言，这种语言具有交互性特点<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>NoSQL: 非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><blockquote><p>NoSQL框架体系NosoL整体框架分为四层，由下至上分为:<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p><ul><li><strong>数据持久层(data persistence):</strong> 定义了数据的存储形式，主要包括基于内存、基于硬盘、内存和硬盘接口、订制可拔插四种形</li><li><strong>整体分布层(data distribution model):</strong> 定义了数据是如何分布<ul><li>CAP支持: 可用于水平扩展</li><li>多数据中心支持: 可以保证在横跨多数据中心是也能够平稳运行</li><li>动态部署支持: 可以在运行着的集群中动态地添加或删除节点</li></ul></li><li><strong>数据逻辑模型层(data logical model):</strong> 键值模型、列式模型、文档模型、图模型</li><li><strong>接口层(interface):</strong> Rest，Thrift，Map/Reduce，Get/Put，特定语言API</li></ul></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1320414976409634">使用DOM - 廖雪峰的官方网站 (liaoxuefeng.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1320418596093986">使用Jackson - 廖雪峰的官方网站 (liaoxuefeng.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://baike.baidu.com/item/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/2081086">SQL数据库_百度百科 (baidu.com)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">SQL教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://baike.baidu.com/item/NoSQL/8828247">NoSQL_百度百科 (baidu.com)</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（十四）| Maven基础</title>
      <link href="/augu1sto/6882e3c69cbc/"/>
      <url>/augu1sto/6882e3c69cbc/</url>
      
        <content type="html"><![CDATA[<p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p><ul><li><p>Maven使用<code>pom.xml</code>定义项目内容，并使用预设的目录结构；（和package.json）</p></li><li><p>在Maven中声明一个依赖项可以自动下载并导入classpath；</p></li><li><p>Maven使用<code>groupId</code>，<code>artifactId</code>和<code>version</code>唯一定位一个依赖。</p></li><li><p>Maven通过解析依赖关系确定项目所需的jar包，常用的4种<code>scope</code>有：<code>compile</code>（默认），<code>test</code>，<code>runtime</code>和<code>provided</code>；</p><p>Maven从中央仓库下载所需的jar包并缓存在本地；</p><p>可以通过镜像仓库加速下载。</p></li></ul><h3 id="构建流程——生命周期">构建流程——生命周期<a class="header-anchor" href="#构建流程——生命周期">⁍</a></h3><p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p><p>最常用的构建命令是指定phase，然后让Maven执行到指定的phase：（如下面的<code>clean</code>、<code>compile</code>、<code>test</code>、<code>package</code>）</p><ul><li>mvn clean</li><li>mvn clean compile</li><li>mvn clean test</li><li>mvn clean package</li></ul><p>通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。</p><h2 id="使用插件">使用插件<a class="header-anchor" href="#使用插件">⁍</a></h2><p>执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个goal来完成编译。</p><p>Maven已经内置了一些常用的标准插件：</p><table><thead><tr><th style="text-align:left">插件名称</th><th style="text-align:left">对应执行的phase</th></tr></thead><tbody><tr><td style="text-align:left">clean</td><td style="text-align:left">clean</td></tr><tr><td style="text-align:left">compiler</td><td style="text-align:left">compile</td></tr><tr><td style="text-align:left">surefire</td><td style="text-align:left">test</td></tr><tr><td style="text-align:left">jar</td><td style="text-align:left">package</td></tr></tbody></table><p>使用自定义插件必须在pom.xml中声明插件及配置</p><h2 id="模块管理">模块管理<a class="header-anchor" href="#模块管理">⁍</a></h2><p>把每个模块当作一个独立的Maven项目，它们有各自独立的<code>pom.xml</code>。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>可以提取出共同部分作为<code>parent</code>，parent的<code>&lt;packaging&gt;</code>是<code>pom</code>而不是<code>jar</code>，因为<code>parent</code>本身不含任何Java代码。各个模块都可以直接从<code>parent</code>继承。</p><p>如果两个模块之间有依赖关系，需要从其中一个里引入另一个。</p><p>最后，在编译的时候，需要在根目录创建一个<code>pom.xml</code>统一编译，通过<code>&lt;modules&gt;</code>编译多个模块。</p><h3 id="中央仓库、本地仓库与私有仓库">中央仓库、本地仓库与私有仓库<a class="header-anchor" href="#中央仓库、本地仓库与私有仓库">⁍</a></h3><ul><li>中央仓库：上传到Maven里的</li><li>私有仓库：非公网上的，需要在本地的<code>~/.m2/settings.xml</code>中配置好</li><li>本地仓库：把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。容易出现版本不一致的情况。更好的方法是使用模块化编译。</li></ul><h2 id="mvnw">mvnw<a class="header-anchor" href="#mvnw">⁍</a></h2><p><code>mvnw</code>是Maven Wrapper的缩写。</p><p>对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。</p><p><mark>就是非全局的Maven版本</mark></p><h2 id="artifact">Artifact<a class="header-anchor" href="#artifact">⁍</a></h2><p>使用Maven发布一个Artifact时：<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><ul><li>可以发布到本地，然后推送到远程Git库，由静态服务器提供基于网页的repo服务，使用方必须声明repo地址；</li><li>可以发布到<a href="https://central.sonatype.org/">central.sonatype.org</a>，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置；</li><li>可以发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用。</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1309301243117601">模块管理 - 廖雪峰的官方网站 (liaoxuefeng.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1347981037010977">发布Artifact - 廖雪峰的官方网站 (liaoxuefeng.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试 | Java算法题输入输出</title>
      <link href="/augu1sto/d0ac43ade796/"/>
      <url>/augu1sto/d0ac43ade796/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，Leetcode上刷题都是核心代码模式，只需要写出solution类就可以了，不用管输入输出。但是许多笔试面试的时候，是需要写输入输出的（ACM模式）。这里简单记录一下可能会用到的输入输出模板。</p><h2 id="标准模板">标准模板<a class="header-anchor" href="#标准模板">⁍</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">// 整数</span><br>        <span class="hljs-keyword">int</span> n1 = in.nextInt();<br>        <span class="hljs-comment">// 浮点数</span><br>        <span class="hljs-keyword">double</span> n2 = in.nextDouble();<br>        <span class="hljs-comment">// 一行，不包含末尾分隔符</span><br>        String s = in.nextLine();<br>        <span class="hljs-comment">// 输出</span><br>        System.out.println(n1);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="scanner的next方法一览">Scanner的next方法一览<a class="header-anchor" href="#scanner的next方法一览">⁍</a></h3><p>参考<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><table><thead><tr><th style="text-align:left">变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>String</code></td><td><code>next()</code></td><td>从此扫描仪查找并返回下一个完整令牌。</td></tr><tr><td style="text-align:left"><code>String</code></td><td><code>next(String pattern)</code></td><td>如果它与从指定字符串构造的模式匹配，则返回下一个标记。</td></tr><tr><td style="text-align:left"><code>String</code></td><td><code>next(Pattern pattern)</code></td><td>如果匹配指定的模式，则返回下一个标记。</td></tr><tr><td style="text-align:left"><code>BigDecimal</code></td><td><code>nextBigDecimal()</code></td><td>将输入的下一个标记扫描为<a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigDecimal.html"><code>BigDecimal</code></a> 。</td></tr><tr><td style="text-align:left"><code>BigInteger</code></td><td><code>nextBigInteger()</code></td><td>将输入的下一个标记扫描为<a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html"><code>BigInteger</code></a> 。</td></tr><tr><td style="text-align:left"><code>BigInteger</code></td><td><code>nextBigInteger(int radix)</code></td><td>将输入的下一个标记扫描为<a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html"><code>BigInteger</code></a> 。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>nextBoolean()</code></td><td>将输入的下一个标记扫描为布尔值并返回该值。</td></tr><tr><td style="text-align:left"><code>byte</code></td><td><code>nextByte()</code></td><td>将输入的下一个标记扫描为 <code>byte</code> 。</td></tr><tr><td style="text-align:left"><code>byte</code></td><td><code>nextByte(int radix)</code></td><td>将输入的下一个标记扫描为 <code>byte</code> 。</td></tr><tr><td style="text-align:left"><code>double</code></td><td><code>nextDouble()</code></td><td>将输入的下一个标记扫描为 <code>double</code> 。</td></tr><tr><td style="text-align:left"><code>float</code></td><td><code>nextFloat()</code></td><td>将输入的下一个标记扫描为 <code>float</code> 。</td></tr><tr><td style="text-align:left"><code>int</code></td><td><code>nextInt()</code></td><td>将输入的下一个标记扫描为 <code>int</code> 。</td></tr><tr><td style="text-align:left"><code>int</code></td><td><code>nextInt(int radix)</code></td><td>将输入的下一个标记扫描为 <code>int</code> 。</td></tr><tr><td style="text-align:left"><code>String</code></td><td><code>nextLine()</code></td><td>使此扫描器前进超过当前行并返回跳过的输入。</td></tr><tr><td style="text-align:left"><code>long</code></td><td><code>nextLong()</code></td><td>将输入的下一个标记扫描为 <code>long</code> 。</td></tr><tr><td style="text-align:left"><code>long</code></td><td><code>nextLong(int radix)</code></td><td>将输入的下一个标记扫描为 <code>long</code> 。</td></tr><tr><td style="text-align:left"><code>short</code></td><td><code>nextShort()</code></td><td>将输入的下一个标记扫描为 <code>short</code> 。</td></tr><tr><td style="text-align:left"><code>short</code></td><td><code>nextShort(int radix)</code></td><td>将输入的下一个标记扫描为 <code>short</code> 。</td></tr></tbody></table><h2 id="eof">EOF<a class="header-anchor" href="#eof">⁍</a></h2><p>采用<code>hasNext</code>来判断有无下一个输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span> ;<br>        <span class="hljs-comment">//判断是否输入结束（系统文件输入）</span><br>        <span class="hljs-keyword">while</span>(sc.hasNext())&#123;<br>            <span class="hljs-comment">//获取输入值</span><br>            a=sc.nextInt();<br>            <span class="hljs-comment">//...</span><br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scanner的hasnext方法一览">Scanner的hasNext方法一览<a class="header-anchor" href="#scanner的hasnext方法一览">⁍</a></h3><table><thead><tr><th style="text-align:left">变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNext()</code></td><td>如果此扫描器的输入中有另一个标记，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNext(String pattern)</code></td><td>如果下一个标记与从指定字符串构造的模式匹配，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNext(Pattern pattern)</code></td><td>如果下一个完整标记与指定模式匹配，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextBigDecimal()</code></td><td>如果此扫描器输入中的下一个标记可以使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextBigDecimal()"><code>nextBigDecimal()</code></a>方法解释为 <code>BigDecimal</code>则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextBigInteger()</code></td><td>如果此扫描器输入中的下一个标记可以使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextBigInteger()"><code>nextBigInteger()</code></a>方法在默认基数中解释为 <code>BigInteger</code> ，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextBigInteger(int radix)</code></td><td>如果此扫描器输入中的下一个标记可以使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextBigInteger()"><code>nextBigInteger()</code></a>方法在指定的基数中解释为 <code>BigInteger</code> ，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextBoolean()</code></td><td>如果使用从字符串“true | false”创建的不区分大小写的模式，可以将此扫描器输入中的下一个标记解释为布尔值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextByte()</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextByte()"><code>nextByte()</code></a>方法将此扫描器输入中的下一个标记解释为默认基数中的字节值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextByte(int radix)</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextByte()"><code>nextByte()</code></a>方法将此扫描器输入中的下一个标记解释为指定基数中的字节值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextDouble()</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextDouble()"><code>nextDouble()</code></a>方法将此扫描仪输入中的下一个标记解释为double值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextFloat()</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextFloat()"><code>nextFloat()</code></a>方法将此扫描器输入中的下一个标记解释为浮点值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextInt()</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextInt()"><code>nextInt()</code></a>方法将此扫描器输入中的下一个标记解释为默认基数中的int值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextInt(int radix)</code></td><td>如果此扫描器输入中的下一个标记可以使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextInt()"><code>nextInt()</code></a>方法解释为指定基数中的int值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextLine()</code></td><td>如果此扫描器的输入中有另一行，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextLong()</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextLong()"><code>nextLong()</code></a>方法将此扫描器输入中的下一个标记解释为默认基数中的长值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextLong(int radix)</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextLong()"><code>nextLong()</code></a>方法可以将此扫描器输入中的下一个标记解释为指定基数中的长值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextShort()</code></td><td>如果使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextShort()"><code>nextShort()</code></a>方法可以将此扫描器输入中的下一个标记解释为默认基数中的短值，则返回true。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td><code>hasNextShort(int radix)</code></td><td>如果此扫描器输入中的下一个标记可以使用 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextShort()"><code>nextShort()</code></a>方法解释为指定基数中的短值，则返回true。</td></tr></tbody></table><h2 id="scanner分隔符">Scanner分隔符<a class="header-anchor" href="#scanner分隔符">⁍</a></h2><p>Scanner使用分隔符模式将其输入分解为标记，该分隔符模式默认匹配空格。 将得到的令牌可以然后被转换成使用各种不同类型的值next方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in).useDelimiter(<span class="hljs-string">&quot;\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>(可配合正则表达式使用)</p><p>以WOJ上的<a href="http://acm.whu.edu.cn/weblearn/problem/2">2. Genesis - WOJ (whu.edu.cn)</a>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>        String head = in.next();<br>        System.out.print(head+<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">while</span>(in.hasNext())&#123;<br>            <span class="hljs-keyword">if</span>(in.hasNext(<span class="hljs-string">&quot;\\d+:\\d+&quot;</span>))&#123;<br>                head = in.next();<br>                System.out.print(n+<span class="hljs-string">&quot;\n&quot;</span>+head+<span class="hljs-string">&quot; &quot;</span>);<br>                n = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                String s = in.next();<br>                <span class="hljs-keyword">if</span>(s.matches(<span class="hljs-string">&quot;\\w+\\D*&quot;</span>))  n++;<br>            &#125;<br>        &#125;<br>        System.out.println(n);<br>        in.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html">Scanner (Java SE 11 &amp; JDK 11 ) (runoob.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（总集篇Ⅰ）| Hexo-Manager开发阶段性总结与下一步计划</title>
      <link href="/augu1sto/7acb8e0037c2/"/>
      <url>/augu1sto/7acb8e0037c2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>到现在，我的Hexo-Manager开发出了第一版 0.0.1-alpha，并在github上pre-release了。尽管功能很简陋，但还是具备一定实用性，并且学习到了许多知识。本文只在对目前的开发进度进行总结，对一些原理进行记录，并对未来工作的思考进行一些记录。</p></blockquote><h2 id="hexo-manager-0-0-1-alpha">Hexo-Manager 0.0.1-alpha<a class="header-anchor" href="#hexo-manager-0-0-1-alpha">⁍</a></h2><p><img src="https://user-images.githubusercontent.com/38211047/156713434-b510eced-19e8-432d-8105-04e2f0455aaa.png" alt="banner"></p><blockquote><p>Hexo-Manager是一个Windows平台的针对Hexo博客进行可视化管理的软件</p></blockquote><h3 id="运行环境">运行环境<a class="header-anchor" href="#运行环境">⁍</a></h3><p>Windows</p><h3 id="下载、安装和配置">下载、安装和配置<a class="header-anchor" href="#下载、安装和配置">⁍</a></h3><p>到<a href="https://github.com/Augu1sto/Hexo-Manager/releases">release</a>页面里下载setup文件，双击安装点击右上角的设置按钮，对于你的Hexo根目录进行配置，例如 <code>C:\hexoBlog</code></p><blockquote><p>这里有问题，在dev的环境下可以输入<code>C:\\hexoBlog</code>转义，也可以直接输入<code>C:\hexoBlog</code>，但是在打包后，只能输入<code>C:\hexoBlog</code>，不能加转义字符</p></blockquote><p><img src="https://user-images.githubusercontent.com/38211047/156712420-b50ca04f-00bb-4265-847d-577109c24391.png" alt="image"></p><h3 id="开发环境">开发环境<a class="header-anchor" href="#开发环境">⁍</a></h3><ul><li>Electron-Vue框架</li><li>NodeJS: v16.8.0</li></ul><h3 id="主要功能">主要功能<a class="header-anchor" href="#主要功能">⁍</a></h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 点击“打开”，选择文件，用系统默认的编辑器打开</li><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 点击“新建”，输入文章名称，新建hexo文章，并用系统默认的编辑器打开</li><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 点击“一键部署”，执行 hexo clean &amp;&amp; hexo deploy。生成站点文件并推送至远程库。</li></ul><h3 id="可能存在的问题">可能存在的问题<a class="header-anchor" href="#可能存在的问题">⁍</a></h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 未进行错误处理和异常处理以及日志输出会在接下来的版本里继续研发，请试用的朋友一定 <strong>先配置根目录</strong></li></ul><h2 id="主要功能开发记录">主要功能开发记录<a class="header-anchor" href="#主要功能开发记录">⁍</a></h2><h3 id="安装">安装<a class="header-anchor" href="#安装">⁍</a></h3><ul><li><a href="#">Post not found: Electron-vue开发实战（一）| 入门与安装</a></li><li><a href="#">Post not found: Electron-vue开发实战（一）plus| Node16.8.0不降级安装Electron-vue+ElementUI开发环境</a></li></ul><p>这两篇文章主要介绍了环境的配置与安装，我中途将NodeJS的环境统一到了16.8.0，建议主要环境看第二篇，具体细节看第一篇</p><h3 id="调试">调试<a class="header-anchor" href="#调试">⁍</a></h3><ul><li>主进程调试： <a href="#">Post not found: Electron-vue开发实战（四）| VSCODE调试主进程</a></li><li>渲染进程调试：Vue_dev_tools的安装见 <a href="#">Post not found: Electron-vue开发实战（一）| 入门与安装</a></li></ul><h3 id="主窗口">主窗口<a class="header-anchor" href="#主窗口">⁍</a></h3><h4 id="窗口设置">窗口设置<a class="header-anchor" href="#窗口设置">⁍</a></h4><ul><li>程序入口以及窗口设置见 <a href="#">Post not found: Electron-vue开发实战（二）| Main进程开发</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/main/index.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建窗口</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Initial window options</span><br><span class="hljs-comment">   */</span><br>  mainWindow = <span class="hljs-keyword">new</span> BrowserWindow(&#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">useContentSize</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">720</span>,<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hexo-Manager&#x27;</span>,<br>    <span class="hljs-attr">center</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">frame</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">titleBarStyle</span>: <span class="hljs-string">&#x27;hidden&#x27;</span>,<br>    <span class="hljs-attr">resizable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#F2F2F2&#x27;</span>,<br>    <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 漏了这个</span><br>    <span class="hljs-comment">// alwaysOnTop: true,</span><br><br>    <span class="hljs-attr">webPreferences</span>: &#123;<br>      <span class="hljs-comment">// 开启node</span><br>      <span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">contextIsolation</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-comment">// 开启remote</span><br>      <span class="hljs-attr">enableRemoteModule</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;)<br><br>  mainWindow.loadURL(winURL) <span class="hljs-comment">// 加载窗口的URL -&gt; 来自renderer进程的页面</span><br><br>  mainWindow.once(<span class="hljs-string">&#x27;ready-to-show&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 防止视觉闪烁</span><br>    mainWindow.show()<br>  &#125;)<br><br>  mainWindow.on(<span class="hljs-string">&#x27;closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    mainWindow = <span class="hljs-literal">null</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在0.0.1-alpha里面，漏了<code>show: false</code>这一句，打算在下次更新里修复啦</p></blockquote><h4 id="关闭-最小化窗口">关闭/最小化窗口<a class="header-anchor" href="#关闭-最小化窗口">⁍</a></h4><p>通过ipcRenderer和主进程通信 <a href="#">Post not found: Electron-vue开发实战（三）| Render进程开发</a></p><ul><li>渲染进程：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--src\renderer\components\Entry.vue--&gt;<br>&lt;i class=&quot;el-icon-minus&quot; @click=&quot;minimizeWindow&quot;&gt;&lt;/i&gt;<br>&lt;i class=&quot;el-icon-close&quot; @click=&quot;closeWindow&quot;&gt;&lt;/i&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  methods: &#123;<br>      minimizeWindow () &#123;<br>      const &#123; ipcRenderer &#125; = require(&#x27;electron&#x27;)<br>      ipcRenderer.send(&#x27;minimize_w&#x27;)<br>    &#125;,<br>      closeWindow () &#123;<br>      const &#123; ipcRenderer &#125; = require(&#x27;electron&#x27;)<br>      ipcRenderer.send(&#x27;close_w&#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>主进程</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/main/index.js</span><br>ipcMain.on(<span class="hljs-string">&#x27;minimize_w&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = BrowserWindow.getFocusedWindow()<br>  <span class="hljs-built_in">window</span>.minimize()<br>&#125;)<br><br>ipcMain.on(<span class="hljs-string">&#x27;close_w&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = BrowserWindow.getFocusedWindow()<br>  <span class="hljs-keyword">if</span> (process.platform === <span class="hljs-string">&#x27;linux&#x27;</span>) &#123;<br>    <span class="hljs-built_in">window</span>.hide()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">window</span>.close()<br>    app.quit()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="hexo设置、调用cmd输入hexo命令">hexo设置、调用cmd输入hexo命令<a class="header-anchor" href="#hexo设置、调用cmd输入hexo命令">⁍</a></h3><h4 id="设置">设置<a class="header-anchor" href="#设置">⁍</a></h4><p>通过electron-store建立本地json数据库，将hexo的根目录读写到配置文件里</p><a href="#">Post not found: Electron-vue开发实战（六）| Electron数据本地存储：用electron-store实现json配置文件读写</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/main/index.js</span><br><span class="hljs-keyword">let</span> hexoRoot<br><span class="hljs-keyword">const</span> Store = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron-store&#x27;</span>)<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Store()<br><span class="hljs-comment">// 通过配置文件读写hexo根目录</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRoot</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// TODO：错误处理，为空的情况，转换特殊字符等</span><br>  hexoRoot = store.get(<span class="hljs-string">&#x27;hexo_root&#x27;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setRoot</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  store.set(<span class="hljs-string">&#x27;hexo_root&#x27;</span>, root)<br>&#125;<br><br>ipcMain.on(<span class="hljs-string">&#x27;setConfig&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, value</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value)<br>  setRoot(value)<br>  event.returnValue = <span class="hljs-string">&#x27;setSuccess&#x27;</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><h4 id="新建文章">新建文章<a class="header-anchor" href="#新建文章">⁍</a></h4><p>前端传入文章的标题，传给主进程，调用shell输入<code>hexo new [post_name]</code>的命令，新建文章；</p><p>将文章标题进行特殊字符转换，然后通过路径打开该文章</p><a href="#">Post not found: Electron-vue开发实战（五）| 主进程调用CMD</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/main/index.js</span><br>ipcMain.on(<span class="hljs-string">&#x27;newFile&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, value, fname</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value + fname)<br>  newAndOpenFile(value, fname)<br>  event.returnValue = <span class="hljs-string">&#x27;success&#x27;</span><br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newAndOpenFile</span> (<span class="hljs-params">value, fname</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> cmdPath = hexoRoot<br>  <span class="hljs-keyword">const</span> cmdStr = <span class="hljs-string">&#x27;hexo new &quot;&#x27;</span> + value + <span class="hljs-string">&#x27;&quot;&#x27;</span> <span class="hljs-comment">// hexo new &quot;[article_name]&quot;</span><br>  <span class="hljs-keyword">const</span> workerProcess = exec(cmdStr, &#123;<br>    <span class="hljs-attr">cwd</span>: cmdPath,<br>    <span class="hljs-attr">encoding</span>: <span class="hljs-string">&#x27;gbk&#x27;</span><br>  &#125;)<br>  workerProcess.stdout.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stdout: &#x27;</span> + data.toString())<br>  &#125;)<br><br>  <span class="hljs-comment">// 打印错误的后台可执行程序输出</span><br>  workerProcess.stderr.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stderr: &#x27;</span> + data.toString())<br>  &#125;)<br><br>  <span class="hljs-comment">// 退出之后的输出</span><br>  workerProcess.on(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;out code：&#x27;</span> + code)<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      shell.openPath(hexoRoot + <span class="hljs-string">&#x27;\\source\\_posts\\&#x27;</span> + fname + <span class="hljs-string">&#x27;.md&#x27;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-built_in">console</span>.error(error)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="打开文章">打开文章<a class="header-anchor" href="#打开文章">⁍</a></h4><a href="#">Post not found: Electron-vue开发实战（二）| Main进程开发</a> 文中使用remote在渲染进程中实现了该功能，在实践中我去除了remote，选择用ipcRender和ipcMain通信实现了该功能。<p>渲染进程将消息传递给主进程，主进程通过调用系统dialog来打开文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/main/index.js</span><br>ipcMain.on(<span class="hljs-string">&#x27;open_file&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  openFile()<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openFile</span> (<span class="hljs-params"></span>) </span>&#123;<br>  getRoot()<br>  dialog.showOpenDialog(&#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;打开文件&#x27;</span>,<br>    <span class="hljs-attr">defaultPath</span>: hexoRoot + <span class="hljs-string">&#x27;\\source\\_posts\\&#x27;</span>,<br>    <span class="hljs-attr">properties</span>: [<span class="hljs-string">&#x27;openFile&#x27;</span>],<br>    <span class="hljs-attr">filters</span>: [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Markdown文件&#x27;</span>, <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;md&#x27;</span>, <span class="hljs-string">&#x27;markdown&#x27;</span>] &#125;]<br>  &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(result.filePaths) <span class="hljs-comment">// 获得打开的文件路径</span><br>      shell.openPath(result.filePaths[<span class="hljs-number">0</span>])<br>    &#125;)<br>    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(err)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一键部署">一键部署<a class="header-anchor" href="#一键部署">⁍</a></h4><p>同样是通过主进程调用shell传入命令 <code>hexo cl&amp;&amp;hexo g -d </code></p><a href="#">Post not found: Electron-vue开发实战（五）| 主进程调用CMD</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">ipcMain.on(<span class="hljs-string">&#x27;deploy_all&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  getRoot()<br>  <span class="hljs-keyword">const</span> cmdPath = hexoRoot<br>  <span class="hljs-keyword">const</span> cmdStr = <span class="hljs-string">&#x27;hexo cl&amp;&amp;hexo g -d&#x27;</span><br>  <span class="hljs-comment">// const cmdStr0 = iconv.decode(cmdStr, &#x27;cp936&#x27;)</span><br>  <span class="hljs-keyword">const</span> workerProcess = exec(cmdStr, &#123;<br>    <span class="hljs-attr">cwd</span>: cmdPath,<br>    <span class="hljs-attr">encoding</span>: <span class="hljs-string">&#x27;gbk&#x27;</span><br>  &#125;)<br>  workerProcess.stdout.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stdout: &#x27;</span> + data.toString())<br>  &#125;)<br><br>  <span class="hljs-comment">// 打印错误的后台可执行程序输出</span><br>  workerProcess.stderr.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stderr: &#x27;</span> + data.toString())<br>  &#125;)<br><br>  <span class="hljs-comment">// 退出之后的输出</span><br>  workerProcess.on(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;out code：&#x27;</span> + code)<br>    event.returnValue = <span class="hljs-string">&#x27;deploySuccess&#x27;</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="原理理解与总结">原理理解与总结<a class="header-anchor" href="#原理理解与总结">⁍</a></h2><h3 id="nodejs">NodeJS<a class="header-anchor" href="#nodejs">⁍</a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 Javascript 运行环境<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h4 id="node-js学习资源">Node.js学习资源<a class="header-anchor" href="#node-js学习资源">⁍</a></h4><p>根据官网给出的建议<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>，在深入研究 Node.js 之前，最好要了解JavaScript和异步编程的概念，有空再慢慢看一遍。</p><h3 id="rust">rust<a class="header-anchor" href="#rust">⁍</a></h3><p>最近看到了有人介绍 <a href="https://github.com/vinodotdev/node-to-rust/releases/download/v1/from-javascript-to-rust.pdf">from-javascript-to-rust.pdf (github.com)</a></p><p>发现微软也有相关教程，<a href="https://docs.microsoft.com/zh-cn/learn/paths/rust-first-steps/">使用 Rust 迈出第一步 - Learn | Microsoft Docs</a></p><p>就搜索了一下rust，感觉可能是未来的趋势啊。。</p><h3 id="electron">electron<a class="header-anchor" href="#electron">⁍</a></h3><p>Electron相当于把Node和浏览器应用结合到一起，使得浏览器应用可以访问文件系统等、Node应用可以具备GUI界面。</p><p>回头来再理解PicGo项目里的这句话，就变得明了了。</p><p>electron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><h2 id="未来工作">未来工作<a class="header-anchor" href="#未来工作">⁍</a></h2><h3 id="待开发功能">待开发功能<a class="header-anchor" href="#待开发功能">⁍</a></h3><ul class="contains-task-list"><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 代码重构</p><p>随着代码功能的增多，需要对项目进行功能解耦，想参考PicGo项目对代码先进行重构</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 错误处理和日志记录</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> git拉取与上传</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 更复杂的配置</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> git配置</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 编辑器<ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 根据分类构建文件树</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 添加标签</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 图片自动上传PicGo</li></ul></li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> hexo各项的基础配置的可视化</li></ul></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 优化新建功能：<code>js-yaml</code></p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 可以选择标签、分类</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 入口界面添加“最近文件”功能</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> hexo插件管理</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> …</p></li></ul><h3 id="与hexo集成">与hexo集成<a class="header-anchor" href="#与hexo集成">⁍</a></h3><p>在目前的开发思路中，是基于已经安装了hexo的环境，运用shell去调用hexo的各种命令，实现新建、部署等功能。</p><h4 id="优点与可行性">优点与可行性<a class="header-anchor" href="#优点与可行性">⁍</a></h4><p>事实上，hexo提供了<a href="https://hexo.io/zh-cn/api/">API | Hexo</a>，通过引入<code>hexo</code>包，可以用api直接调用新建、部署等功能，甚至方便地去查询文档的<code>yml</code>信息，查看渲染完毕的网页。</p><h4 id="缺点">缺点<a class="header-anchor" href="#缺点">⁍</a></h4><p>但是我认为这么做还是有另一种方面的局限？</p><p>如果要开发成npm包，可能是没什么问题；</p><p>如果要打包成独立的exe文件，就必须将整个hexo也打包进去（如果我的理解对的话）。当然也可以就此变成整个hexo从安装开始就可视化的软件（任重道远啊。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://nodejs.cn/learn">Node.js 简介 (nodejs.cn)</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/47822968">什么是 Nodejs ? - 知乎 (zhihu.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://molunerfinn.com/electron-vue-1/">Electron-vue开发实战0——Electron-vue入门 | MARKSZのBlog (molunerfinn.com)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> vue </tag>
            
            <tag> Node.js </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（七）| icon设置与发布等</title>
      <link href="/augu1sto/2b9fe5008a62/"/>
      <url>/augu1sto/2b9fe5008a62/</url>
      
        <content type="html"><![CDATA[<h2 id="logo">LOGO<a class="header-anchor" href="#logo">⁍</a></h2><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203032131709.png" alt="logo-large"></p><p>本项目图标logo采用<a href="https://www.canva.cn/design/play?template=EAEHR2T6jM4&amp;category=tADLkg220qc&amp;type=TAD-K-k4STM">现代渐变logo图标icon设计元素-素材集合 (canva.cn)</a>设计，直接加了个H的字母在上面</p><p>不同平台上应用的LOGO尺寸和格式也不尽相同。三个平台所需的图片格式如下：<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><ul><li>Linux - png</li><li>macOS - icns</li><li>Windows - ico</li></ul><p>可以先准备好png，再转换</p><p>都放入build/icons文件夹</p><blockquote><p>不知道为啥我的icon复制过来就还是electron原来的样子。。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203032139458.png" alt="image-20220303213957427"></p><p>只能改名再放进去，直接打包会报错（我好迷惑）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203032335408.png" alt="image-20220303233542383"></p></blockquote><p><code>package.json</code>里的配置如下（原先就有）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;mac&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;icon&quot;</span>: <span class="hljs-string">&quot;build/icons/icon.icns&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;win&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;icon&quot;</span>: <span class="hljs-string">&quot;build/icons/icon.ico&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;linux&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;icon&quot;</span>: <span class="hljs-string">&quot;build/icons&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="appid是什么">AppID是什么<a class="header-anchor" href="#appid是什么">⁍</a></h2><p>AppID是与注册表相关的东西。我们在主进程<code>index.js</code>里也要使用。否则打包后的应用将失去Windows平台的应用通知功能。</p><blockquote><p>注册表下的内容，如HKEY_CLASSES_ROOT\CLSID下存放了所有的类和组件类别，但是模块可以由很多个类组成，那么这些类组成的这个模块，在COM中被称为<strong>应用</strong>，每一个应用对应着的这些模块，会有一些相同的设置，例如安全性、访问权限等，其中Dll代理其中一部分。</p><p>为了表示某个CLSID是属于某个AppID（将CLSID关联AppID），我们需要在HKEY_CLASSES_ROOT\CLSID{你的CLSID}键中，新建一个叫AppID的值，其中的内容就是它所属的AppID。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p></blockquote><p>在<code>package.json</code>中添加</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;appId&quot;</span>: <span class="hljs-string">&quot;com.augu1sto.hexo-manager&quot;</span>,<br></code></pre></td></tr></table></figure><h2 id="打包其他配置">打包其他配置<a class="header-anchor" href="#打包其他配置">⁍</a></h2><p>在Windows平台上，默认打包出来的安装包并没有办法选择安装的路径，只会默认装到C盘的用户目录。这个并不是我们想要的。我们想要的是让用户自己选择安装的路径。</p><p>所以需要修改<code>windows</code>的一些配置以及加上一个<code>nsis</code>的配置来实现：<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;win&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;icon&quot;</span>: <span class="hljs-string">&quot;build/icons/icon.ico&quot;</span>,<br>  <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;nsis&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;nsis&quot;</span>: &#123;<br>          <span class="hljs-comment">// 是否一键安装，建议为 false，可以让用户点击下一步、下一步、下一步的形式安装程序，如果为true，当用户双击构建好的程序，自动安装程序并打开，即：一键安装（one-click installer）</span><br>          oneClick: <span class="hljs-literal">false</span>,<br>          <span class="hljs-comment">// 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。</span><br>          allowElevation: <span class="hljs-literal">true</span>,<br>          <span class="hljs-comment">// 允许修改安装目录，建议为 true，是否允许用户改变安装目录，默认是不允许</span><br>          allowToChangeInstallationDirectory: <span class="hljs-literal">true</span>,<br>          <span class="hljs-comment">// 安装图标</span><br>          installerIcon: &#x27;build/icons/icon.ico&#x27;,<br>          <span class="hljs-comment">// 卸载图标</span><br>          uninstallerIcon: &#x27;build/icons/icon.ico&#x27;,<br>          <span class="hljs-comment">// 安装时头部图标</span><br>          installerHeaderIcon: &#x27;build/icons/icon.ico&#x27;,<br>          <span class="hljs-comment">// 创建桌面图标</span><br>          createDesktopShortcut: <span class="hljs-literal">true</span>,<br>          <span class="hljs-comment">// 创建开始菜单图标</span><br>          createStartMenuShortcut: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以增加参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这个意思是打出来32 bit + 64 bit的包，但是要注意：这样打包出来的安装包体积比较大</span><br>            <span class="hljs-attr">arch</span>: [<br>              <span class="hljs-string">&#x27;x64&#x27;</span><br>              <span class="hljs-comment">// &#x27;ia32&#x27;</span><br>            ]<br></code></pre></td></tr></table></figure><p>设置在系统通知里的名字：</p><p>打开你的<code>main/index.js</code>，在Windows平台的时候加上这个<code>productName</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">import</span> pkg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../package.json&#x27;</span><br><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">if</span> (process.platform === <span class="hljs-string">&#x27;win32&#x27;</span>) &#123;<br>  <span class="hljs-comment">//app.setAppUserModelId(pkg.build.appId) </span><br>  app.setAppUserModelId(pkg.build.productName) <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打包">打包<a class="header-anchor" href="#打包">⁍</a></h2><p><code>yarn run build</code></p><p>报了错</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203032326368.png" alt="img"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203032327603.png" alt="image-20220303232705564"></p><p>解决：使用了electron-store的包，要放在依赖（非开发依赖里）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">&quot;electron-store&quot;</span>: <span class="hljs-string">&quot;^8.0.1&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解决了上面说的图标问题后，总算成功了</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203032336384.png" alt="image-20220303233626351"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203032340994.png" alt="image-20220303234015945"></p><h2 id="发布">发布<a class="header-anchor" href="#发布">⁍</a></h2><h3 id="软件版本号—规范与命名规则">软件版本号—规范与命名规则<a class="header-anchor" href="#软件版本号—规范与命名规则">⁍</a></h3><p>在一个产品产生的过程中会经历很多阶段，从需求确立直到发版，在不同的阶段会有不同的命名，我们来看看。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><ol><li>Alpha版 表示该软件刚刚具有雏形，有了基本功能，大多用于开发者之间交流，bug还比较多，尚待修改完善。</li><li>Beta版 表示该软件消除了严重的错误，但还需要大量测试来进一步修改剩下的bug，这部分修改主要针对UI。</li><li>Rc版 表示该软件基本不存在会导致错误的严重bug，与正式版接近。</li><li>Release版 该版本表示一个正式版本，此版本会面向用户，称为标准版。简写为R。举例：如1.0.0Beta，表示该软件进入测试版本。</li></ol><p>软件版本号由四部分组成：</p><ol><li>第一部分为主版本号</li><li>第二部分为子版本号</li><li>第三部分为阶段版本号</li><li>第四部分为日期版本号加希腊字母版本号</li></ol><h3 id="软件版本自动构建与发布">软件版本自动构建与发布<a class="header-anchor" href="#软件版本自动构建与发布">⁍</a></h3><p>可以参考<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，添加脚本</p><h3 id="手动发布">手动发布<a class="header-anchor" href="#手动发布">⁍</a></h3><p>在github上创建release</p><p><a href="https://github.com/Augu1sto/Hexo-Manager/releases">Releases · Augu1sto/Hexo-Manager (github.com)</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://molunerfinn.com/electron-vue-5/#LOGO%E7%9A%84%E5%87%86%E5%A4%87">Electron-vue开发实战4——通过CI发布以及更新的方式 | MARKSZのBlog (molunerfinn.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/141830822">COM编程攻略（十九 AppID、Dll代理） - 知乎 (zhihu.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/109399321">electron-vue跨平台桌面应用开发实战教程（六）——打包 - 知乎 (zhihu.com)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.jianshu.com/p/6df3b8dcbe17">产品笔记 | 软件版本号—规范与命名规则 - 简书 (jianshu.com)</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://molunerfinn.com/electron-vue-5/#%E9%80%9A%E8%BF%87CI%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83">Electron-vue开发实战4——通过CI发布以及更新的方式 | MARKSZのBlog (molunerfinn.com)</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（六）| Electron数据本地存储：用electron-store实现json配置文件读写</title>
      <link href="/augu1sto/63c5a47ab77f/"/>
      <url>/augu1sto/63c5a47ab77f/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库选择">数据库选择<a class="header-anchor" href="#数据库选择">⁍</a></h2><p>在PicGo项目中，作者在<a href="https://github.com/louischatriot/nedb">nedb</a> 和<a href="https://github.com/typicode/lowdb">lowdb</a> 中进行了选择，最终选择了后者。但是在配置的时候还是踩了不少坑。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>经过搜索，本项目决定采用<code>electron-store</code>进行存储。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><h2 id="安装">安装<a class="header-anchor" href="#安装">⁍</a></h2><p><code>yarn add electron-store --dev</code></p><p>安装很顺利，<s>都有点不习惯了</s>。</p><h2 id="配置文件名称和路径">配置文件名称和路径<a class="header-anchor" href="#配置文件名称和路径">⁍</a></h2><p>创建Store实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Store = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron-store&#x27;</span>);<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Store();<br></code></pre></td></tr></table></figure><h3 id="name"><strong>name</strong><a class="header-anchor" href="#name">⁍</a></h3><p>Type: <code>string</code><br>Default: <code>config</code><br>存储文件的名称（不带扩展名）。</p><h3 id="cwd"><strong>cwd</strong><a class="header-anchor" href="#cwd">⁍</a></h3><p>Type: <code>string</code><br>Default: <code>app.getPath('userData')</code></p><p>存储文件位置。 除非绝对必要，否则请勿指定！ 默认情况下，它将通过遵循系统约定来选择最佳位置。 您很可能会误解并惹恼用户。</p><p>如果是相对路径，则相对于默认cwd。 例如在macOS 中，<code>&#123;cwd：'unicorn'&#125;</code>将在<code>〜/Librar/Application\ Support/App\ Name/unicorn</code>中生成一个存储文件。</p><p><a href="https://www.electronjs.org/zh/docs/latest/api/app#appgetpathname">app | Electron (electronjs.org)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.getPath(<span class="hljs-string">&#x27;userData&#x27;</span>)<br></code></pre></td></tr></table></figure><p>储存你应用程序设置文件的文件夹，默认是 <code>appData</code> 文件夹附加应用的名称</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203031818806.png" alt="image-20220303181806636"></p><h3 id="fileextension"><strong>fileExtension</strong><a class="header-anchor" href="#fileextension">⁍</a></h3><p>Type: <code>string</code><br>Default: <code>json</code></p><p>配置文件的扩展名。</p><p>更多参考ref[4]的翻译。</p><h2 id="读">读<a class="header-anchor" href="#读">⁍</a></h2><h3 id="get-key-defaultvalue"><strong>.get(key, [defaultValue])</strong><a class="header-anchor" href="#get-key-defaultvalue">⁍</a></h3><p>获取一个项目或defaultValue（如果该项目不存在）。</p><h2 id="写">写<a class="header-anchor" href="#写">⁍</a></h2><h3 id="set-key-value"><strong>.set(key, value)</strong><a class="header-anchor" href="#set-key-value">⁍</a></h3><p>设置一个项目。该值必须是JSON可序列化的。 尝试将类型设置为undefined，function或symbol会导致TypeError。</p><h3 id="set-object"><strong>.set(object)</strong><a class="header-anchor" href="#set-object">⁍</a></h3><p>一次设置多个项目。</p><h2 id="应用">应用<a class="header-anchor" href="#应用">⁍</a></h2><p>往配置文件里读/写hexo根目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">let hexoRoot<br><span class="hljs-keyword">const</span> Store = require(<span class="hljs-string">&#x27;electron-store&#x27;</span>)<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Store()<br><span class="hljs-comment">// 通过配置文件读写hexo根目录</span><br><span class="hljs-function">function <span class="hljs-title">getRoot</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// TODO：错误处理，为空的情况，转换特殊字符等</span><br>  hexoRoot = store.get(<span class="hljs-string">&#x27;hexo_root&#x27;</span>)<br>&#125;<br><br><span class="hljs-function">function <span class="hljs-title">setRoot</span> <span class="hljs-params">(root)</span> </span>&#123;<br>  store.set(<span class="hljs-string">&#x27;hexo_root&#x27;</span>, root)<br>&#125;<br><br>ipcMain.on(<span class="hljs-string">&#x27;setConfig&#x27;</span>, (event, value) =&gt; &#123;<br>  console.log(value)<br>  setRoot(value)<br>  event.returnValue = <span class="hljs-string">&#x27;setSuccess&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://molunerfinn.com/electron-vue-3/">Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb | MARKSZのBlog (molunerfinn.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://github.com/sindresorhus/electron-store">sindresorhus/electron-store: Simple data persistence for your Electron app or module - Save and load user preferences, app state, cache, etc (github.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://www.kancloud.cn/idcpj/python/1017775">electron-store 以文件形式缓存配置 · PHP/Python/前端/Linux 等等 学习笔记 · 看云 (kancloud.cn)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://xushanxiang.com/2019/12/electron-store.html">Electron存储简单数据和用户首选项推荐用electron-store (xushanxiang.com)</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> json </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|滑动窗口</title>
      <link href="/augu1sto/8520ff749f4c/"/>
      <url>/augu1sto/8520ff749f4c/</url>
      
        <content type="html"><![CDATA[<p><strong>注：</strong> 仅记录模板题，滑动窗口非这些题目的最佳解(不如说大部分都可以优化。。)</p><h2 id="滑动窗口模板">滑动窗口模板<a class="header-anchor" href="#滑动窗口模板">⁍</a></h2><p>步骤<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><ol><li>根据题意维护变量<ol><li>和 Sum</li><li>最大长度 max_len，最小长度 min_len<ul><li><strong>注意：</strong> 有的时候要设<code>Integer.MAX_VALUE</code>/<code>Integer.MIN_VALUE</code></li></ul></li><li>不重复 hashmap = {}</li><li>等</li></ol></li><li>窗口的开始位置start和结束位置end</li><li>根据条件写判断语句，维护step1中的变量</li><li>根据题目要求，从中选择一种方法套用<ul><li>选择一：窗口长度固定<br>if 窗口长度达到限定的长度：<br>1.更新step1中的相关变量<br>2.窗口左边位置start向前移动 1，保证end向右移动时窗口长度保持不变</li><li>选择二：窗口长度不固定<br>while 窗口条件不符合：<br>1.更新step1中的相关变量<br>2.不断移动start，直到窗口条件符合</li></ul></li><li>返回答案</li></ol><h2 id="643-子数组最大平均数-i"><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/description/">643. 子数组最大平均数 I</a><a class="header-anchor" href="#643-子数组最大平均数-i">⁍</a></h2><p>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数</p><blockquote><p><strong>示例如下:</strong></p><p>输入：nums = [1,12,-5,-6,50,3], k = 4</p><p>输出：12.75</p><p>解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</p></blockquote><blockquote><p>**解题思路：**通过滑动窗口算法找到长度为k的连续子数组的最大和，再除以k，得到结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// step1</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> avg = Integer.MIN_VALUE;<br>        <span class="hljs-comment">// step2</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; end &lt; nums.length; end++) &#123;<br>            <span class="hljs-comment">// step3</span><br>            sum += nums[end];<br>            <span class="hljs-keyword">if</span> (end - start + <span class="hljs-number">1</span> == k) &#123;<br>                avg = Math.max(<span class="hljs-number">1.0</span> *sum/k, avg);<br>            &#125;<br>            <span class="hljs-comment">// step4</span><br>            <span class="hljs-keyword">if</span> (end - start + <span class="hljs-number">1</span>&gt;=k) &#123;<br>                sum -= nums[start];<br>                start += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// step5</span><br>        <span class="hljs-keyword">return</span> avg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><mark>注意浮点数精度，要用double</mark></p><h2 id="3-无重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a><a class="header-anchor" href="#3-无重复字符的最长子串">⁍</a></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度 。</p><blockquote><p><strong>示例如下:</strong></p><p>输入：s = “abcabcbb”</p><p>输出：3</p><p>解释：因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><blockquote><p>**解题思路：**题目中提到不重复字符串，所以引入哈希表存储，key存储元素，value存储出现的次数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// step1</span><br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>        Map&lt;Character,Integer&gt; myMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// step2</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span>[] st = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; end &lt; s.length(); end++) &#123;<br>            <span class="hljs-keyword">int</span> k = myMap.getOrDefault(st[end], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            myMap.put(st[end],k);<br>            <span class="hljs-comment">// step3</span><br>            <span class="hljs-keyword">if</span> (myMap.size()==end-start+<span class="hljs-number">1</span>) &#123;<br>                maxLen = Math.max(end-start+<span class="hljs-number">1</span>, maxLen);<br>            &#125;<br>            <span class="hljs-comment">// step4</span><br>            <span class="hljs-keyword">while</span> (myMap.size()&lt;end-start+<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">int</span> val = myMap.get(st[start]);<br>                val--;<br>                <span class="hljs-keyword">if</span> (val==<span class="hljs-number">0</span>) &#123;<br>                    myMap.remove(st[start]);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    myMap.put(st[start], val);<br>                &#125;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a><a class="header-anchor" href="#209-长度最小的子数组">⁍</a></h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 **连续子数组 [numsl, numsl+1, …, numsr-1, numsr] **，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><blockquote><p><strong>示例如下:</strong></p><p>输入：target = 7, nums = [2,3,1,2,4,3]</p><p>输出：2</p><p>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p>输入：target = 11, nums = [1,1,1,1,1,1,1,1]</p><p>输出：0</p></blockquote><blockquote><p>**解题思路：**通过滑动窗口算法找到连续子数组的和 &gt;=target的最小长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">// step1</span><br>        <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// step2</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; end &lt; nums.length; end++) &#123;<br>            <span class="hljs-comment">// step3</span><br>            sum += nums[end];<br>            <span class="hljs-keyword">if</span> (sum&gt;=target) &#123;<br>                minLen = Math.min(minLen, end - start + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// step4</span><br>            <span class="hljs-keyword">while</span> (sum&gt;=target) &#123;<br>                minLen = Math.min(minLen, end - start + <span class="hljs-number">1</span>);<br>                sum -= nums[start];<br>                start ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// step5</span><br>        <span class="hljs-keyword">return</span> minLen==Integer.MAX_VALUE?<span class="hljs-number">0</span>:minLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1695-删除子数组的最大得分"><a href="https://leetcode-cn.com/problems/maximum-erasure-value/description/">1695. 删除子数组的最大得分</a><a class="header-anchor" href="#1695-删除子数组的最大得分">⁍</a></h2><p>给你一个正整数数组 nums ，请你从中删除一个含有<strong>若干不同元素</strong>的子数组。删除子数组的<strong>得分</strong>就是子数组各元素之<strong>和</strong> 。</p><p>返回 <strong>只删除一个</strong>子数组可获得的<strong>最大得分</strong>。</p><p>如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p><blockquote><p><strong>示例如下:</strong></p><p>输入：nums = [4,2,4,5,6]</p><p>输出：17</p><p>解释：最优子数组是 [2,4,5,6]</p><p>输入：nums = [5,2,1,2,5,2,1,2,5]</p><p>输出：8</p><p>解释：最优子数组是 [5,2,1] 或 [1,2,5]</p></blockquote><blockquote><p>**解题思路：**只需求不重复的连续子数组的最大和即可，类似Lc3,只是多维护了个Sum和变量</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">maximumUniqueSubarray</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums</span>) &#123;</span><br><span class="hljs-class">        // <span class="hljs-title">step1</span></span><br><span class="hljs-class">        <span class="hljs-title">int</span> <span class="hljs-title">max</span> = 0;</span><br><span class="hljs-class">        <span class="hljs-title">int</span> <span class="hljs-title">sum</span> = 0;</span><br><span class="hljs-class">        <span class="hljs-title">Map</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Integer</span>&gt; <span class="hljs-title">myMap</span> = <span class="hljs-title">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();</span><br><span class="hljs-class">        // <span class="hljs-title">step2</span></span><br><span class="hljs-class">        <span class="hljs-title">int</span> <span class="hljs-title">start</span> = 0;</span><br><span class="hljs-class">        <span class="hljs-title">for</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> end = <span class="hljs-number">0</span>; end &lt; nums.length; end++</span>) &#123;</span><br><span class="hljs-class">            <span class="hljs-title">int</span> <span class="hljs-title">val1</span> = <span class="hljs-title">myMap</span>.<span class="hljs-title">getOrDefault</span>(<span class="hljs-params">nums[end], <span class="hljs-number">0</span></span>) + 1;</span><br><span class="hljs-class">            <span class="hljs-title">myMap</span>.<span class="hljs-title">put</span>(<span class="hljs-params">nums[end], val1</span>);</span><br><span class="hljs-class">            <span class="hljs-title">sum</span> += <span class="hljs-title">nums</span>[<span class="hljs-title">end</span>];</span><br><span class="hljs-class">            // <span class="hljs-title">step3</span></span><br><span class="hljs-class">            <span class="hljs-title">if</span> (<span class="hljs-params">end - start + <span class="hljs-number">1</span> == myMap.size(<span class="hljs-params"></span>) </span>) &#123;</span><br><span class="hljs-class">                <span class="hljs-title">max</span> = <span class="hljs-title">Math</span>.<span class="hljs-title">max</span>(<span class="hljs-params"><span class="hljs-built_in">max</span>, <span class="hljs-built_in">sum</span></span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            <span class="hljs-title">while</span> (<span class="hljs-params">end - start + <span class="hljs-number">1</span> &gt; myMap.size(<span class="hljs-params"></span>)</span>) &#123; // 说明包含重复项</span><br><span class="hljs-class">                <span class="hljs-title">int</span> <span class="hljs-title">val2</span> = <span class="hljs-title">myMap</span>.<span class="hljs-title">get</span>(<span class="hljs-params">nums[start]</span>);</span><br><span class="hljs-class">                <span class="hljs-title">val2</span>--;</span><br><span class="hljs-class">                <span class="hljs-title">if</span> (<span class="hljs-params">val2 == <span class="hljs-number">0</span></span>) &#123;</span><br><span class="hljs-class">                    <span class="hljs-title">myMap</span>.<span class="hljs-title">remove</span>(<span class="hljs-params">nums[start]</span>);</span><br><span class="hljs-class">                &#125;<span class="hljs-title">else</span>&#123;</span><br><span class="hljs-class">                    <span class="hljs-title">myMap</span>.<span class="hljs-title">put</span>(<span class="hljs-params">nums[start], val2</span>);</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">                </span><br><span class="hljs-class">                <span class="hljs-title">sum</span> -= <span class="hljs-title">nums</span>[<span class="hljs-title">start</span>];</span><br><span class="hljs-class">                <span class="hljs-title">start</span>++;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        <span class="hljs-title">return</span> <span class="hljs-title">max</span>;</span><br><span class="hljs-class"></span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/description/">438. 找到字符串中所有字母异位词</a><a class="header-anchor" href="#438-找到字符串中所有字母异位词">⁍</a></h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><blockquote><p><strong>示例1:</strong></p><p>输入：s = “cbaebabacd”, p = “abc”</p><p>输出：[0,6]</p><p>解释：起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p><p><strong>示例2:</strong></p><p>输入：s = “abab”, p = “ab”</p><p>输出：[0,1,2]</p><p>解释：起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p></blockquote><blockquote><p>**解题思路：**滑动窗口满足窗口的所有元素及个数都和目标串一致，滑动窗口的start值即为答案</p></blockquote><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] st = s.toCharArray();<br>        <span class="hljs-comment">// step1</span><br>        Map&lt;Character, Integer&gt; sMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">// s表</span><br>        Map&lt;Character, Integer&gt; pMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">// p表</span><br>        <span class="hljs-comment">// 初始化p表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : p.toCharArray()) &#123;<br>            <span class="hljs-keyword">int</span> value = pMap.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            pMap.put(c, value);<br>        &#125;<br><br>        <span class="hljs-comment">// step2</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; st.length; j++) &#123;<br>            <span class="hljs-comment">// step3</span><br>            <span class="hljs-keyword">int</span> value = sMap.getOrDefault(st[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            sMap.put(st[j], value);<br>            <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &lt; p.length()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sMap.equals(pMap)) &#123;<br>                res.add(i);<br>            &#125;<br>            <span class="hljs-keyword">int</span> tmp = sMap.get(st[i]);<br>            tmp--;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) &#123;<br>                sMap.remove(st[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sMap.put(st[i], tmp);<br>            &#125;<br>            i++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="567-字符串的排列"><a href="https://leetcode-cn.com/problems/permutation-in-string/description/">567. 字符串的排列</a><a class="header-anchor" href="#567-字符串的排列">⁍</a></h2><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。</p><blockquote><blockquote><p>如果是，返回 true ；否则，返回 false 。换句话说，s1 的排列之一是 s2 的 <strong>子串</strong> 。</p></blockquote></blockquote><blockquote><p><strong>示例1:</strong></p><p>输入：s1 = “ab” s2 = “eidbaooo”</p><p>输出：true</p><p>解释：s2 包含 s1 的排列之一 (“ba”)</p><p><strong>示例2:</strong></p><p>输入：s1= “ab” s2 = “eidboaoo”</p><p>输出：false</p></blockquote><blockquote><p>**解题思路：**类似Lc438</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s2.length()&lt;s1.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        Map&lt;Character, Integer&gt; m1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Character, Integer&gt; m2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len = s1.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">int</span> v = m1.getOrDefault(s1.charAt(j), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            m1.put(s1.charAt(j), v);<br>            <span class="hljs-keyword">int</span> v2 = m2.getOrDefault(s2.charAt(j), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            m2.put(s2.charAt(j), v2);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (m1.equals(m2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = s1.length(); j &lt; s2.length(); j++) &#123;<br><br>            <span class="hljs-keyword">int</span> valj = m2.getOrDefault(s2.charAt(j), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            m2.put(s2.charAt(j), valj);<br><br>            <span class="hljs-keyword">int</span> vali = m2.get(s2.charAt(i));<br>            vali--;<br>            <span class="hljs-keyword">if</span> (vali==<span class="hljs-number">0</span>) &#123;<br>                m2.remove(s2.charAt(i));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                m2.put(s2.charAt(i), vali);<br>            &#125;<br>            i++;<br>            <span class="hljs-keyword">if</span> (m1.equals(m2)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://mp.weixin.qq.com/s/A0EGZWjIwJJeQXjmwSYQ_Q">一套模板把这道题&quot;带走&quot; (qq.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（五）| 主进程调用CMD</title>
      <link href="/augu1sto/301e18d1b58e/"/>
      <url>/augu1sto/301e18d1b58e/</url>
      
        <content type="html"><![CDATA[<p>主进程调用cmd其实就是node.js调用cmd</p><p>有两种方法：<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><ol><li>使用child_process</li><li>安装使用node-cmd</li></ol><p>这里直接用第1种方法</p><h2 id="node-js-child-process">Node.js child_process<a class="header-anchor" href="#node-js-child-process">⁍</a></h2><p><code>import &#123; exec &#125; from 'child_process'</code></p><p>默认情况下，会在父 Node.js 进程和衍生的子进程之间建立 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 的管道。 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h4 id="在-windows-上衍生-bat-和-cmd-文件">在 Windows 上衍生 .bat 和 .cmd 文件<a class="header-anchor" href="#在-windows-上衍生-bat-和-cmd-文件">⁍</a></h4><ul><li><a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>: 衍生 shell 并在该 shell 中运行命令，完成后将 <code>stdout</code> 和 <code>stderr</code> 传给回调函数。</li><li><a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a>: 与 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a> 类似，不同之处在于，默认情况下，它直接衍生命令，而不先衍生 shell。</li></ul><p><a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a> 和 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a> 之间区别的重要性可能因平台而异。</p><ul><li>在 <strong>Unix</strong> 类型的操作系统（Unix、Linux、macOS）上，<a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a> 可以更高效，因为它默认不衍生 shell。</li><li>在 <strong>Windows</strong> 上，<code>.bat</code> 和 <code>.cmd</code> 文件在没有终端的情况下无法自行执行，因此无法使用 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a> 启动。 因此， 在 Windows 上运行时，<code>.bat</code> 和 <code>.cmd</code> 文件可以使用具有 <code>shell</code> 选项集的 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>、使用 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>、或通过衍生 <code>cmd.exe</code> 并将 <code>.bat</code> 或 <code>.cmd</code> 文件作为参数传入（这也是 <code>shell</code> 选项和 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a> 所做的）来调用。</li></ul><p>在任何情况下，如果 <mark>脚本文件名</mark> 包含空格，则需要加上引号。</p><p>（注意是文件名）</p><h4 id="child-process-exec-command-options-callback"><code>child_process.exec(command[, options][, callback])</code><a class="header-anchor" href="#child-process-exec-command-options-callback">⁍</a></h4><ul><li><p>⭐ <code>command</code> <a href="http://url.nodejs.cn/9Tw2bK"></a> 要运行的命令，参数以空格分隔。</p></li><li><p><code>options</code></p><ul><li>⭐ <code>cwd</code>  子进程的当前工作目录。 <strong>默认值:</strong> <code>process.cwd()</code>。</li><li><code>env</code> 环境变量键值对。 <strong>默认值:</strong> <code>process.env</code>。</li><li>⭐ <code>encoding</code>  <strong>默认值:</strong> <code>'utf8'</code>  <strong>(如果有中文，建议改为<code>gbk</code>)</strong></li><li><code>shell</code>  用于执行命令的 shell。 请参阅 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_shell_requirements">shell 的要求</a>和<a href="http://nodejs.cn/api-v14/child_process.html#child_process_default_windows_shell">默认的 Windows shell</a>。 <strong>默认值:</strong> Unix 上是 <code>'/bin/sh'</code>，Windows 上是 <code>process.env.ComSpec</code>。</li><li><code>signal</code> 允许使用中止信号中止子进程。</li><li><code>timeout</code> <strong>默认值:</strong> <code>0</code> 。（如果 <code>timeout</code> 大于 <code>0</code>，则如果子进程运行时间超过 <code>timeout</code> 毫秒，父进程将发送由 <code>killSignal</code> 属性（默认为 <code>'SIGTERM'</code>）标识的信号。）</li><li><code>maxBuffer</code>  标准输出或标准错误上允许的最大数据量（以字节为单位）。 如果超过，则子进程将终止并截断任何输出。 请参阅 <a href="http://nodejs.cn/api-v14/child_process.html#child_process_maxbuffer_and_unicode">maxBuffer 和 Unicode</a> 的注意事项。 <strong>默认值:</strong> <code>1024 * 1024</code>。</li><li><code>killSignal</code> <strong>默认值:</strong> <code>'SIGTERM'</code></li><li><code>uid</code> 设置进程的用户标识（参见 <a href="http://url.nodejs.cn/bUGgha"><code>setuid(2)</code></a>）。</li><li><code>gid</code>  设置进程的群组标识（参见 <a href="http://url.nodejs.cn/64HRVx"><code>setgid(2)</code></a>）。</li><li>⭐ <code>windowsHide</code>隐藏通常在 Windows 系统上创建的子进程控制台窗口。 <strong>默认值:</strong> <code>false</code>。</li></ul></li><li><p>⭐ <code>callback</code> 当进程终止时使用输出调用。</p><ul><li><code>error</code></li><li><code>stdout</code></li><li><code>stderr</code> ：成功后，<code>error</code> 将是 <code>null</code>。 出错时，<code>error</code> 将是 <a href="http://nodejs.cn/api-v14/errors.html#errors_class_error"><code>Error</code></a> 的实例。 <code>error.code</code> 属性将是进程的退出码。 按照惯例，除 <code>0</code> 之外的任何退出码都表示错误。 <code>error.signal</code> 将是终止进程的信号。</li></ul></li><li><p>返回: <a href="http://nodejs.cn/api-v14/child_process.html#class-childprocess">&lt;ChildProcess&gt;</a></p></li></ul><p>以本项目为例，调用Hexo命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">ipcMain.on(<span class="hljs-string">&#x27;newFile&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, value, fname</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value + fname)<br>  newAndOpenFile(value, fname)<br>  event.returnValue = <span class="hljs-string">&#x27;success&#x27;</span><br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newAndOpenFile</span> (<span class="hljs-params">value, fname</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> cmdPath = hexoRoot<br>  <span class="hljs-keyword">const</span> cmdStr = <span class="hljs-string">&#x27;hexo new &quot;&#x27;</span> + value + <span class="hljs-string">&#x27;&quot;&#x27;</span> <span class="hljs-comment">// hexo new &quot;[article_name]&quot;</span><br>  <span class="hljs-keyword">const</span> workerProcess = exec(cmdStr, &#123;<br>    <span class="hljs-attr">cwd</span>: cmdPath,<br>    <span class="hljs-attr">encoding</span>: <span class="hljs-string">&#x27;gbk&#x27;</span><br>  &#125;)<br>  workerProcess.stdout.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stdout: &#x27;</span> + data.toString())<br>  &#125;)<br><br>  <span class="hljs-comment">// 打印错误的后台可执行程序输出</span><br>  workerProcess.stderr.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stderr: &#x27;</span> + data.toString())<br>  &#125;)<br><br>  <span class="hljs-comment">// 退出之后的输出</span><br>  workerProcess.on(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;out code：&#x27;</span> + code)<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      shell.openPath(hexoRoot + <span class="hljs-string">&#x27;\\source\\_posts\\&#x27;</span> + fname + <span class="hljs-string">&#x27;.md&#x27;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-built_in">console</span>.error(error)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>几个注意事项：</p><ul><li>文章名要用双引号引起来，不然特殊字符、空格等可能导致出错</li><li>编码选择gbk</li><li>后续操作（这里就是打开新建的文章）要写在退出后的子进程回调的最后，不能写在主进程里！！</li></ul><p>当然，还有写其他写法，都涉及到js语法，可以参考官网api<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup></p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br>exec(<span class="hljs-string">&#x27;cat *.js missing_file | wc -l&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`exec error: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`stderr: <span class="hljs-subst">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/weixin_42762089/article/details/88711853">Electron调用命令行(cmd)方法总结_王俊的博客-CSDN博客_electron exec</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="http://nodejs.cn/api-v14/child_process.html">child_process 子进程 | Node.js API 文档 (nodejs.cn)</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> Electron-vue </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（四）| VSCODE调试主进程</title>
      <link href="/augu1sto/a6ae5aa3a06c/"/>
      <url>/augu1sto/a6ae5aa3a06c/</url>
      
        <content type="html"><![CDATA[<h2 id="package-json查看配置">package.json查看配置<a class="header-anchor" href="#package-json查看配置">⁍</a></h2><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203022324335.png" alt="image-20220302232428278"></p><p>事实上，因为安装的时候什么都选了，所以在package.json里有dev的配置</p><p>可以先点击调试按钮，选择<code>Run Script:dev</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203031010067.png" alt="image-20220303101006462"></p><p>但是一开始我没调出来（可能是要先添加<code>source-map</code>？），先用<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的方法配置<code>lauch.json</code>折腾了一番</p><p>后来发现根本不需要配？【知识增加.jpg】</p><h2 id="source-map">source-map<a class="header-anchor" href="#source-map">⁍</a></h2><p>参考的文章中还写了要在<code>webpack.main.config.js</code>里添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">devtool : <span class="hljs-string">&#x27;source-map&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203022337832.png" alt="image-20220302233701808"></p><p>我照做了，不然好像打不了断点</p><h3 id="什么是source-map">什么是source-map<a class="header-anchor" href="#什么是source-map">⁍</a></h3><p>source-map也是一种针对JavaScript的debug工具<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h3 id="为什么用source-map">为什么用source-map<a class="header-anchor" href="#为什么用source-map">⁍</a></h3><p>JavaScript 脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。</p><p>常见的源码转换，主要是以下三种情况：</p><ul><li>压缩，减小体积</li><li>多个文件合并，减少 HTTP 请求数</li><li>其他语言编译成 JavaScript</li></ul><p>这三种情况，都使得实际运行的代码不同于开发代码，除错（ <code>debug</code> ）变得困难重重，所以才需要 <code>Source Map</code> 。结合上面的例子，即使打包过后的代码，也可以找到具体的报错位置，这使得我们 <code>debug</code> 代码变得轻松简单，这就是 <code>Source Map</code> 想要解决的问题。</p><h3 id="如何生成-source-map">如何生成 Source Map<a class="header-anchor" href="#如何生成-source-map">⁍</a></h3><p>各种主流前端任务管理工具，打包工具都支持生成 <code>Source Map</code> 。<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup> 中提到了各种各样的包，包括了安装环境时常见的<code>gulp</code>。</p><p><code>Webpack</code> 是前端打包工具（本文案例都会使用该打包工具）。在其配置文件 <code>webpack.config.js</code> 中设置**devtool[13]**即可生成 <code>Source Map</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>        <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&quot;source-map&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>devtool</strong>有 20 多种不同取值，分别生成不同类型的<code>Source Map</code>，可以根据需要进行配置。下文会详细介绍，这里不再赘述。</li></ul><p>（这就是为什么要在<code>webpack.main.config.js</code>添加它的原因）</p><h3 id="source-map大致原理">source-map大致原理<a class="header-anchor" href="#source-map大致原理">⁍</a></h3><p>打开了<code>souce-map</code>后调试，会在<code>dist/electron</code>底下生成<code>.map</code>文件</p><p>执行打包后，生成 <code>dist/electron</code> 文件夹，打开 <code>dist/main.js</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203022353720.png" alt="image-20220302235331692"></p><p>正是因为这句注释，标记了该文件的 <code>Source Map</code> 地址，浏览器才可以正确的找到源代码的位置。<code>sourceMappingURL</code> 指向 <code>Source Map</code> 文件的 <code>URL</code> 。</p><p><code>main.js.map</code>里 <code>mappings</code> 属性的值是：<code>AAAA; AACA, c</code> ，它的组成结构分成三层：</p><blockquote><p>第一层是<strong>行对应</strong>，以分号（;）分隔，分号间的内容对应一行线上代码。例如我们上面的例子里，没有分号（可以认为是省略了末尾的分号），则是因为线上代码被压缩成了一行。</p><p>第二层是<strong>位置对应</strong>，以逗号（,）分隔，逗号间的内容对应该行线上代码的某个位置。</p><p>第三层是<strong>位置映射</strong>，以<a href="http://en.wikipedia.org/wiki/Variable-length_quantity">VLQ编码</a>表示，代表该位置对应的源代码位置。</p></blockquote><p>通过进一步的解析，<code>AAAA</code> 和 <code>AAcA</code> 以及 <code>c</code> 都是代表了位置，正常来说，每个位置最多由 5 个字母组成，5 个字母的含义分别是：</p><ul><li>第一位，表示这个位置在（转换后的代码的）的第几列。</li><li>第二位，表示这个位置属于 sources 属性中的哪一个文件。</li><li>第三位，表示这个位置属于转换前代码的第几行。</li><li>第四位，表示这个位置属于转换前代码的第几列。</li><li>第五位，表示这个位置属于 names 属性中的哪一个变量。</li></ul><p>具体分析可以看参考文件<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">[2:2]</a></sup></p><h2 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h2><p>总之，可以知道<code>source-map</code>通过形成生成的JS代码对于源文件之间的映射，让我们可以对应到每一行、每一个变量，进行断点调试。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://juejin.cn/post/6847902221426917389">https://juejin.cn/post/6847902221426917389</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/467566753">弄懂 SourceMap，前端开发提效 100% - 知乎 (zhihu.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> vue </tag>
            
            <tag> VSCode </tag>
            
            <tag> Webpack </tag>
            
            <tag> source-map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-贪心算法</title>
      <link href="/augu1sto/cc1252d36e55/"/>
      <url>/augu1sto/cc1252d36e55/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识<a class="header-anchor" href="#基础知识">⁍</a></h2><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p><p><strong>什么时候用贪心</strong> ：如何验证可不可以用贪心算法————举反例</p><h3 id="贪心一般解题步骤">贪心一般解题步骤<a class="header-anchor" href="#贪心一般解题步骤">⁍</a></h3><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id="406-根据身高重建队列"><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height">406. 根据身高重建队列</a><a class="header-anchor" href="#406-根据身高重建队列">⁍</a></h2><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong></p></blockquote><p>先把people按身高hi排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]<br></code></pre></td></tr></table></figure><p>从前到后，对于每个person，把它往前挪到第ki个位置 --&gt; 直接用ArrayList实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] reconstructQueue(<span class="hljs-keyword">int</span>[][] people) &#123;<br>    <span class="hljs-comment">// 身高从大到小排（身高相同k小的站前面）</span><br>    Arrays.sort(<br>      people,<br>      (a, b) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];<br>      &#125;<br>    );<br>    <span class="hljs-comment">// 用Comparator实现</span><br>    <span class="hljs-comment">// Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123;</span><br>    <span class="hljs-comment">//     public int compare(int[] person1, int[] person2) &#123;</span><br>    <span class="hljs-comment">//         if (person1[0] != person2[0]) &#123;</span><br>    <span class="hljs-comment">//             return person2[0] - person1[0];</span><br>    <span class="hljs-comment">//         &#125; else &#123;</span><br>    <span class="hljs-comment">//             return person1[1] - person2[1];</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;);</span><br><br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] p : people) &#123;<br>      ans.add(p[<span class="hljs-number">1</span>], p);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[people.length][]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="253-会议室ⅱ">253. 会议室Ⅱ<a class="header-anchor" href="#253-会议室ⅱ">⁍</a></h2><p>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">示例 1：<br><br>输入：intervals = [[0,30],[5,10],[15,20]]<br>输出：2<br><br>示例 2：<br><br>输入：intervals = [[7,10],[2,4]]<br>输出：1<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><p>先按每个interval的第1个元素排序</p><ul><li>对所有会议，按照开始时间排升序；</li><li>用贪心算法，每来一个新的会议，遍历所有会议室，如果有空的会议室（该会议室的结束时间早于等于当前会议的开始时间），则作为当前最优的选择，更新该会议室的结束时间，并停止循环</li><li>如果一个可用的会议室都没有，则新增会议室，并更新该会议室的结束时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>    <span class="hljs-comment">// 先考虑特殊情况</span><br>    <span class="hljs-keyword">if</span> (intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从定义排序按照进入时间排序</span><br>    Arrays.sort(intervals, (v1, v2) -&gt; (v1[<span class="hljs-number">0</span>] - v2[<span class="hljs-number">0</span>]));<br>    <span class="hljs-comment">// 定义一个优先队列</span><br>    PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    <span class="hljs-comment">// 一个计数器</span><br>    <span class="hljs-keyword">int</span> meetingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] meeting : intervals)&#123;<br>        <span class="hljs-comment">//要是堆非空，当前会议的开始时间已经大于等于了最小的结束时间</span><br>        <span class="hljs-comment">// 这里就是要把所有已经结束的会议淘汰出去</span><br>        <span class="hljs-keyword">while</span> (!heap.isEmpty() &amp;&amp; meeting[<span class="hljs-number">0</span>] &gt;= heap.peek())&#123;<br>            heap.poll();<br>        &#125;<br>        <span class="hljs-comment">// 再把当前会议的结束时间加进去</span><br>        heap.add(meeting[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 堆里有的就是进行的会议的数量</span><br>        <span class="hljs-comment">// 谈话不断的看是不是最大的</span><br>        meetingCount = Math.max(meetingCount, heap.size());<br>    &#125;<br>    <span class="hljs-keyword">return</span> meetingCount;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⭐621-任务调度器">⭐<a href="https://leetcode-cn.com/problems/task-scheduler/description/">621. 任务调度器</a><a class="header-anchor" href="#⭐621-任务调度器">⁍</a></h2><p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2<br>输出：8<br>解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B<br>     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 0<br>输出：6<br>解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0<br>[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]<br>[&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;]<br>[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]<br>...<br>诸如此类<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n = 2<br>输出：16<br>解释：一种可能的解决方案是：<br>     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong></p></blockquote><p>我们首先考虑所有任务种类中执行次数最多的那一种，记它为 $\texttt{A}$，的执行次数为 $\textit{maxExec}$。</p><p>使用一个宽为 $n+1$ 的矩阵可视化地展现执行 $\texttt{A}$ 的时间点。</p><p>任务以行优先的顺序执行，没有任务的格子对应 CPU 的待命状态。</p><p><img src="https://assets.leetcode-cn.com/solution-static/621/1.png" alt="fig1"></p><p>冷却时间为 $n$，因此我们将所有的 $\texttt{A}$ 排布在矩阵的第一列，可以保证满足题目要求，同时这样时间也会最小</p><p>总时间： $$(n+1)(\textit{maxExec} - 1)+1$$</p><blockquote><p>列数*行数，但是最后一行只需要一个A就行了，所以是</p><p>列数*（行数-1）+1</p></blockquote><p>如果需要执行 $\textit{maxExec}$ 次（跟A次数相等）的任务的数量为 $\textit{maxCount}$，那么类似地可以得到对应的总时间为：</p><p>$$<br>(\textit{maxExec} - 1)(n + 1) + \textit{maxCount}<br>$$</p><blockquote><p>如果 $\textit{maxCount} &gt; n+1$ （即不同的任务数量超过了冷却时间+1）?</p><p>问题放大就是填「超出」$n+1$ 列。如图</p><p><img src="https://assets.leetcode-cn.com/solution-static/621/3.png" alt="fig3"></p><p><strong>如果我们填「超出」了 $n+1$ 列，任意两个相邻任务的执行间隔肯定也会至少为 $n$</strong></p><p>（可以把上图第二行的A挪到第1行的X，一次网上挪）</p><p>最后就是任务的总数 $|\textit{task}|$</p></blockquote><p><img src="https://assets.leetcode-cn.com/solution-static/621/2.png" alt="fig2"></p><p>剩余任务的执行次数一定都小于 $\textit{maxExec}$，从 <strong>倒数第二行开始</strong> ，按照 <strong>反向列优先的顺序（即先放入靠左侧的列，从下往上放）</strong> ，依次放入每一种任务，并且同一种任务需要连续地填入。</p><p>因为比$\textit{maxExec}$（即高度）小，所以同一行不可能出现两个同样的任务D/E/F，即满足题目要求，总时间还是不变的：<br>$$<br>(\textit{maxExec} - 1)(n + 1) + \textit{maxCount}<br>$$</p><hr><p>综上：</p><ul><li><p>如果我们没有填「超出」了 $n+1$ 列，那么图中存在 $0$ 个或多个位置没有放入任务，由于位置数量为 $(\textit{maxExec} - 1)(n + 1) + \textit{maxCount}$，因此有：</p><p>$$<br>|\textit{task}| &lt; (\textit{maxExec} - 1)(n + 1) + \textit{maxCount}<br>$$</p></li><li><p>如果我们填「超出」了 $n+1$ 列，那么同理有：</p><p>$$<br>|\textit{task}| &gt; (\textit{maxExec} - 1)(n + 1) + \textit{maxCount}<br>$$</p></li></ul><p>因此，在任意的情况下，需要的最少时间就是 $(\textit{maxExec} - 1)(n + 1) + \textit{maxCount}$ 和 $|\textit{task}|$ 中的较大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; freq = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        <span class="hljs-comment">// 最多的执行次数</span><br>        <span class="hljs-keyword">int</span> maxExec = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : tasks) &#123;<br>            <span class="hljs-keyword">int</span> exec = freq.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            freq.put(ch, exec);<br>            maxExec = Math.max(maxExec, exec);<br>        &#125;<br><br>        <span class="hljs-comment">// 具有最多执行次数的任务数量</span><br>        <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;<br>        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = freq.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;<br>            <span class="hljs-keyword">int</span> value = entry.getValue();<br>            <span class="hljs-keyword">if</span> (value == maxExec) &#123;<br>                ++maxCount;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Math.max((maxExec - <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>) + maxCount, tasks.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(|\textit{task}| + |\Sigma|)$，其中 $|\Sigma|$ 是数组 $\textit{task}$ 中出现任务的种类，在本题中任务用大写字母表示，因此 $|\Sigma|$ 不会超过 $26$。</li><li>空间复杂度：$O(|\Sigma|)$。</li></ul><blockquote><p>用二维数组代替map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tasks.length;i++)&#123;count[tasks[i]-<span class="hljs-string">&#x27;A&#x27;</span>]++;&#125;<br>        Arrays.sort(count);<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">25</span>;<br>        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;count[j]==count[<span class="hljs-number">25</span>])&#123;j--;&#125;<span class="hljs-comment">//从j+1到25并列最多</span><br>        <span class="hljs-keyword">return</span> Math.max(tasks.length,(n+<span class="hljs-number">1</span>)*(count[<span class="hljs-number">25</span>]-<span class="hljs-number">1</span>)+<span class="hljs-number">25</span>-j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（一）plus| Node16.8.0不降级安装Electron-vue+ElementUI开发环境</title>
      <link href="/augu1sto/8b4126167da0/"/>
      <url>/augu1sto/8b4126167da0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言<a class="header-anchor" href="#前言">⁍</a></h2><p>本文旨在{ %post_link Electron-vue开发实战（一）- 入门与安装(踩坑实录) %}中提及的基本安装方法上尝试改进，在不变换nodeJs环境的基础上，完成对Electron-vue环境和ElementUI/Element-theme的安装和配置</p><h2 id="配置vue脚手架和electron框架">配置vue脚手架和electron框架<a class="header-anchor" href="#配置vue脚手架和electron框架">⁍</a></h2><p>这部分与前文一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 如果你没有vue-cli的话需要全局安装</span><br>npm install -g vue-cli<br><span class="hljs-meta">#</span><span class="bash"> 然后使用vue-cli来安装electron-vue的模板</span><br>vue init simulatedgreg/electron-vue my-project<br></code></pre></td></tr></table></figure><p>另外还可以使用离线安装的方式进行<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，</p><p>下载模板源码</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/SimulatedGREG/electron-vue">https://github.com/SimulatedGREG/electron-vue</a></p><p>下载后解压存放在 <strong>用户目录/.vue-templates/</strong> 下（没有就创建，注意复数s），形成如下的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;用户目录&#125;/<br>  .vue-templates/<br>     electron-vue-master/（目录名随便，但是在待会儿init指定的时候需要一致）<br>       .github/<br>       template/<br>       ....<br></code></pre></td></tr></table></figure><p>之后就可以使用离线（offline）模式创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vue init --offline electron-vue-master electron-vue-demo # 名称和上述文件夹名称一致即可<br></code></pre></td></tr></table></figure><blockquote><p>根据向导创建的过程中有个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">? Use Sass / Scss? （是否使用Sass/Scss编译器）<br></code></pre></td></tr></table></figure><p>的问题，原文作者选了No。</p><p>我认为选No或许可以省掉一堆事，用css写样式文件就好啦。不过为了Element-theme定制主题，或许还是该选Yes。</p></blockquote><h2 id="package-json修改">package.json修改<a class="header-anchor" href="#package-json修改">⁍</a></h2><p>根据 <a href="#">Post not found: 【杂记】Node-sass、Node.JS版本管理以及其他</a>，我们不想再安装node-sass，而是改为dart-sass</p><p>修改package.json，去掉node-sass包，直接改成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;sass&quot;</span>: <span class="hljs-string">&quot;^1.49.9&quot;</span><br></code></pre></td></tr></table></figure><p>我项目中<code>package.json</code>的<code>dev-dependence</code>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;axios&quot;</span>: <span class="hljs-string">&quot;^0.21.0&quot;</span>,<br>  <span class="hljs-string">&quot;element-ui&quot;</span>: <span class="hljs-string">&quot;^2.15.6&quot;</span>,<br>  <span class="hljs-string">&quot;vue&quot;</span>: <span class="hljs-string">&quot;^2.5.16&quot;</span>,<br>  <span class="hljs-string">&quot;vue-electron&quot;</span>: <span class="hljs-string">&quot;^1.0.6&quot;</span>,<br>  <span class="hljs-string">&quot;vue-router&quot;</span>: <span class="hljs-string">&quot;^3.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;vuex&quot;</span>: <span class="hljs-string">&quot;^3.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;vuex-electron&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;ajv&quot;</span>: <span class="hljs-string">&quot;^6.5.0&quot;</span>,<br>  <span class="hljs-string">&quot;babel-core&quot;</span>: <span class="hljs-string">&quot;^6.26.3&quot;</span>,<br>  <span class="hljs-string">&quot;babel-eslint&quot;</span>: <span class="hljs-string">&quot;^8.2.3&quot;</span>,<br>  <span class="hljs-string">&quot;babel-loader&quot;</span>: <span class="hljs-string">&quot;^7.1.4&quot;</span>,<br>  <span class="hljs-string">&quot;babel-minify-webpack-plugin&quot;</span>: <span class="hljs-string">&quot;^0.3.1&quot;</span>,<br>  <span class="hljs-string">&quot;babel-plugin-istanbul&quot;</span>: <span class="hljs-string">&quot;^4.1.6&quot;</span>,<br>  <span class="hljs-string">&quot;babel-plugin-transform-runtime&quot;</span>: <span class="hljs-string">&quot;^6.23.0&quot;</span>,<br>  <span class="hljs-string">&quot;babel-preset-env&quot;</span>: <span class="hljs-string">&quot;^1.7.0&quot;</span>,<br>  <span class="hljs-string">&quot;babel-preset-stage-0&quot;</span>: <span class="hljs-string">&quot;^6.24.1&quot;</span>,<br>  <span class="hljs-string">&quot;babel-register&quot;</span>: <span class="hljs-string">&quot;^6.26.0&quot;</span>,<br>  <span class="hljs-string">&quot;cfonts&quot;</span>: <span class="hljs-string">&quot;^2.1.2&quot;</span>,<br>  <span class="hljs-string">&quot;chai&quot;</span>: <span class="hljs-string">&quot;^4.1.2&quot;</span>,<br>  <span class="hljs-string">&quot;chalk&quot;</span>: <span class="hljs-string">&quot;^4.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;copy-webpack-plugin&quot;</span>: <span class="hljs-string">&quot;^4.5.1&quot;</span>,<br>  <span class="hljs-string">&quot;cross-env&quot;</span>: <span class="hljs-string">&quot;^5.1.6&quot;</span>,<br>  <span class="hljs-string">&quot;css-loader&quot;</span>: <span class="hljs-string">&quot;^0.28.11&quot;</span>,<br>  <span class="hljs-string">&quot;del&quot;</span>: <span class="hljs-string">&quot;^3.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;devtron&quot;</span>: <span class="hljs-string">&quot;^1.4.0&quot;</span>,<br>  <span class="hljs-string">&quot;electron&quot;</span>: <span class="hljs-string">&quot;^10.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;electron-builder&quot;</span>: <span class="hljs-string">&quot;^22.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;electron-debug&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;electron-devtools-installer&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;element-theme-chalk&quot;</span>: <span class="hljs-string">&quot;^2.15.6&quot;</span>,<br>  <span class="hljs-string">&quot;eslint&quot;</span>: <span class="hljs-string">&quot;^4.19.1&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-config-standard&quot;</span>: <span class="hljs-string">&quot;^11.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-friendly-formatter&quot;</span>: <span class="hljs-string">&quot;^4.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-loader&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-plugin-html&quot;</span>: <span class="hljs-string">&quot;^4.0.3&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-plugin-import&quot;</span>: <span class="hljs-string">&quot;^2.12.0&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-plugin-node&quot;</span>: <span class="hljs-string">&quot;^6.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-plugin-promise&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>  <span class="hljs-string">&quot;eslint-plugin-standard&quot;</span>: <span class="hljs-string">&quot;^3.1.0&quot;</span>,<br>  <span class="hljs-string">&quot;file-loader&quot;</span>: <span class="hljs-string">&quot;^1.1.11&quot;</span>,<br>  <span class="hljs-string">&quot;html-webpack-plugin&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;inject-loader&quot;</span>: <span class="hljs-string">&quot;^4.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;karma&quot;</span>: <span class="hljs-string">&quot;^2.0.2&quot;</span>,<br>  <span class="hljs-string">&quot;karma-chai&quot;</span>: <span class="hljs-string">&quot;^0.1.0&quot;</span>,<br>  <span class="hljs-string">&quot;karma-coverage&quot;</span>: <span class="hljs-string">&quot;^1.1.2&quot;</span>,<br>  <span class="hljs-string">&quot;karma-electron&quot;</span>: <span class="hljs-string">&quot;^6.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;karma-mocha&quot;</span>: <span class="hljs-string">&quot;^1.3.0&quot;</span>,<br>  <span class="hljs-string">&quot;karma-sourcemap-loader&quot;</span>: <span class="hljs-string">&quot;^0.3.7&quot;</span>,<br>  <span class="hljs-string">&quot;karma-spec-reporter&quot;</span>: <span class="hljs-string">&quot;^0.0.32&quot;</span>,<br>  <span class="hljs-string">&quot;karma-webpack&quot;</span>: <span class="hljs-string">&quot;^3.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;listr&quot;</span>: <span class="hljs-string">&quot;^0.14.3&quot;</span>,<br>  <span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>: <span class="hljs-string">&quot;0.4.0&quot;</span>,<br>  <span class="hljs-string">&quot;mocha&quot;</span>: <span class="hljs-string">&quot;^5.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;node-loader&quot;</span>: <span class="hljs-string">&quot;^0.6.0&quot;</span>,<br>  <span class="hljs-string">&quot;require-dir&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;sass&quot;</span>: <span class="hljs-string">&quot;^1.49.9&quot;</span>,<br>  <span class="hljs-string">&quot;sass-loader&quot;</span>: <span class="hljs-string">&quot;^7.0.3&quot;</span>,<br>  <span class="hljs-string">&quot;spectron&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>  <span class="hljs-string">&quot;style-loader&quot;</span>: <span class="hljs-string">&quot;^0.21.0&quot;</span>,<br>  <span class="hljs-string">&quot;url-loader&quot;</span>: <span class="hljs-string">&quot;^1.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;vue-html-loader&quot;</span>: <span class="hljs-string">&quot;^1.2.4&quot;</span>,<br>  <span class="hljs-string">&quot;vue-loader&quot;</span>: <span class="hljs-string">&quot;^15.2.4&quot;</span>,<br>  <span class="hljs-string">&quot;vue-style-loader&quot;</span>: <span class="hljs-string">&quot;^4.1.0&quot;</span>,<br>  <span class="hljs-string">&quot;vue-template-compiler&quot;</span>: <span class="hljs-string">&quot;^2.5.16&quot;</span>,<br>  <span class="hljs-string">&quot;webpack&quot;</span>: <span class="hljs-string">&quot;^4.15.1&quot;</span>,<br>  <span class="hljs-string">&quot;webpack-cli&quot;</span>: <span class="hljs-string">&quot;^3.0.8&quot;</span>,<br>  <span class="hljs-string">&quot;webpack-dev-server&quot;</span>: <span class="hljs-string">&quot;^3.1.4&quot;</span>,<br>  <span class="hljs-string">&quot;webpack-hot-middleware&quot;</span>: <span class="hljs-string">&quot;^2.22.2&quot;</span>,<br>  <span class="hljs-string">&quot;webpack-merge&quot;</span>: <span class="hljs-string">&quot;^4.1.3&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输入<code>yarn</code>命令安装即可</p><h2 id="安装element-ui和element-theme相关">安装Element UI和Element-theme相关<a class="header-anchor" href="#安装element-ui和element-theme相关">⁍</a></h2><h3 id="yarn">yarn<a class="header-anchor" href="#yarn">⁍</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add element-ui --dev<br>yarn add element-theme-chalk --dev<br>yarn add element-theme --dev<br></code></pre></td></tr></table></figure><p>把<code>element-theme</code>放到最后写，因为它需要gulp-sass–&gt;node-sass依赖，所以安装途中会报错</p><p>事实上<code>--dev</code>不加也可以，因为报错的原因，根本存不进<code>package.json</code></p><p>来到熟悉的错误，大致就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">GULPXXXXXXXXXXX<br>GULPXXXXXXXXXXX<br></code></pre></td></tr></table></figure><p>之类的一长串（不太记得），涉及到说gulp-sass的依赖项node-sass找不到MSbuild环境之类的</p><h3 id="重新yarn安装element-theme">重新yarn安装element-theme<a class="header-anchor" href="#重新yarn安装element-theme">⁍</a></h3><p>思路上来讲就是把gulp-sass依赖的node-sass换成dart-sass，但执行起来又变得奇怪？</p><ol><li>进入<code>node_modules/element-theme</code>文件夹</li><li>删除<code>package.json</code>中<code>gulp-sass</code>依赖</li><li><code>yarn</code></li><li><code>yarn add gulp-sass --dev</code></li></ol><p>我的本意是在装<code>gulp-sass</code>的过程中再排查问题，或者装到一半修改它的依赖重装；但一点错都没报，直接成功了。。。</p><h3 id="解决gracefule-fs错误">解决<code>gracefule-fs</code>错误<a class="header-anchor" href="#解决gracefule-fs错误">⁍</a></h3><p>在<a href="#">Post not found: Electron-vue开发实战（三）- Render进程开发</a>中提到如下错误：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202271632149.png" alt="image-20220227163239063"></p><p>网上大部分的解决方案是降级node到11.15.0或以下，但我这样做又带来了其他问题（因为<code>element-theme</code>中对<code>node</code>的要求是大于12？）</p><p>有一位作者提到了可以升级<code>graceful-fs</code>，故我做如下尝试：</p><ol><li><p>进入<code>node_modules\element-theme\node_modules\vinyl-fs</code></p></li><li><p>修改<code>package.json</code>中<code>graceful-fs</code>的版本为<code>4.0.0</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202281429924.png" alt="image-20220228142938845"></p></li><li><p>在当前文件夹下<code>yarn</code></p></li></ol><h3 id="解决chalk错误">解决<code>chalk</code>错误<a class="header-anchor" href="#解决chalk错误">⁍</a></h3><p>执行<code>node_modules/.bin/et -i</code>还是会报错</p><p>很抱歉没有截图，但错误提示很明显，说是这一行出错：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202281435152.png" alt="image-20220228143540089"></p><p>根据<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，需要将chalk降级到<code>4.0.0</code></p><ol><li>进入文件夹<code>node_modules\element-theme\node_modules\run-sequence</code></li><li>修改<code>package.json</code>中<code>chalk</code>的版本为<code>4.0.0</code><s>(怎么都要4.0.0)</s></li><li><code>yarn</code></li></ol><h3 id="运行et">运行et<a class="header-anchor" href="#运行et">⁍</a></h3><p>至此，所有问题应该都解决了，在项目根目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node_modules/.bin/et -i<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202281440250.png" alt="image-20220228144038188"></p><p>(因为已经生成了，所以是已存在的提示)</p><p>项目目录中也终于出现了</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202281441015.png" alt="image-20220228144154945"></p><p>本人流下感动的热泪x</p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=26f13db76d2762d0803ea4b790ed0849/eb5212a88226cffc910a3d26b7014a90f603ea1f.jpg" alt="img" style="zoom:25%;" /><p>希望日后编译生成的命令也能有效（先不尝试了）</p><h2 id="其他文件修改">其他文件修改<a class="header-anchor" href="#其他文件修改">⁍</a></h2><h3 id="electron-vue-dev-runner-js">.electron-vue\dev-runner.js<a class="header-anchor" href="#electron-vue-dev-runner-js">⁍</a></h3><p>取消这一行注释</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202281449821.png" alt="image-20220228144930749"></p><h3 id="引入dev-tools">引入dev-tools<a class="header-anchor" href="#引入dev-tools">⁍</a></h3><p><code>src\main\index.dev.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This file is used specifically and only for development. It installs</span><br><span class="hljs-comment"> * `electron-debug` &amp; `vue-devtools`. There shouldn&#x27;t be any need to</span><br><span class="hljs-comment"> *  modify this file, but it can be used to extend your development</span><br><span class="hljs-comment"> *  environment.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* eslint-disable */</span><br><br><span class="hljs-comment">// Install `electron-debug` with `devtron`</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron-debug&#x27;</span>)(&#123; <span class="hljs-attr">showDevTools</span>: <span class="hljs-literal">true</span> &#125;)<br><br><span class="hljs-keyword">const</span>&#123;BrowserWindow&#125;=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;electron&quot;</span>)<br><span class="hljs-comment">// Install `vue-devtools`</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>).app.on(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// await installExtension(VUEJS_DEVTOOLS);</span><br>    <span class="hljs-comment">// 新增的：安装vue-devtools</span><br>    <span class="hljs-keyword">const</span> &#123; session &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;electron&quot;</span>);<br>    <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>    session.defaultSession.loadExtension(<br>      path.resolve(__dirname, <span class="hljs-string">&quot;E:/download/devtools-5.1.1/shells/chrome/&quot;</span>)  <span class="hljs-comment">//这个是刚刚build好的插件目录</span><br>    ); <br><span class="hljs-comment">// 这个版本里没有addDevToolsExtension方法了</span><br><span class="hljs-comment">// BrowserWindow.addDevToolsExtension(path.resolve(__dirname, &quot;../../devTools/chrome&quot;)  );</span><br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Vue Devtools failed to install:&quot;</span>, e.toString());<br>  &#125;<br><br>&#125;)<br><br><span class="hljs-comment">// Require `main` process to boot app</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="创建window时添加开启remote">创建window时添加开启remote<a class="header-anchor" href="#创建window时添加开启remote">⁍</a></h3><p>看到好多人这么做，我尚未搞清楚原理</p><p><code>src\main\index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建窗口</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Initial window options</span><br><span class="hljs-comment">   */</span><br>  mainWindow = <span class="hljs-keyword">new</span> BrowserWindow(&#123;<br>  <span class="hljs-comment">//...</span><br><br>    <span class="hljs-attr">webPreferences</span>: &#123;<br>      <span class="hljs-comment">// 开启node</span><br>      <span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">contextIsolation</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-comment">// 开启remote</span><br>      <span class="hljs-attr">enableRemoteModule</span>: <span class="hljs-literal">true</span><br><br>    &#125;<br>  &#125;)<br></code></pre></td></tr></table></figure><h3 id="tasks错误">tasks错误<a class="header-anchor" href="#tasks错误">⁍</a></h3><p><code>yarn run build</code>报错</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202251827372.png" alt=""></p><p>注释掉 .electron-vue/build.js中相关代码就行了（记得运行时开代理）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202251829772.png" alt="image-20220225182906710"></p><h3 id="build资源下载出错">build资源下载出错<a class="header-anchor" href="#build资源下载出错">⁍</a></h3><ol><li>开代理</li><li>提前下载好卡住的资源，放在<code>C:\Users\[Username]\AppData\Local\electron-builder\Cache</code>下面<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li></ol><p>应该就差不多了</p><h2 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h2><p>在两台设备上装了两次，绕了一点弯路，不过应该是都成功了。</p><p>不能保证方法百分百正确，也不知道如何将子依赖的依赖写入父依赖，使得安装可以一键进行。</p><p>总之，也算是加深了理解，获得了一些方法论层面的知识。</p><p>仅供参考。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/165416035">Electron+Vue+ElementUI开发环境搭建 - 知乎 (zhihu.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://blog.csdn.net/hh3167253066/article/details/121569274">最新chalk5.0.0不支持在nodejs中require()导入，解决方法_hh3167253066的博客-CSDN博客</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>[<a href="https://www.jianshu.com/p/ef7962a2edf6">Electron] electron-builder 打包下载依赖慢/失败 - 简书 (jianshu.com)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> vue </tag>
            
            <tag> Node.js </tag>
            
            <tag> ElementUI </tag>
            
            <tag> dart-sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂记】Node-sass、Node.JS版本管理以及其他</title>
      <link href="/augu1sto/24ed28881418/"/>
      <url>/augu1sto/24ed28881418/</url>
      
        <content type="html"><![CDATA[<p>试图在另一台设备上就着node v16重新配置搭建了一遍electron-vue的环境，又踩了一些坑，不过理解也稍微深了一点。</p><p>总的概括就是——活用修改<code>package.json</code>。</p><h2 id="node-js降级？">Node.js降级？<a class="header-anchor" href="#node-js降级？">⁍</a></h2><p>看到许多包出问题时，网上的解答大多都是给Node.js降级，我一开始也是这么做的，包需要哪个版本的node，我就装哪个版本的。</p><p>但是这样也带来一些问题——</p><ul><li>之前装一个什么东西说需要node v10，但是后面又变成v12，运行项目时仍是v10</li><li>Element-theme安装时告诉我要node v12以上，但运行<code>et -i</code>报错我又需要v11及以下，事实上因为本来是v12的环境，就还是会报错</li></ul><p>所以现在我更倾向于升包的等级。</p><p>在<code>package.json</code>中将某些包升级，再重新<code>yarn</code></p><p>但有些包是依赖关系，比如说安装<code>a</code>包里的<code>b</code>包出错，</p><p>事实上，可以修改<code>node_modules/a/package.json</code>里面<code>b</code>包的版本，然后在<code>node_modules/a</code>目录下执行<code>yarn</code></p><h2 id="node-sass">node-sass<a class="header-anchor" href="#node-sass">⁍</a></h2><p>这个无疑是装vue环境时最令人头秃的东西了，不仅需要你的nodejs版本对应，还需要你有msbuild v15和python2！</p><p>当然这些都有解决方法。</p><p>但在我实际搜索中发现，其实或许根本不需要<code>node-sass</code>。</p><p><code>dart-sass</code>作为更稳定、安装更方便的将 <code>sass</code> 编译成 <code>css</code> 的工具，是<code>sass</code>官方目前主推的，也会是未来的发展方向。</p><p>在<code>pakage.json</code>里可以先将<code>node-sass</code>去除。然后通过<code>yarn add sass -dev</code>的方式，将<code>dart-sass</code>再加进去。</p><h2 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h2><p>作为node开发刚起步的小白，这只是我自己的一点思考，不代表一定正确，不过应该也会是一种解决方法。</p>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.JS </tag>
            
            <tag> Node-sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（三）| Render进程开发</title>
      <link href="/augu1sto/ab2a829608be/"/>
      <url>/augu1sto/ab2a829608be/</url>
      
        <content type="html"><![CDATA[<p>对于<code>electron-vue</code>而言，renderer进程其实大部分就是在写我们平时常写的前端页面</p><h2 id="安装element-ui">安装Element UI<a class="header-anchor" href="#安装element-ui">⁍</a></h2><h3 id="element-ui">Element UI<a class="header-anchor" href="#element-ui">⁍</a></h3><p>Element UI是饿了么开发的一套开源的基于Vue的UI框架，属于Javascript UI框架，与CSS UI框架（Bootstrap等）不同，除了提供CSS的修饰，还提供了更加遍历的控件操作方法。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>通过<a href="https://element.eleme.cn/#/zh-CN/component/installation">组件 | Element</a>快速查看可用的组件。</p><h3 id="安装element-ui并更换主题">安装Element UI并更换主题<a class="header-anchor" href="#安装element-ui并更换主题">⁍</a></h3><p><a href="https://element.eleme.cn/#/zh-CN/component/custom-theme">组件 | Element</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add element-ui<br></code></pre></td></tr></table></figure><h4 id="未成功-安装主题工具">(未成功)安装主题工具<a class="header-anchor" href="#未成功-安装主题工具">⁍</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add element-theme --dev<br></code></pre></td></tr></table></figure><p><strong>安装白垩主题</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add element-theme-chalk -D<br></code></pre></td></tr></table></figure><p><strong>初始化变量文件</strong></p><p>主题生成工具安装成功后，如果全局安装可以在命令行里通过 <code>et</code> 调用工具，如果安装在当前目录下，需要通过 <code>node_modules/.bin/et</code> 访问到命令。执行 <code>-i</code> 初始化变量文件。默认输出到 <code>element-variables.scss</code>，当然你可以传参数指定文件输出目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">et -i [可以自定义变量文件]<br></code></pre></td></tr></table></figure><p>非全局安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node_modules/.bin/et -i<br></code></pre></td></tr></table></figure><p>报错<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202271632149.png" alt="image-20220227163239063"></p><p>graceful-fs 与 node 版本不兼容</p><p>(各种处理见 { % post_link “Electron-vue开发实战（一）plus- Node16.8.0不降级安装Electron-vue+ElementUI开发环境” %} )</p><h4 id="其他主题">其他主题<a class="header-anchor" href="#其他主题">⁍</a></h4><p><code>element-ink-theme</code>:  <a href="https://ink.elpsy.cn/guide/#installation">指南 | Ink (elpsy.cn)</a></p><h3 id="引入-按需引入（后期待改）">引入/按需引入（后期待改）<a class="header-anchor" href="#引入-按需引入（后期待改）">⁍</a></h3><p><a href="https://element.eleme.cn/#/zh-CN/component/quickstart">组件 | Element</a></p><p>在<code>src/renderer/main.js</code>中写入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><br>Vue.use(ElementUI)<br><br><span class="hljs-comment">/* eslint-disable no-new */</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> h(App),<br>  <span class="hljs-attr">components</span>: &#123; App &#125;,<br>  router,<br>  store,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span><br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="render进程开发">Render进程开发<a class="header-anchor" href="#render进程开发">⁍</a></h2><p>在开发模式下，由于使用的是<code>webpack-dev-server</code>开启的服务器，所以<code>BrowserWindow</code>加载的是来自于类似<code>http://localhost:9080</code>这样的地址的页面。</p><p>而在生产模式下，却是使用的<code>file://</code>的协议，比如<code>file://$&#123;__dirname&#125;/index.html</code>来指定窗口加载的页面。</p><p>假如我有一个子路由地址为<code>child</code>。如果不启用Hash模式，在开发模式下没啥问题，<code>http://localhost:9080/child</code>，但是在生产模式下，<code>file://$&#123;__dirname&#125;/index.html/child</code>却是无法匹配的一条路径。因此在electron下，<code>vue-router</code>请不要使用<code>history</code>模式，而使用默认的<code>hash</code>模式。</p><blockquote><p>👆 见Picgo <code>src\main\apis\app\window\constants.ts</code></p></blockquote><h3 id="自定义titlebar">自定义titlebar<a class="header-anchor" href="#自定义titlebar">⁍</a></h3><p>在创建的<code>BrowserWindow</code>的配置里加上一句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">titleBarStyle: <span class="hljs-string">&#x27;hidden&#x27;</span>,<br></code></pre></td></tr></table></figure><p>然后你就可以自行在renderer进程的页面里模拟一个顶部的<code>titlebar</code>了</p><p>在css样式里添加拖拽/不可拖拽</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.fake-title-bar</span> &#123; <span class="hljs-comment">// bar</span><br>  -webkit-app-region: drag;<br>&#125;<br><br><span class="hljs-selector-class">.handle-bar</span> &#123; <span class="hljs-comment">// 右边的缩小/关闭按钮</span><br>  -webkit-app-region: no-drag;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main进程和renderer进程的通信">main进程和renderer进程的通信<a class="header-anchor" href="#main进程和renderer进程的通信">⁍</a></h2><h3 id="remote模块：渲染器进程访问主进程">remote模块：渲染器进程访问主进程<a class="header-anchor" href="#remote模块：渲染器进程访问主进程">⁍</a></h3><p>remote模块是electron为了让一些原本在Main进程里运行的模块也能在renderer进程里运行而创建的。</p><p>在<code>electron-vue</code>里内置了<code>vue-electron</code>这个模块，可以在vue里很方便的使用诸如<code>this.$electron.remote.xxx</code>来使用remote的模块。</p><p><mark>注意路径转义</mark></p><h4 id="shell">shell<a class="header-anchor" href="#shell">⁍</a></h4><p>让默认图片应用打开一张图片、让默认浏览器打开一个url。</p><p>具体api： <a href="https://www.electronjs.org/zh/docs/latest/api/shell">shell | Electron (electronjs.org)</a></p><h4 id="dialog">dialog<a class="header-anchor" href="#dialog">⁍</a></h4><p>打开原生对话框</p><p>api：<a href="https://www.electronjs.org/zh/docs/latest/api/dialog">dialog | Electron (electronjs.org)</a></p><p><strong>实例：</strong></p><p>需求：点击按钮，弹出hexo文章的根目录，选择相应文章，用默认应用（即typora打开）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">openFile () &#123;<br>  <span class="hljs-built_in">this</span>.$electron.remote.dialog<br>    .showOpenDialog(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;打开文件&#x27;</span>,<br>      <span class="hljs-attr">defaultPath</span>: <span class="hljs-string">&#x27;[hexo_root]\\source\\_posts&#x27;</span>,<br>      <span class="hljs-attr">properties</span>: [<span class="hljs-string">&#x27;openFile&#x27;</span>]<br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(result.filePaths) <span class="hljs-comment">// 获得打开的文件路径</span><br>      <span class="hljs-built_in">this</span>.$electron.remote.shell.openPath(result.filePaths[<span class="hljs-number">0</span>])<br>    &#125;)<br>    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(err)<br>    &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="深入remote模块">深入remote模块<a class="header-anchor" href="#深入remote模块">⁍</a></h3><blockquote><p>注意：</p><p>remote即将被electron弃用，PicGo项目中实际也并没有用到这个模块</p></blockquote><p>remote模块未主进程可以访问的模块创建一个镜像，以此提供一个代理，将渲染器进程需要执行的操作委托给主进程执行。</p><p>当调用remote对象的方法或属性是，它会想主进程发送一条同步消息，在主进程中执行相应的方法或属性，然后将结果发送回渲染器进程</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203021642985.jpg" alt=""></p><h3 id="从主进程向渲染器进程发送内容">从主进程向渲染器进程发送内容<a class="header-anchor" href="#从主进程向渲染器进程发送内容">⁍</a></h3><h4 id="webcontents">webContents<a class="header-anchor" href="#webcontents">⁍</a></h4><p><code>webContents</code>其实是<code>BrowserWindow</code>实例的一个属性，它存储了调用时的Web浏览器窗口对象，管理者渲染器进程中Web页面的生命周期，触发各种事件。</p><p>也就是如果我们需要在<code>main</code>进程里给某个窗口某个页面发送消息，则必须通过<code>win.webContents.send()</code>方法来发送。</p><h3 id="ipcmain和ipcrenderer">ipcMain和ipcRenderer<a class="header-anchor" href="#ipcmain和ipcrenderer">⁍</a></h3><p>通过<code>ipcMain</code>和<code>ipcRenderer</code>来实现非父子组件通信</p><p>其中<code>ipcMain</code>是在<code>main</code>进程里使用的，而<code>ipcRenderer</code>是在<code>renderer</code>进程里使用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// In main process.</span><br><span class="hljs-keyword">const</span> &#123;ipcMain&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br>ipcMain.on(<span class="hljs-string">&#x27;asynchronous-message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, arg</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(arg)  <span class="hljs-comment">// prints &quot;ping&quot;</span><br>  event.sender.send(<span class="hljs-string">&#x27;asynchronous-reply&#x27;</span>, <span class="hljs-string">&#x27;pong&#x27;</span>)<br>&#125;)<br><br>ipcMain.on(<span class="hljs-string">&#x27;synchronous-message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, arg</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(arg)  <span class="hljs-comment">// prints &quot;ping&quot;</span><br>  event.returnValue = <span class="hljs-string">&#x27;pong&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// In renderer process (web page).</span><br><span class="hljs-keyword">const</span> &#123;ipcRenderer&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(ipcRenderer.sendSync(<span class="hljs-string">&#x27;synchronous-message&#x27;</span>, <span class="hljs-string">&#x27;ping&#x27;</span>)) <span class="hljs-comment">// prints &quot;pong&quot;</span><br><br>ipcRenderer.on(<span class="hljs-string">&#x27;asynchronous-reply&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, arg</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(arg) <span class="hljs-comment">// prints &quot;pong&quot;</span><br>&#125;)<br>ipcRenderer.send(<span class="hljs-string">&#x27;asynchronous-message&#x27;</span>, <span class="hljs-string">&#x27;ping&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中<code>ipcMain</code>只有监听来自<code>ipcRenderer</code>的某个事件后才能返回给<code>ipcRenderer</code>值。而<code>ipcRenderer</code>既可以收，也可以发。</p><p><code>ipcMain</code>无法主动发消息给<code>ipcRenderer</code>。因为ipcMain只有<code>.on()</code>方法没有<code>.send()</code>的方法。(要用webContent)</p><h4 id="📜使用ipcmain和ipcrender实现伪窗口的关闭和最小化">📜使用ipcMain和ipcRender实现伪窗口的关闭和最小化<a class="header-anchor" href="#📜使用ipcmain和ipcrender实现伪窗口的关闭和最小化">⁍</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; app, BrowserWindow, Menu, ipcMain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron&#x27;</span><br><br><br>ipcMain.on(<span class="hljs-string">&#x27;minimize_w&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = BrowserWindow.getFocusedWindow()<br>  <span class="hljs-built_in">window</span>.minimize()<br>&#125;)<br><br>ipcMain.on(<span class="hljs-string">&#x27;close_w&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = BrowserWindow.getFocusedWindow()<br>  <span class="hljs-keyword">if</span> (process.platform === <span class="hljs-string">&#x27;linux&#x27;</span>) &#123;<br>    <span class="hljs-built_in">window</span>.hide()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">window</span>.close()<br>    app.quit()<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--Entry.vue--&gt;<br>&lt;template&gt;<br>&lt;!--...--&gt;<br>        &lt;i class=&quot;el-icon-minus&quot; @click=&quot;minimizeWindow&quot;&gt;&lt;/i&gt;<br>        &lt;i class=&quot;el-icon-close&quot; @click=&quot;closeWindow&quot;&gt;&lt;/i&gt;<br>&lt;!--...--&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  methods: &#123;<br>    minimizeWindow () &#123;<br>      const &#123; ipcRenderer &#125; = require(&#x27;electron&#x27;)<br>      ipcRenderer.send(&#x27;minimize_w&#x27;)<br>    &#125;,<br><br>    closeWindow () &#123;<br>      const &#123; ipcRenderer &#125; = require(&#x27;electron&#x27;)<br>      ipcRenderer.send(&#x27;close_w&#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>注意script里面的函数要按照html代码里引用的顺序来写</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>朱建昕《Spring Boot+Vue开发实战》 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://blog.csdn.net/qq_34447899/article/details/120748888">https://blog.csdn.net/qq1808814025/article/details/120234560</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> Electrion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（二）| Main进程开发</title>
      <link href="/augu1sto/79d34a519ec6/"/>
      <url>/augu1sto/79d34a519ec6/</url>
      
        <content type="html"><![CDATA[<h2 id="认识目录">认识目录<a class="header-anchor" href="#认识目录">⁍</a></h2><p>使用vue-cli创建的electron工程文件目录大体结构<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">my-project<br>├─ .electron-vue<br>│  └─ &lt;build/development&gt;.js files<br>├─ build<br>│  └─ icons/<br>├─ dist<br>│  ├─ electron/<br>│  └─ web/<br>├─ node_modules/<br>├─ src<br>│  ├─ main <span class="hljs-comment"># 主进程</span><br>│  │  ├─ index.dev.js <span class="hljs-comment"># 开发模式</span><br>│  │  └─ index.js <span class="hljs-comment"># 主进程</span><br>│  ├─ renderer <span class="hljs-comment"># 渲染进程</span><br>│  │  ├─ components/<br>│  │  ├─ router/<br>│  │  ├─ store/<br>│  │  ├─ App.vue<br>│  │  └─ main.js<br>│  └─ index.ejs<br>├─ static/ <span class="hljs-comment"># 资源文件</span><br>├─ <span class="hljs-built_in">test</span><br>│  ├─ e2e<br>│  │  ├─ specs/<br>│  │  ├─ index.js<br>│  │  └─ utils.js<br>│  ├─ unit<br>│  │  ├─ specs/<br>│  │  ├─ index.js<br>│  │  └─ karma.config.js<br>│  └─ .eslintrc<br>├─ .babelrc<br>├─ .eslintignore<br>├─ .eslintrc.js<br>├─ .gitignore<br>├─ package.json <span class="hljs-comment"># 配置文件</span><br>└─ README.md<br></code></pre></td></tr></table></figure><p>electron有多种文件结构，例如将所有应用的代码都放在app目录中，资源文件位于static目录</p><p>我们重点关注的是主进程、渲染进程和配置文件，其中开发主要集中在渲染进程中</p><h2 id="package-json-3">package.json[^3]<a class="header-anchor" href="#package-json-3">⁍</a></h2><p>许多Node项目中都会有package.json清单文件，它是electron项目的依赖文件，核心参数之一是应用的主入口。</p><p>对于纯electron应用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;main&quot;</span>:<span class="hljs-string">&quot;./app/main.js&quot;</span>,<br>    <span class="hljs-attr">&quot;scripts&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;start&quot;</span>:<span class="hljs-string">&quot;electron .&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>dist目录全称是distribution。在某些框架中，因为开发和发布是的内容或者代码形式是不一样的（比如利用Grunt压缩等等)，这时候就需要一个存放最终发布版本的代码，这就是dist文件夹的用处。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><hr><p>上面的代码根据<a href="%E3%80%8AElectron%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%AC2%E7%AB%A0">3</a>中对electron应用的讲解，electron-vue框架搭建出来，这里显示的有些不一样，可能涉及到发布/开发模式的问题？不知道以后编译啊之类的会不会就有区别；看PicGo的项目这里差别也很大</p></blockquote><h2 id="主进程-src-main">主进程 <code>src/main</code><a class="header-anchor" href="#主进程-src-main">⁍</a></h2><p>在<a href="%E3%80%8AElectron%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%AC2%E7%AB%A0">3</a>的纯electron应用中，它将主进程写入<code>main.js</code>文件中，作为项目的入口；而在electron-vue框架中，主进程在<code>src/main/index.js</code>中。代码的整体结构是相似的。</p><p>在main进程中主要需要掌握以下知识</p><h3 id="app模块"><a href="https://electronjs.org/docs/api/app">app</a>模块<a class="header-anchor" href="#app模块">⁍</a></h3><p><code>app</code>可以处理应用的生命周期与配置，是electron应用的骨架。它掌管着整个应用的生命周期钩子，以及很多其他事件钩子。</p><p>引用模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// method 1</span><br><span class="hljs-keyword">const</span> &#123;app&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><span class="hljs-comment">// method 2 (electron-vue框架内置)</span><br><span class="hljs-keyword">import</span> &#123; app &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p>app的常用生命周期钩子如下：</p><ul><li><p><code>will-finish-launching</code> 在应用完成基本启动进程之后触发</p></li><li><p><code>ready</code> 当electron完成初始化后触发（<mark>必须</mark>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 创建窗口</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Initial window options</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">// ...</span><br>&#125;<br><br>app.on(<span class="hljs-string">&#x27;ready&#x27;</span>, createWindow) <span class="hljs-comment">// 调用createWindow创建窗口</span><br></code></pre></td></tr></table></figure></li><li><p><code>window-all-closed</code> 所有窗口都关闭的时候触发，在windows和linux里，所有窗口都退出的时候<strong>通常</strong>是应用退出的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.on(<span class="hljs-string">&#x27;window-all-closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (process.platform !== <span class="hljs-string">&#x27;darwin&#x27;</span>) &#123; <span class="hljs-comment">// 当操作系统不是darwin（macOS）的话</span><br>    app.quit() <span class="hljs-comment">// 退出应用</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><code>before-quit</code> 退出应用之前的时候触发</p></li><li><p><code>will-quit</code> 即将退出应用的时候触发</p></li><li><p><code>quit</code> 应用退出的时候触发(用法见<code>window-all-closed</code>)</p></li></ul></li><li><p>事件钩子</p><ul><li><p><code>active</code>（仅macOS）当应用处于激活状态时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">app.on(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (mainWindow === <span class="hljs-literal">null</span>) &#123;<br>    createWindow()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><code>browser-window-created</code> 当一个BrowserWindow被创建的时候</p></li><li><p><code>browser-window-focus</code> 当一个BrowserWindow处于激活状态的时候</p></li></ul><p>这些钩子需要配合一些具体场景来做出具体的操作。比如当一个BrowserWindow处于激活状态的时候修改窗口的title值。</p></li><li><p>其他常用的方法：</p><ul><li><p><code>app.quit()</code> 用于退出应用</p></li><li><p><code>app.getPath(name)</code> 用于获取一些系统目录，对于存放应用的配置文件等很有用</p></li><li><p><code>app.focus()</code> 用于激活应用，不同系统激活逻辑<a href="https://electronjs.org/docs/api/app#appfocus">不一样</a></p></li></ul></li></ul><p>而我们通常会在<code>ready</code>的时候执行创建应用窗口、创建应用菜单、创建应用快捷键等初始化操作。而在<code>will-quit</code>或者<code>quit</code>的时候执行一些清空操作，比如解绑应用快捷键。</p><h3 id="browserwindow渲染器进程"><a href="https://www.electronjs.org/zh/docs/latest/api/browser-window">BrowserWindow</a>渲染器进程<a class="header-anchor" href="#browserwindow渲染器进程">⁍</a></h3><p>主进程可以使用<code>BrowserWindow</code>模块创建多个独立的、互相隔离的渲染器进程（即应用窗口）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; app, BrowserWindow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron&#x27;</span><br></code></pre></td></tr></table></figure><p>创建<code>BrowserWindow</code>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mainWindow = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// ...</span><br>mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br></code></pre></td></tr></table></figure><h4 id="常见配置和方法">常见配置和方法<a class="header-anchor" href="#常见配置和方法">⁍</a></h4><p>可以通过添加参数来改变配置</p><p>一个BrowserWindow的常用配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-built_in">window</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">window</span> = <span class="hljs-keyword">new</span> BrowserWindow(&#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">900</span>, <span class="hljs-comment">// 高</span><br>    <span class="hljs-attr">width</span>: <span class="hljs-number">400</span>, <span class="hljs-comment">// 宽</span><br>    <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 创建后是否显示</span><br>    <span class="hljs-attr">frame</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否创建frameless窗口</span><br>    <span class="hljs-attr">fullscreenable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否允许全屏</span><br>    <span class="hljs-attr">center</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否出现在屏幕居中的位置</span><br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#fff&#x27;</span> <span class="hljs-comment">// 背景色，用于transparent和frameless窗口</span><br>    <span class="hljs-attr">titleBarStyle</span>: <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-comment">// 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等</span><br>    <span class="hljs-attr">resizable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否允许拉伸大小</span><br>    <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否是透明窗口（仅macOS）</span><br>    <span class="hljs-attr">vibrancy</span>: <span class="hljs-string">&#x27;ultra-dark&#x27;</span>, <span class="hljs-comment">// 窗口模糊的样式（仅macOS）</span><br>    <span class="hljs-attr">webPreferences</span>: &#123;<br>      <span class="hljs-attr">backgroundThrottling</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 当页面被置于非激活窗口的时候是否停止动画和计时器</span><br>    &#125;<br>    <span class="hljs-comment">// ... 以及其他可选配置</span><br>  &#125;)<br><br>  <span class="hljs-built_in">window</span>.loadURL(url)<br><br>  <span class="hljs-built_in">window</span>.on(<span class="hljs-string">&#x27;closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">window</span> = <span class="hljs-literal">null</span> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>PicGo主窗口写法参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> createSettingWindow = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> options = &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">450</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br>    <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">frame</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">center</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">fullscreenable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">resizable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;PicGo&#x27;</span>,<br>    <span class="hljs-attr">vibrancy</span>: <span class="hljs-string">&#x27;ultra-dark&#x27;</span>,<br>    <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">titleBarStyle</span>: <span class="hljs-string">&#x27;hidden&#x27;</span>,<br>    <span class="hljs-attr">webPreferences</span>: &#123;<br>      <span class="hljs-attr">backgroundThrottling</span>: <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (process.platform === <span class="hljs-string">&#x27;win32&#x27;</span>) &#123; <span class="hljs-comment">// 针对windows平台做出不同的配置</span><br>    options.show = <span class="hljs-literal">true</span> <span class="hljs-comment">// 创建即展示</span><br>    options.frame = <span class="hljs-literal">false</span> <span class="hljs-comment">// 创建一个frameless窗口</span><br>    options.backgroundColor = <span class="hljs-string">&#x27;#3f3c37&#x27;</span> <span class="hljs-comment">// 背景色</span><br>  &#125;<br>  settingWindow = <span class="hljs-keyword">new</span> BrowserWindow(options)<br><br>  settingWindow.loadURL(settingWinURL)<br><br>  settingWindow.on(<span class="hljs-string">&#x27;closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    settingWindow = <span class="hljs-literal">null</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在PicGo项目中，window的配置被保存在<code>main/apis/app/window/windowList.ts</code>中，然后<code>export</code>出去，在<code>windowManager</code>里对窗口进行统一管理</p></blockquote><p>跟<code>app</code>模块一样，<code>BrowserWindow</code>也有很多常用的事件钩子：</p><ul><li><code>closed</code> 当窗口被关闭的时候</li><li><code>focus</code> 当窗口被激活的时候</li><li><code>show</code> 当窗口展示的时候</li><li><code>hide</code> 当窗口被隐藏的时候</li><li><code>maxmize</code> 当窗口最大化时</li><li><code>minimize</code> 当窗口最小化时</li><li><code>...</code></li></ul><p>当然，也依然有很多实用的方法：</p><ul><li><code>BrowserWindow.getFocusedWindow()</code> [静态方法]获取激活的窗口</li><li><code>win.close()</code> [实例方法，下同]关闭窗口</li><li><code>win.focus()</code> 激活窗口</li><li><code>win.show()</code> 显示窗口</li><li><code>win.hide()</code> 隐藏窗口</li><li><code>win.maximize()</code> 最大化窗口</li><li><code>win.minimize()</code> 最小化窗口</li><li><code>win.restore()</code> 从最小化窗口恢复</li><li><code>...</code></li></ul><p>比如上述说到的，windows的顶部的操作区（放大、缩小、关闭按钮）就可以通过icon模拟+实例方法来实现</p><h4 id="将html文档加载到主窗口">将html文档加载到主窗口<a class="header-anchor" href="#将html文档加载到主窗口">⁍</a></h4><p>方法一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">mainWindow.webContents.loadFile(<span class="hljs-string">&#x27;index.html&#x27;</span>);<br></code></pre></td></tr></table></figure><p>方法二：（electron-vue框架自带）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">const</span> winURL = process.env.NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span><br>  ? `http:<span class="hljs-comment">//localhost:9080` // 开发模式的话走webpack-dev-server的url</span><br>  : `file:<span class="hljs-comment">//$&#123;__dirname&#125;/index.html`</span><br><br><span class="hljs-comment">//...</span><br>mainWindow.loadURL(winURL)<br></code></pre></td></tr></table></figure><blockquote><p><code>__dirname</code>变量是Node全局可用的一个变量，它的值是当前正被执行的Node应用的完整路径。</p></blockquote><p><code>win.webContents</code>此窗口拥有的 <code>WebContents</code> 对象。 所有与网页相关的事件和操作都将通过它完成。</p><ul><li><p><code>win.loadURL(url[, options])</code>与<a href="https://www.electronjs.org/zh/docs/latest/api/web-contents#contentsloadurlurl-options"><code>webContents.loadURL(url[, options\])</code></a> 相同。</p></li><li><p><code>win.loadFile(filePath[, options])</code>与 <code>webContents.loadFile</code>相同， <code>filePath</code> 应该是一个与你的应用程序的根路径相关的HTML文件路径。</p></li></ul><p>两者在用法上有一定差别，可以参考<a href="https://www.electronjs.org/zh/docs/latest/api/browser-window#winloadurlurl-options">BrowserWindow | Electron (electronjs.org)</a></p><h4 id="优雅地显示窗口">优雅地显示窗口<a class="header-anchor" href="#优雅地显示窗口">⁍</a></h4><p>在加载页面时，渲染进程第一次完成绘制时，如果窗口还没有被显示，渲染进程会发出 <code>ready-to-show</code> 事件 。 在此事件后显示窗口将没有视觉闪烁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>);<br><br><span class="hljs-keyword">let</span> mainWindow = <span class="hljs-literal">null</span>;<br><br>app.on(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  mainWindow = <span class="hljs-keyword">new</span> BrowserWindow(&#123; <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span> &#125;); <span class="hljs-comment">// 设置为false</span><br><br>  mainWindow.loadURL(<span class="hljs-string">`file://<span class="hljs-subst">$&#123;__dirname&#125;</span>/index.html`</span>);<br><br>  mainWindow.once(<span class="hljs-string">&#x27;ready-to-show&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    mainWindow.show();<br>  &#125;);<br><br>  mainWindow.on(<span class="hljs-string">&#x27;closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    mainWindow = <span class="hljs-literal">null</span>;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="tray系统托盘"><a href="https://www.electronjs.org/zh/docs/latest/api/tray">Tray</a>系统托盘<a class="header-anchor" href="#tray系统托盘">⁍</a></h3><p>添加图标和上下文菜单到系统通知区。在windows里，<code>Tray</code>配合上图标之后就是windows右下角的应用图标</p><p>windows和macOS里，图标的大小都是<code>16*16</code>px。</p><p>官网代码（配合Menu使用）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; app, Menu, Tray &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br><span class="hljs-keyword">let</span> tray = <span class="hljs-literal">null</span><br>app.whenReady().then(<span class="hljs-function">() =&gt;</span> &#123;<br>  tray = <span class="hljs-keyword">new</span> Tray(<span class="hljs-string">&#x27;/path/to/my/icon&#x27;</span>)<br>  <span class="hljs-keyword">const</span> contextMenu = Menu.buildFromTemplate([<br>    &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Item1&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;radio&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Item2&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;radio&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Item3&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;radio&#x27;</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span> &#125;,<br>    &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Item4&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;radio&#x27;</span> &#125;<br>  ])<br>  tray.setToolTip(<span class="hljs-string">&#x27;This is my application.&#x27;</span>)<br>  tray.setContextMenu(contextMenu)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>在 Windows 上, 建议使用 <code>ICO</code> 图标来获得最佳视觉效果。</li></ul><p>如果要在所有平台上保持完全相同的行为, 则不应依赖 <code>click</code> 事件, 并且始终将上下文菜单附加到任务栏图标。</p><p>macOS下顶部栏的图标通常都是走<code>黑白</code>路线，所以可以为两种系统分别准备不同的图标。<code>PicGo</code>里<code>Tray</code>的生成代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTray</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> menubarPic = process.platform === <span class="hljs-string">&#x27;darwin&#x27;</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="hljs-string">`<span class="hljs-subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span><br>  tray = <span class="hljs-keyword">new</span> Tray(menubarPic) <span class="hljs-comment">// 指定图片的路径</span><br>  <span class="hljs-comment">// ... 其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意上述代码里有一个<code>$&#123;__static&#125;</code>的变量。该变量是<code>electron-vue</code>为我们暴露出来的项目根目录下的<code>static</code>文件夹的路径。通过这个路径，在开发和生产阶段都能很好的定位你的静态资源所在的目录。是个很方便的变量。</p><p>Tray支持很多有用的事件。其中最关键的两个是<code>click</code>和<code>right-click</code>。分别对应鼠标左键点击和鼠标右键点击事件。</p><h4 id="鼠标左键点击事件">鼠标左键点击事件<a class="header-anchor" href="#鼠标左键点击事件">⁍</a></h4><ul><li>在macOS系统下，鼠标左键点击Tray的icon可能会出现配置菜单，也有可能会出现应用窗口。</li><li>在windows下，鼠标左键点击Tray的icon通常会出现应用的窗口。</li></ul><h4 id="鼠标右键点击事件">鼠标右键点击事件<a class="header-anchor" href="#鼠标右键点击事件">⁍</a></h4><ul><li>在macOS系统下，鼠标右键点击Tray的icon通常会出现配置菜单。</li><li>在windows系统下，同上。</li></ul><p>PicGo举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTray</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> menubarPic = process.platform === <span class="hljs-string">&#x27;darwin&#x27;</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="hljs-string">`<span class="hljs-subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span><br>  tray = <span class="hljs-keyword">new</span> Tray(menubarPic)<br>  <span class="hljs-keyword">const</span> contextMenu = <span class="hljs-comment">// ...菜单</span><br>  tray.on(<span class="hljs-string">&#x27;right-click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 右键点击</span><br>    <span class="hljs-built_in">window</span>.hide() <span class="hljs-comment">// 隐藏小窗口</span><br>    tray.popUpContextMenu(contextMenu) <span class="hljs-comment">// 打开菜单</span><br>  &#125;)<br>  tray.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 左键点击</span><br>    <span class="hljs-keyword">if</span> (process.platform === <span class="hljs-string">&#x27;darwin&#x27;</span>) &#123; <span class="hljs-comment">// 如果是macOS</span><br>      toggleWindow() <span class="hljs-comment">// 打开或关闭小窗口</span><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果是windows</span><br>      <span class="hljs-built_in">window</span>.hide() <span class="hljs-comment">// 隐藏小窗口</span><br>      <span class="hljs-keyword">if</span> (settingWindow === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果主窗口不存在就创建一个</span><br>        createSettingWindow()<br>        settingWindow.show()<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果主窗口在，就显示并激活</span><br>        settingWindow.show()<br>        settingWindow.focus()<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="menu"><a href="https://www.electronjs.org/zh/docs/latest/api/menu">Menu</a><a class="header-anchor" href="#menu">⁍</a></h3><p><code>new Menu()</code>创建新菜单。</p><p>主要分两种。</p><ul><li><p>第一种是app的菜单。对于macOS来说就是顶部栏左侧区域的菜单项。对于windows而言就是一个窗口的标题栏下方的菜单区。</p><p>可以通过<code>Menu.setApplicationMenu()</code>来实现。</p></li><li><p>第二种是类似于右键菜单的菜单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> contextMenu = Menu.buildFromTemplate([<br>   &#123;<br>     <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;关于&#x27;</span>,<br>     click () &#123;<br>       dialog.showMessageBox(&#123;<br>         <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;PicGo&#x27;</span>,<br>         <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;PicGo&#x27;</span>,<br>         <span class="hljs-attr">detail</span>: <span class="hljs-string">`Version: <span class="hljs-subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span><br>       &#125;)<br>     &#125;<br>   &#125;,<br>   &#123;<br>     <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;打开详细窗口&#x27;</span>,<br>     click () &#123;<br>       <span class="hljs-keyword">if</span> (settingWindow === <span class="hljs-literal">null</span>) &#123;<br>         createSettingWindow()<br>         settingWindow.show()<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         settingWindow.show()<br>         settingWindow.focus()<br>       &#125;<br>     &#125;<br>   &#125;,<br>   &#123;<br>     <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;选择默认图床&#x27;</span>,<br>     <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;submenu&#x27;</span>,<br>     <span class="hljs-attr">submenu</span>: [<br>       &#123;<br>         <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;微博图床&#x27;</span>,<br>         <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;radio&#x27;</span>,<br>         <span class="hljs-attr">checked</span>: db.read().get(<span class="hljs-string">&#x27;picBed.current&#x27;</span>).value() === <span class="hljs-string">&#x27;weibo&#x27;</span>,<br>         click () &#123;<br>           db.read().set(<span class="hljs-string">&#x27;picBed.current&#x27;</span>, <span class="hljs-string">&#x27;weibo&#x27;</span>)<br>             .write()<br>         &#125;<br>       &#125;,<br>       &#123;<br>         <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;七牛图床&#x27;</span>,<br>         <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;radio&#x27;</span>,<br>         <span class="hljs-attr">checked</span>: db.read().get(<span class="hljs-string">&#x27;picBed.current&#x27;</span>).value() === <span class="hljs-string">&#x27;qiniu&#x27;</span>,<br>         click () &#123;<br>           db.read().set(<span class="hljs-string">&#x27;picBed.current&#x27;</span>, <span class="hljs-string">&#x27;qiniu&#x27;</span>)<br>             .write()<br>         &#125;<br>       &#125;<br>     ]<br>   &#125;,<br>   &#123;<br>     <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;quit&#x27;</span>,<br>     <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;退出&#x27;</span><br>   &#125;<br> ])<br><br> tray.on(<span class="hljs-string">&#x27;right-click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>   tray.popUpContextMenu(contextMenu)<br> &#125;)                                  <br></code></pre></td></tr></table></figure></li></ul><p>组成<code>Menu</code>的是一个一个的<code>MenuItem</code>。它们有很多类型：</p><ol><li>normal</li><li>separator</li><li>submenu</li><li>checkbox</li><li>radio</li></ol><p>以及很多角色：</p><ol><li>quit</li><li>copy</li><li>redo</li><li>undo</li><li>minimize</li><li>close</li><li>reload</li><li>…</li></ol><p>通常来说，配置的菜单项基本从类型里来组合。</p><p>如果没有在创建app菜单里指定这些操作的快捷键的话，那么一些常见的快捷操作就无法在你的app里使用了。比如<code>ctrl+c</code>或者<code>command+c</code>复制这个操作，如果你没有通过<code>Menu.setApplicationMenu()</code>来设定这个快捷键的话，那么在你的electron应用里就无法执行复制的操作了。</p><blockquote><p>注意，如果在开发模式下直接只使用如下快捷键的话，一些调试快捷键比如<code>F12</code>或者<code>command+shift+i</code>打开控制台的操作就无法使用了。所以在开发模式下不需要创建这些快捷键菜单。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> createMenu = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;development&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> template = [&#123;<br>      <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Edit&#x27;</span>,<br>      <span class="hljs-attr">submenu</span>: [<br>        &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Undo&#x27;</span>, <span class="hljs-attr">accelerator</span>: <span class="hljs-string">&#x27;CmdOrCtrl+Z&#x27;</span>, <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;undo:&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Redo&#x27;</span>, <span class="hljs-attr">accelerator</span>: <span class="hljs-string">&#x27;Shift+CmdOrCtrl+Z&#x27;</span>, <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;redo:&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;separator&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Cut&#x27;</span>, <span class="hljs-attr">accelerator</span>: <span class="hljs-string">&#x27;CmdOrCtrl+X&#x27;</span>, <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;cut:&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Copy&#x27;</span>, <span class="hljs-attr">accelerator</span>: <span class="hljs-string">&#x27;CmdOrCtrl+C&#x27;</span>, <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;copy:&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Paste&#x27;</span>, <span class="hljs-attr">accelerator</span>: <span class="hljs-string">&#x27;CmdOrCtrl+V&#x27;</span>, <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;paste:&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Select All&#x27;</span>, <span class="hljs-attr">accelerator</span>: <span class="hljs-string">&#x27;CmdOrCtrl+A&#x27;</span>, <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;selectAll:&#x27;</span> &#125;,<br>        &#123;<br>          <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Quit&#x27;</span>,<br>          <span class="hljs-attr">accelerator</span>: <span class="hljs-string">&#x27;CmdOrCtrl+Q&#x27;</span>,<br>          click () &#123;<br>            app.quit()<br>          &#125;<br>        &#125;<br>      ]<br>    &#125;]<br>    menu = Menu.buildFromTemplate(template)<br>    Menu.setApplicationMenu(menu)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过<code>accelerator</code>指定你想要的快捷键。诸如<code>Shift</code>、<code>Ctrl</code>、<code>Cmd</code>等键位缩写。如果是组合键，就加上<code>+</code>。尤其注意到，因为macOS和windows键位的差异，所以有一个很好用的键位缩写<code>CmdOrCtrl</code>，即如果是在macOS上就是<code>Cmd</code>，在windows上就是<code>Ctrl</code>。</p><p>菜单项的点击事件可以直接通过<code>click</code>属性来指定。先通过了<code>Menu.buildFromTemplate()</code>这个方法创建了菜单，然后再在右键点击<code>Tray</code>图标的时候将其弹（PopUp)出来。</p><p>当然也有其他构建菜单的方法。可以通过Menu实例的<code>append</code>方法来加入<code>Menu Item</code>。</p><h2 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h2><p>本文主要还是结合了PicGo项目对Electron主进程有了大致的了解</p><p>PicGo项目本身对功能的划分比较明确，它的入口是<code>backgroung.js</code>，通过它来调用<code>main/lifeCycle/index.js</code>，在其中来进行ready/quit等，并调用写入其他文件里的窗口创建/菜单创建等。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://molunerfinn.com/electron-vue-1/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BB%8B%E7%BB%8D">Electron-vue开发实战0——Electron-vue入门 | MARKSZのBlog (molunerfinn.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://segmentfault.com/q/1010000002712805">在一些开源框架中，dist文件夹是什么意思 - SegmentFault 思否</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|位运算</title>
      <link href="/augu1sto/2b4514c3bfcc/"/>
      <url>/augu1sto/2b4514c3bfcc/</url>
      
        <content type="html"><![CDATA[<h2 id="常用位运算总结">常用位运算总结<a class="header-anchor" href="#常用位运算总结">⁍</a></h2><table><thead><tr><th>作用</th><th>公式</th><th>代码（JAVA）</th><th>举例</th></tr></thead><tbody><tr><td>改变num第i位（1-&gt;0，0-&gt;1）</td><td>num^(1&lt;&lt;i)</td><td>num^=(1&lt;&lt;i)</td><td>num: 1001(9)<br />i: 3<br />1&lt;&lt;i: 1000<br />–&gt; num = 1</td></tr><tr><td>判断num的第i位是不是0</td><td>num&amp;(1&lt;&lt;i) == 0</td><td></td><td>000001(0)000</td></tr><tr><td>获得一个二进制数最右边的一个1</td><td>b &amp;(-b) = b&amp;(~b+1)</td><td>num = b&amp;(-b)</td><td>b:  10100<br />-b: 01100<br />–&gt; num = 00100b</td></tr><tr><td>(接上)最右边的1在第几位</td><td></td><td>Integer.bitCount(num - 1)</td><td>num-1就相当于把1000变成了111，1的个数就相当于第几位（从0开始）</td></tr><tr><td>无进位相加</td><td>a^b</td><td>r = a^b</td><td>a: 1001(9)<br />b: 1111(15)<br />a^b: 110</td></tr><tr><td>计算（保存）进位</td><td>(a&amp;b)&lt;&lt;1</td><td>c = (a&amp;b)&lt;&lt;1</td><td>a&amp;b: 1001<br />–&gt; c: 10010(和列竖式一样，第1位和第4位进1，在和a^b相加继续操作)</td></tr><tr><td>将二进制数的最后一个1变成0(最后一个1，不是最后一位)</td><td>x&amp;(x-1)</td><td>x = x&amp;(x-1)</td><td>x: 1010<br />x-1: 1001<br />–&gt; 1000</td></tr><tr><td>$2^n$</td><td>1&lt;&lt;n</td><td>1&lt;&lt;n</td><td>1000(8)(n=3)</td></tr><tr><td>0~(1111)的遍历</td><td></td><td>i&lt; (1&lt;&lt;n)</td><td></td></tr></tbody></table><h2 id="剑指-offer-ii-001-整数除法"><a href="https://leetcode-cn.com/problems/xoh6Oh/">剑指 Offer II 001. 整数除法</a><a class="header-anchor" href="#剑指-offer-ii-001-整数除法">⁍</a></h2><p>给定两个整数 <code>a</code> 和 <code>b</code> ，求它们的除法的商 <code>a/b</code> ，要求不得使用乘号 <code>'*'</code>、除号 <code>'/'</code> 以及求余符号 <code>'%'</code> 。</p><p>注意：</p><ul><li>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</li><li>⭐ 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>, 2<sup>31</sup>−1]。本题中，如果除法结果溢出，则返回 2<sup>31</sup> − 1</li></ul><blockquote><p><strong>思路与注意事项</strong></p></blockquote><p>最大的正数为 2^31-1,最小的负数为 -2^31,如果将负数转化为正数会溢出，所以可以 <strong>将正数都转化为负数计算</strong></p><p><mark>注意处理成负数之后，后面的大于号小于号都要变！</mark></p><p>当被除数大于除数时，继续判断是不是大于除数的 2 倍？ 4 倍？ 8 倍？…如果被除数大于除数的 2^k 倍，那么将被除数减去除数的 2^ k 倍，之后再重复以上步骤。</p><p>15=2*4+2*2+2*1=2*(4+2+1)=2*7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -a;<br><br>    <span class="hljs-keyword">int</span> negative = <span class="hljs-number">1</span>; <span class="hljs-comment">//记录正负</span><br>    <span class="hljs-comment">//如果两个都是负数，则negative=1</span><br>    <span class="hljs-comment">//一正一负，则negative==0</span><br>    <span class="hljs-comment">//都是正数，则negative=-1</span><br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) &#123;<br>      negative--;<br>      a = -a; <span class="hljs-comment">//正数转成负数</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>      negative--;<br>      b = -b;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> res = dev(a, b);<br>    <span class="hljs-keyword">return</span> negative == <span class="hljs-number">0</span> ? -res : res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dev</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> || a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = getShift(a, b);<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; n) + dev(a - (b &lt;&lt; n), b);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (a &lt;= b &amp;&amp; b &gt;= (Integer.MIN_VALUE &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>      <span class="hljs-keyword">int</span> tmp = b &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">//a&gt;b,b就左移</span><br>      <span class="hljs-keyword">if</span> (tmp &lt; a) <span class="hljs-keyword">break</span>;<br>      b = tmp;<br>      n++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-ii-002-二进制加法"><a href="https://leetcode-cn.com/problems/JFETK5/">剑指 Offer II 002. 二进制加法</a><a class="header-anchor" href="#剑指-offer-ii-002-二进制加法">⁍</a></h2><p>给定两个 01 字符串 <code>a</code> 和 <code>b</code> ，请计算它们的和，并以二进制字符串的形式输出。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><blockquote><p><strong>思路</strong></p></blockquote><ul><li>把 a 和 b 转换成整型数字 x 和 y，在接下来的过程中，x 保存结果，y 保存进位。</li><li>当进位不为 0 时<ul><li>计算当前 x 和 y 的无进位相加结果：answer = x ^ y</li><li>计算当前 x 和 y 的进位：carry = (x &amp; y) &lt;&lt; 1</li><li>完成本次循环，更新 x = answer，y = carry</li></ul></li><li>返回 x 的二进制形式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span>(<span class="hljs-params">self, a, b</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        x, y = <span class="hljs-built_in">int</span>(a, <span class="hljs-number">2</span>), <span class="hljs-built_in">int</span>(b, <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">while</span> y:<br>            answer = x ^ y<br>            carry = (x &amp; y) &lt;&lt; <span class="hljs-number">1</span><br>            x, y = answer, carry<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bin</span>(x)[<span class="hljs-number">2</span>:]<span class="hljs-comment">#&quot;0b101&quot;去掉&quot;0b&quot;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>JAVA递归写法： 但是Integer大小有限制，所以大数无法通过</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addBinary</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> na = Integer.parseInt(a, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span> nb = Integer.parseInt(b, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> Integer.toBinaryString(addBin(na, nb));<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addBin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> na, <span class="hljs-keyword">int</span> nb)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nb == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> na;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = na ^ nb;<br>    <span class="hljs-keyword">int</span> cin = (na &amp; nb) &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">return</span> addBin(ans, cin);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-ii-003-前-n-个数字二进制中-1-的个数"><a href="https://leetcode-cn.com/problems/w3tCBm/">剑指 Offer II 003. 前 n 个数字二进制中 1 的个数</a><a class="header-anchor" href="#剑指-offer-ii-003-前-n-个数字二进制中-1-的个数">⁍</a></h2><p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[] bits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">int</span> last = i &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">//判断最后一位是不是1</span><br>            bits[i] = bits[i &gt;&gt; <span class="hljs-number">1</span>] + last;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bits;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><h4 id="brian-kernighan-算法">Brian Kernighan 算法<a class="header-anchor" href="#brian-kernighan-算法">⁍</a></h4></blockquote><p>对于任意整数 x，令 $x=x<sub>&amp;</sub>(x-1)$，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到x 变成 0，则操作次数即为 x 的「一比特数」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[] bits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            bits[i] = countOnes(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bits;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ones = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>            x &amp;= (x - <span class="hljs-number">1</span>);<br>            ones++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>O(nlogn)</p><h2 id="剑指-offer-ii-004-只出现一次的数字"><a href="https://leetcode-cn.com/problems/WGki4K/">剑指 Offer II 004. 只出现一次的数字 </a><a class="header-anchor" href="#剑指-offer-ii-004-只出现一次的数字">⁍</a></h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。</p><p>**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><blockquote><p><strong>思路</strong></p></blockquote><p>考虑位运算</p><p>❌ nums.length最大是3*10^4，也不可能用一个数的各个位数表示某个数是否出现（python可以？）</p><ul><li>num出现1次，则a的第num位置1</li><li>如果a的第num位为1，说明num出现了第2/3次，置b的第num位为1</li><li>用a-b，返回的一定类似0001…000的数，最右边的1对应的位数只出现了一次的数</li><li><strong>位运算置第i位为1：</strong> 与数 1 &lt;&lt; i 进行按位异或运算即可</li><li><strong>位运算计算最低位的1是第几位：</strong> 可以通过一些语言自带的函数得到这个最低位的 1 究竟是第几位（即 i值） bin©.count(“0”) - 1</li><li><strong>位运算计算第i位是否是1：</strong> 与 1&lt;&lt; i 相与，看是不是i</li></ul><p>❌ <mark>无法处理负数，如果条件是正数。。或许可以考虑这种方法</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        a = <span class="hljs-number">0</span><br>        b = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            i = <span class="hljs-number">1</span>&lt;&lt;num<br>            <span class="hljs-keyword">if</span>((a&amp;i)!=i):<br>                a^=i<br>            <span class="hljs-keyword">elif</span>((b&amp;i)!=i):<br>                b^=i<br>        c=a^b<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bin</span>(c).count(<span class="hljs-string">&quot;0&quot;</span>) - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>✔️ <strong>依次确定每一个二进制位</strong></p><p>统计所有数第i个二进制位的和，模3，最终得到结果的第i个二进制位</p><p><mark>巧用题目条件，最多的位数</mark></p><p>时间复杂度：$O(n \log C)$，其中 $n$ 是数组的长度，$C$ 是元素的数据范围，本题中就是 $\log C=\log 2^{32} = 32$</p><ul><li>得到x的第i个二进制位： ((x&gt;&gt; i) &amp; 1)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: nums) &#123;<br>                total += ((num &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (total % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;<br>                ans |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-15-二进制中-1-的个数-汉明重量"><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5vk1l3/">剑指 Offer 15. 二进制中 1 的个数(汉明重量)</a><a class="header-anchor" href="#剑指-offer-15-二进制中-1-的个数-汉明重量">⁍</a></h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量)）。</p><p>提示：</p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> countOne(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            n=n&amp;(n-<span class="hljs-number">1</span>);<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每轮消去一个1，时间复杂度O(M)，M为1的个数</p><h2 id="剑指-offer-56-i-数组中数字出现的次数"><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/eubbnm/">剑指 Offer 56 - I. 数组中数字出现的次数</a><a class="header-anchor" href="#剑指-offer-56-i-数组中数字出现的次数">⁍</a></h2><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>            n^=num;<br>        &#125;<span class="hljs-comment">// n = a^b</span><br>        <br>        <span class="hljs-keyword">int</span> lastOne = n&amp;(-n); <span class="hljs-comment">// 保留n最右边（第i位）一个1</span><br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>((lastOne&amp;num)==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 说明num第i位为0</span><br>                a^=num; <span class="hljs-comment">// a第i位为0，区分与b</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> b = a^n;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;b,a&#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="78-子集"><a href="https://leetcode-cn.com/problems/subsets/description/">78. 子集</a><a class="header-anchor" href="#78-子集">⁍</a></h2><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203020011454.png" alt="image-20220302001102353"></p><p>每个数对应二进制数mask的1位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>; mask &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++mask) &#123; <span class="hljs-comment">// 遍历0~（1111..1)2 n个1</span><br>            t.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// mask的第i个数为1的话，就加入nums[i]</span><br>                    t.add(nums[i]);<br>                &#125;<br>            &#125;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(t));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="287-寻找重复数"><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/description/">287. 寻找重复数</a><a class="header-anchor" href="#287-寻找重复数">⁍</a></h2><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><blockquote><p><strong>思路：</strong></p></blockquote><p>数每一位的1相加是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        maxBit = <span class="hljs-number">1</span><br>        n = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> (n&gt;&gt;maxBit) != <span class="hljs-number">0</span>:<br>            maxBit+=<span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> bit <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(maxBit):<br>            <span class="hljs-comment"># 计算每一位的和</span><br>            sum_n = <span class="hljs-number">0</span><br>            sum_num = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit)!= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 初始时加上第一个数</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> i&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span>:<br>                    sum_n += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> nums[i]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span>:<br>                    sum_num += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># sum_num-sum_n 就是第i位为0/1的数</span><br>            <span class="hljs-keyword">if</span> sum_num&gt;sum_n:<br>                ans |= <span class="hljs-number">1</span>&lt;&lt;bit<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>有其他更好解法，见 [快慢指针](<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/xun-zhao-zhong-fu-shu-by-leetcode-solution/">寻找重复数 - 寻找重复数 - 力扣（LeetCode） (leetcode-cn.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|回溯算法</title>
      <link href="/augu1sto/78b6fa9cea22/"/>
      <url>/augu1sto/78b6fa9cea22/</url>
      
        <content type="html"><![CDATA[<h2 id="基本知识">基本知识<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><a class="header-anchor" href="#基本知识">⁍</a></h2><p><strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h3 id="回溯法问题总结">回溯法问题总结<a class="header-anchor" href="#回溯法问题总结">⁍</a></h3><ul><li><a href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98">组合问题</a>：N个数里面按一定规则找出k个数的集合</li><li><a href="#%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98">切割问题</a>：一个字符串按一定规则有几种切割方式</li><li><a href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98">子集问题</a>：一个N个数的集合里有多少符合条件的子集</li><li><a href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98">排列问题</a>：N个数按一定规则全排列，有几种排列方式</li><li><a href="#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98">棋盘问题</a>：N皇后，解数独等等</li></ul><blockquote><p>组合无序，排序有序</p></blockquote><h3 id="回溯法模板">回溯法模板<a class="header-anchor" href="#回溯法模板">⁍</a></h3><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⭐-回溯三步：">⭐ 回溯三步：<a class="header-anchor" href="#⭐-回溯三步：">⁍</a></h4><ul><li><p>回溯函数模板返回值（一般是void）以及参数</p><ul><li><p>一般是先写逻辑，然后需要什么参数，就填什么参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>回溯函数终止条件</p><p>一般来说搜到 <strong>叶子节点</strong> 了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (终止条件) &#123;<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>回溯搜索的遍历过程</p><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p><img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础"></p><p><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>    处理节点;<br>    backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br><br></code></pre></td></tr></table></figure><p><mark>不能忘记回溯撤销</mark></p></li></ul><h2 id="组合问题">组合问题<a class="header-anchor" href="#组合问题">⁍</a></h2><h3 id="77-组合"><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a><a class="header-anchor" href="#77-组合">⁍</a></h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><blockquote><p><strong>思路</strong></p></blockquote><ul><li>叶子节点：每个组合的第k个数，即子组合长度为k</li><li>每个节点就是往集合里加数</li><li>横向遍历： <strong>剪枝</strong> [起始,剩下的数]（不剪枝就是&lt;=n）<ul><li>关键：如何避免重复？——每次递归的时候取[]中下一个数</li><li>起始：i=t，递归时变成i+1</li><li>剩下的数：= n - 集合中还差的数的个数 +1 （保证还有足够的数可以被遍历）<ul><li>集合中还差的数的个数 = （k-comb.size()）</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20201123195223940.png" alt="77.组合"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>  <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; comb = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>    backtracking(n, k, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (comb.size() == k) &#123;<br>      res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(comb));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t; i &lt;= n - (k - comb.size()) + <span class="hljs-number">1</span>; i++) &#123;<br>      comb.add(i);<br>      backtracking(n, k, i + <span class="hljs-number">1</span>);<br>      comb.removeLast();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="216-组合总和-iii"><a href="https://leetcode-cn.com/problems/combination-sum-iii/description/">216. 组合总和 III</a><a class="header-anchor" href="#216-组合总和-iii">⁍</a></h3><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><blockquote><p><strong>思路：</strong> 参考上面的模板，一下就写对啦！</p></blockquote><ul><li>终止条件：<ul><li>size=k且sum=n，符合条件，res.add</li><li>size=k但sum!=n，结束</li><li>按从小到大遍历的话，如果sum&gt;n，结束</li></ul></li><li>横向遍历 [1,9]–》[t,9-(k-size)+1], t=i+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n) &#123;<br>    sumComb3(k, n, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sumComb3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> startIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sz = path.size();<br>    <span class="hljs-keyword">if</span> (sz == k &amp;&amp; sum == n) &#123;<br>      res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &gt; n || (sz == k &amp;&amp; sum != n)) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - sz) + <span class="hljs-number">1</span>; i++) &#123;<br>      sum += i;<br>      path.add(i);<br>      sumComb3(k, n, i + <span class="hljs-number">1</span>);<br>      path.removeLast();<br>      sum -= i; <span class="hljs-comment">// 别忘了回溯这一步！</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⭐17-电话号码的字母组合">⭐<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合</a><a class="header-anchor" href="#⭐17-电话号码的字母组合">⁍</a></h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：digits = &quot;23&quot;<br>输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：digits = &quot;&quot;<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：digits = &quot;2&quot;<br>输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong></p></blockquote><p>首先要思考清楚题意，每个数字相当于一个字母的集合（用字符串数组表示出来）</p><p>每个集合里都要取一个数，构成最终的集合</p><p>因为是集合（答案可以按任意顺序返回），所以按顺序来就行</p><ul><li>每层迭代是每个数字内部的集合遍历</li><li>每层递归是下一个“数字”代表的集合</li><li>终止条件是没有数字了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String[] digitStr = &#123;<br>    <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">//2</span><br>    <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">//3</span><br>    <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">//4</span><br>    <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">//5</span><br>    <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">//6</span><br>    <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">//7</span><br>    <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">//8</span><br>    <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">//9</span><br>  &#125;;<br><br>  <span class="hljs-keyword">public</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (digits == <span class="hljs-keyword">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuilder</span><br>    StringBuilder temp = <span class="hljs-keyword">new</span> StringBuilder();<br>    backtracking(digits, <span class="hljs-number">0</span>, temp);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(String digits, <span class="hljs-keyword">int</span> i, StringBuilder temp)</span> </span>&#123;<br>    <span class="hljs-comment">// i记录迭代到第i个digits</span><br><br>    <span class="hljs-keyword">if</span> (i == digits.length()) &#123;<br>      <span class="hljs-comment">//   res.add(str);</span><br>      res.add(temp.toString());<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// k记录遍历到当前digit里的第k位</span><br>    <span class="hljs-keyword">int</span> digit = digits.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; digitStr[digit].length(); k++) &#123;<br>      <span class="hljs-comment">//   str += digitStr[digit].charAt(k);</span><br>      temp.append(digitStr[digit].charAt(k));<br>      backtracking(digits, i + <span class="hljs-number">1</span>, temp);<br>      <span class="hljs-comment">//   str = str.substring(0, str.length() - 1);</span><br>      temp.deleteCharAt(temp.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键问题和错误：</strong></p><ol><li>涉及字符串拼接，选用<code>StringBuilder </code><ul><li>转换成String： <code>.toString()</code></li><li>添加：<code>.append(ch)</code></li><li>删除最后一个：<code>deleteCharAt(temp.length() - 1);</code></li></ul></li><li>字符串的第K个字母： <code>.charAt(k)</code></li><li>⭐ digit的第k位，转换为数字：<code>int digit = digits.charAt(i) - '0';</code></li></ol><h3 id="39-组合总和"><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a><a class="header-anchor" href="#39-组合总和">⁍</a></h3><p>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p>candidates 中的 同一个 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><blockquote><p><strong>思路：</strong> 先排序</p></blockquote><p>这题在[数组](/augu1sto/0d8a87a8eab4/#39-组合总和)里写过，不赘述</p><ul><li>终止条件<ul><li>sum==target，加进结果列表，返回</li><li>sum&gt;target，再往后遍历也更大，直接返回<ul><li>虽然我也不是很懂，这个判断条件写进循环里，效率会高很多。。</li></ul></li></ul></li><li>遍历，因为排序过了，每次从下一个值开始遍历 ❌<ul><li>可以重复，从当前值开始遍历</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        Arrays.sort(candidates);<span class="hljs-comment">//排序</span><br>        sumComb(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sumComb</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> startIndex)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// if (sum&gt;target) &#123;</span><br>        <span class="hljs-comment">//     return;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; nums.length&amp;&amp;(sum+nums[i]&lt;=target); i++) &#123;<br>            sum+=nums[i];<br>            path.add(nums[i]);<br>            sumComb(nums, target, i);<br>            sum-=nums[i];<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="40-组合总和-ii"><a href="https://leetcode-cn.com/problems/combination-sum-ii/description/">40. 组合总和 II</a><a class="header-anchor" href="#40-组合总和-ii">⁍</a></h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong> 解集不能包含重复的组合。</p><blockquote><p><strong>思路</strong></p></blockquote><p>和上一题差不多，遍历的时候从下一个数开始就行了</p><p>但是要去重，也就是说for循环的时候如果下一个数和当前数相等，跳过continue就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        Arrays.sort(candidates);<span class="hljs-comment">//排序</span><br>        sumComb2(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sumComb2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> startIndex)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// if (sum&gt;target) &#123;</span><br>        <span class="hljs-comment">//     return;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; nums.length&amp;&amp;(sum+nums[i]&lt;=target); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i&gt;startIndex&amp;&amp;nums[i]==nums[i-<span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum+=nums[i];<br>            path.add(nums[i]);<br>            sumComb2(nums, target, i+<span class="hljs-number">1</span>);<span class="hljs-comment">//这里！</span><br>            sum-=nums[i];<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="切割问题">切割问题<a class="header-anchor" href="#切割问题">⁍</a></h2><p>从startIndex循环，确定长度</p><p>切割条件的判断，不满足条件就continue</p><h3 id="131-分割回文串"><a href="https://leetcode-cn.com/problems/palindrome-partitioning/description/">131. 分割回文串</a><a class="header-anchor" href="#131-分割回文串">⁍</a></h3><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;aab&quot;<br>输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><p>两个关键问题：</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><ul><li>终止条件：<ul><li>遍历到结尾，加入合集</li></ul></li><li>逻辑：<ul><li>用startIndex表示切割线</li><li>循环i表示切割长度</li><li>如果是回文就记录到path中</li></ul></li><li>优化：记忆化搜索<ul><li>用f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    LinkedList&lt;String&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[][] f;<br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;<br>        f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()][s.length()];<br>        backtracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (startIndex&gt;=s.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; s.length(); i++) &#123;<br>            String st = s.substring(startIndex, i+<span class="hljs-number">1</span>);<span class="hljs-comment">//右边取不到，所以写i+1</span><br>            <span class="hljs-keyword">if</span> (isPal(s,startIndex,i)==-<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(st);<br>            backtracking(s, i+<span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">isPal</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (f[i][j] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> f[i][j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>            f[i][j] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>            f[i][j] = isPal(s, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            f[i][j] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[i][j];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="93-复原-ip-地址"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/description/">93. 复原 IP 地址</a><a class="header-anchor" href="#93-复原-ip-地址">⁍</a></h3><p>用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong> (不能有前缀0)，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;25525511135&quot;<br>输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><ul><li>除了index，还要用cnt来记录是第几次切割，根据剩下的位数len-startIndex剪枝<ul><li>第1次前：4~12位</li><li>第2次前：3~9位</li><li>第3次前：2~6位</li><li>第4次前：1~3位</li><li>总结：(4-cnt+1) ~ 3*(4-cnt+1)位</li></ul></li><li>每次切割最多3位</li><li>如果首字母==0，只能切1位</li><li>有效：转换为十位数在0-255之间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">4</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        cutting(s, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cutting</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (startIndex==s.length()&amp;&amp;cnt==<span class="hljs-number">4</span>+<span class="hljs-number">1</span>) &#123;<br>            res.add(String.join(<span class="hljs-string">&quot;.&quot;</span>, arr));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((s.length()-startIndex&lt;<span class="hljs-number">4</span>-cnt+<span class="hljs-number">1</span>)||(s.length()-startIndex&gt;<span class="hljs-number">3</span>*(<span class="hljs-number">4</span>-cnt+<span class="hljs-number">1</span>))) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.charAt(startIndex)==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            arr[cnt-<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;0&quot;</span>;<br>            cutting(s, startIndex+<span class="hljs-number">1</span>, cnt+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//用cnt记录回溯，不用再做操作</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//for循环注意最后的条件，不能超出字符串长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; s.length()&amp;&amp;i &lt; startIndex+<span class="hljs-number">3</span>; i++) &#123;<br>            String st = s.substring(startIndex, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (Integer.parseInt(st)&lt;<span class="hljs-number">0</span>||Integer.parseInt(st)&gt;<span class="hljs-number">255</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            arr[cnt-<span class="hljs-number">1</span>]=st;<br>            cutting(s, i+<span class="hljs-number">1</span>, cnt+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//用cnt记录回溯，不用再做操作</span><br>            <br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>数据结构选型</strong></p><p>字符串数组长度固定+要用特定字符拼接：用String[]</p><p>注意细节！！</p><h2 id="子集问题">子集问题<a class="header-anchor" href="#子集问题">⁍</a></h2><p>组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点</p><h3 id="78-子集"><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a><a class="header-anchor" href="#78-子集">⁍</a></h3><p>遍历时记录所有节点(写在递归开头)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    backtracking(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> startIndex)</span> </span>&#123;<br>    res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<span class="hljs-comment">//记录</span><br>    <span class="hljs-keyword">if</span> (startIndex == nums.length) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;<br>      path.add(nums[i]);<br>      backtracking(nums, i + <span class="hljs-number">1</span>);<br>      path.removeLast();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="90-子集-ii"><a href="https://leetcode-cn.com/problems/subsets-ii/description/">90. 子集 II</a><a class="header-anchor" href="#90-子集-ii">⁍</a></h3><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><blockquote><p><strong>思路</strong> 先排序，循环遍历时跳过和上一个一样的数（参考组合）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    Arrays.sort(nums);<br>    backtracking(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> startIndex)</span> </span>&#123;<br>    res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>    <span class="hljs-keyword">if</span> (startIndex == nums.length) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">//去重</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      path.add(nums[i]);<br>      backtracking(nums, i + <span class="hljs-number">1</span>);<br>      path.removeLast();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="491-递增子序列"><a href="https://leetcode-cn.com/problems/increasing-subsequences/description/">491. 递增子序列</a><a class="header-anchor" href="#491-递增子序列">⁍</a></h3><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><blockquote><p><strong>思路：</strong> 套子集模板</p></blockquote><ul><li><p>判断数字是否&gt;=Path的最后一个数，如果不是，则continue；</p></li><li><p>注意递增子序列中 <strong>至少有两个元素</strong> 。</p></li><li><p><mark>去重</mark></p><ul><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li>用长度为200的数组记录数字有没有被访问过(每层！！写在递归里面，循环外面)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    backtracking(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> startIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (path.size() &gt;= <span class="hljs-number">2</span>) &#123;<br>      res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (startIndex == nums.length) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">201</span>]; <span class="hljs-comment">//记录数是否被访问过，访问过的(数+100)对应置1</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (<br>        !path.isEmpty() &amp;&amp;<br>        nums[i] &lt; path.getLast() ||<br>        (visited[nums[i] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>)<br>      ) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      visited[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br>      path.add(nums[i]);<br>      backtracking(nums, i + <span class="hljs-number">1</span>);<br>      path.removeLast();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列问题">排列问题<a class="header-anchor" href="#排列问题">⁍</a></h2><h3 id="46-全排列"><a href="https://leetcode-cn.com/problems/permutations/description/">46. 全排列</a><a class="header-anchor" href="#46-全排列">⁍</a></h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><blockquote><p><strong>思路</strong></p></blockquote><p>不需要startIndex，但是要去重，记录哪些元素用过了（记得回溯）</p><p>和上一题不同，这次直接申请nums长度的used数组就行了</p><p>used[i]表示num[i]是否出现过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[] used;<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>    backtracking(nums);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>      res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (used[i]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      used[i] = <span class="hljs-keyword">true</span>;<br>      path.add(nums[i]);<br>      backtracking(nums);<br>      path.removeLast();<br>      used[i] = <span class="hljs-keyword">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⭐-47-全排列-ii">⭐ <a href="https://leetcode-cn.com/problems/permutations-ii/description/">47. 全排列 II</a><a class="header-anchor" href="#⭐-47-全排列-ii">⁍</a></h3><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><blockquote><p><strong>思路</strong></p></blockquote><p>先排序，遍历时比较节点的值是否与上一个相同（line22），记得查看是否被访问过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[] used;<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>    Arrays.sort(nums);<br>    backtracking(nums);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过</span><br>            <span class="hljs-comment">// 如果同⼀树层nums[i - 1]使⽤过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-keyword">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果同⼀树⽀nums[i]使⽤过</span><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用</span><br>            path.add(nums[i]);<br>            backTrack(nums, used);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复</span><br>            used[i] = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//回溯</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>如果改成 <code>used[i - 1] == true</code>， 也是正确的!</strong>，去重代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p><p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p></blockquote><h2 id="⭐332-重新安排行程">⭐<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/description/">332. 重新安排行程</a><a class="header-anchor" href="#⭐332-重新安排行程">⁍</a></h2><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><ul><li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li></ul><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：tickets = [[<span class="hljs-string">&quot;MUC&quot;</span>,<span class="hljs-string">&quot;LHR&quot;</span>],[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;MUC&quot;</span>],[<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;SJC&quot;</span>],[<span class="hljs-string">&quot;LHR&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]]<br>输出：[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;MUC&quot;</span>,<span class="hljs-string">&quot;LHR&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;SJC&quot;</span>]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><p>建立{起点：{终点}}的映射集合：用Map</p><p>其中{终点}要以字典序排序，所以选用有自然优先级的容器TreeMap（回溯）/PriorityQueue（官方题解dfs）</p><p>下面是回溯法的步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Deque&lt;String&gt; res;<br>  <span class="hljs-keyword">private</span> Map&lt;String, Map&lt;String, Integer&gt;&gt; map;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;<br>    map = <span class="hljs-keyword">new</span> HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();<br>    res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (List&lt;String&gt; t : tickets) &#123;<br>      Map&lt;String, Integer&gt; temp;<br>      <span class="hljs-keyword">if</span> (map.containsKey(t.get(<span class="hljs-number">0</span>))) &#123;<br>        temp = map.get(t.get(<span class="hljs-number">0</span>));<br>        temp.put(t.get(<span class="hljs-number">1</span>), temp.getOrDefault(t.get(<span class="hljs-number">1</span>), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        temp = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(); <span class="hljs-comment">//升序Map</span><br>        temp.put(t.get(<span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<br>      &#125;<br>      map.put(t.get(<span class="hljs-number">0</span>), temp);<br>    &#125;<br>    res.add(<span class="hljs-string">&quot;JFK&quot;</span>);<br>    backTracking(tickets.size());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ticketNum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (res.size() == ticketNum + <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    String last = res.getLast();<br>    <span class="hljs-keyword">if</span> (map.containsKey(last)) &#123; <span class="hljs-comment">//防止出现null</span><br>      <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; target : map.get(last).entrySet()) &#123;<br>        <span class="hljs-keyword">int</span> count = target.getValue();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>          res.add(target.getKey());<br>          target.setValue(count - <span class="hljs-number">1</span>);<br>          <span class="hljs-keyword">if</span> (backTracking(ticketNum)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          res.removeLast();<br>          target.setValue(count);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong> DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, PriorityQueue&lt;String&gt;&gt;();<br>    List&lt;String&gt; itinerary = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;<br>            String src = ticket.get(<span class="hljs-number">0</span>), dst = ticket.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(src)) &#123;<br>                map.put(src, <span class="hljs-keyword">new</span> PriorityQueue&lt;String&gt;());<br>            &#125;<br>            map.get(src).offer(dst);<br>        &#125;<br>        <br>        dfs(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        Collections.reverse(itinerary);<br>        <span class="hljs-keyword">return</span> itinerary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String curr)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (map.containsKey(curr) &amp;&amp; map.get(curr).size() &gt; <span class="hljs-number">0</span>) &#123;<br>            String tmp = map.get(curr).poll();<br>            dfs(tmp);<br>        &#125;<br>        itinerary.add(curr);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//作者：LeetCode-Solution</span><br><span class="hljs-comment">//链接：https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/</span><br><br></code></pre></td></tr></table></figure><h2 id="⭐51-n-皇后">⭐<a href="https://leetcode-cn.com/problems/n-queens/description/">51. N 皇后</a><a class="header-anchor" href="#⭐51-n-皇后">⁍</a></h2><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 4<br>输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 1<br>输出：[[&quot;Q&quot;]]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong></p></blockquote><p>皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>用4个数组记录该行、列、左斜/右斜有没有被访问过</p><p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><p>对于cb[row][col]</p><ul><li>used_c[col]==1，说明被访问过</li><li>左斜线可以用 used_l[row+col]==1，表示访问过</li><li>右斜线可以用 used_r[n-1-row+col]==1，表示访问过</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202241020469.png" alt="image-20220224102045206"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    String[] path;<span class="hljs-comment">//最后用Arrays.asList转换</span><br>    <span class="hljs-keyword">int</span>[] used_c;<br>    <span class="hljs-keyword">int</span>[] used_l;<br>    <span class="hljs-keyword">int</span>[] used_r;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>        path = <span class="hljs-keyword">new</span> String[n];<br>        used_c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//是否用过当前列</span><br>        used_l = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>*n-<span class="hljs-number">1</span>];<span class="hljs-comment">//是否用过左斜线</span><br>        used_r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>*n-<span class="hljs-number">1</span>];<span class="hljs-comment">//是否用过右斜线</span><br>        helper(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row==n) &#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(Arrays.asList(path)));<span class="hljs-comment">//ATTENTION!</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        Arrays.fill(st, <span class="hljs-string">&#x27;.&#x27;</span>);<span class="hljs-comment">//初始化填充.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-keyword">if</span> (used_c[col]==<span class="hljs-number">1</span>||used_l[row+col]==<span class="hljs-number">1</span>||used_r[n-<span class="hljs-number">1</span>-row+col]==<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//set</span><br>            st[col]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>            used_c[col]=<span class="hljs-number">1</span>;<br>            used_l[row+col]=<span class="hljs-number">1</span>;<br>            used_r[n-<span class="hljs-number">1</span>-row+col]=<span class="hljs-number">1</span>;<br>            path[row]=<span class="hljs-keyword">new</span> String(st);<span class="hljs-comment">//转换成String填入path</span><br>            helper(n, row+<span class="hljs-number">1</span>); <span class="hljs-comment">//下一行</span><br>            <span class="hljs-comment">//reset</span><br>            st[col]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>            used_c[col]=<span class="hljs-number">0</span>;<br>            used_l[row+col]=<span class="hljs-number">0</span>;<br>            used_r[n-<span class="hljs-number">1</span>-row+col]=<span class="hljs-number">0</span>; <br><br>        &#125;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>使用的类型以及类型转化</p><p>引用类型要new一个再传参</p><p>String没有办法随便更改某一位的值，故这里用char[]再进行转换</p><p>说不定有其他更方便的数据结构</p><h2 id="37-解数独"><a href="https://leetcode-cn.com/problems/sudoku-solver/description/">37. 解数独</a><a class="header-anchor" href="#37-解数独">⁍</a></h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p><ul><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><blockquote><p><strong>思路</strong></p></blockquote><p>对每一个数看三个地方有没有重复解：</p><ul><li>行 new row[9]</li><li>列 new col[9]</li><li>块 new block[9]</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202241638565.png" alt="image-20220224163800447"></p><p>用行r和列c来表示第b块 <code>b=3*(r/3)+c/3</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">int</span>[][] col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">int</span>[][] block = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br><br>        <span class="hljs-comment">//记录已有的数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">int</span> num = board[i][j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                    row[num-<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>                    col[num-<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>                    block[num-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>*(i/<span class="hljs-number">3</span>)+j/<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        solve(board);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">9</span>; num++) &#123;<br>                    <span class="hljs-keyword">if</span> (!checkValid(board, i, j, num)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    board[i][j]=(<span class="hljs-keyword">char</span>)(num+<span class="hljs-string">&#x27;0&#x27;</span>);<br>                    row[num-<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>                    col[num-<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>                    block[num-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>*(i/<span class="hljs-number">3</span>)+j/<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (solve(board)) &#123;<span class="hljs-comment">//如果找到合适一组立刻返回</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                    &#125;<br><br>                    board[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>                    row[num-<span class="hljs-number">1</span>][i] = <span class="hljs-number">0</span>;<br>                    col[num-<span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>                    block[num-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>*(i/<span class="hljs-number">3</span>)+j/<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;                    <br><br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//找不到，返回错误</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//遍历完没有返回false，说明找到了合适棋盘位置了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row[num-<span class="hljs-number">1</span>][i]==<span class="hljs-number">1</span>||col[num-<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>||block[num-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>*(i/<span class="hljs-number">3</span>)+j/<span class="hljs-number">3</span>]==<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我的老天爷！！！把除号和模号搞错了！！纠结好久。。救命</p></blockquote><p>runtime beats 53.4 %</p><p>或许用其他方法更快？（位运算，见官方题解）</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 (programmercarl.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇）| 回溯法精讲！_哔哩哔哩_bilibili</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章锚点设置</title>
      <link href="/augu1sto/9395aea8f2ae/"/>
      <url>/augu1sto/9395aea8f2ae/</url>
      
        <content type="html"><![CDATA[<h2 id="当前文章锚点跳转">当前文章锚点跳转<a class="header-anchor" href="#当前文章锚点跳转">⁍</a></h2><p>使用 markdown 内置的链接方式即可，其中如果有空格，需要把空格换成连字符 <code>-</code> ，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[跳转到本文锚点](#hexo-标题与-id-关系)<br></code></pre></td></tr></table></figure><h2 id="站内文章链接">站内文章链接<a class="header-anchor" href="#站内文章链接">⁍</a></h2><p>官方有标签插件实现站内文章链接，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">post_link官方文档&#123;% post_link &#x27;hexo blog&#x27; %&#125;<br></code></pre></td></tr></table></figure><p>注意： 这儿优先使用文章 <a href="https://hexo.io/zh-cn/docs/front-matter"><code>Front-matter</code></a> 中的<code>permalink</code>字段，如果没有 <code>permalink</code> ，则使用 <code>文件名字</code>！</p><h2 id="站内其他文章锚点链接">站内其他文章锚点链接<a class="header-anchor" href="#站内其他文章锚点链接">⁍</a></h2><p>上面的 <code>post_link</code> 方式链接站内文章好用，但是不支持文章的锚点链接，我们需要换一种方式。</p><p>官方文档还有一个 <code>post_path</code> ，用于获取文章路径，结合 markdown 内置的链接方式，即可实现锚点超链接，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">post_path官方文档[hexo 安装](&#123;% post_path &#x27;hexo blog&#x27; %&#125;#安装)<br></code></pre></td></tr></table></figure><p>也可以使用 html a 标签实现，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;&#123;% post_path &#x27;hexo blog&#x27; %&#125;#安装&quot;&gt;hexo 安装&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>如果文章中有图片，可能会出现锚点位置不准确问题，原因是图片加载成功之后会把内容高度撑开。</li><li>如果如果有空格，需要把空格换成连字符 <code>-</code>。</li></ol><h2 id="站外文章锚点">站外文章锚点<a class="header-anchor" href="#站外文章锚点">⁍</a></h2><p>直接使用全路径即可，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[hexo 引用文章](https://hexo.io/zh-cn/docs/tag-plugins#%E5%BC%95%E7%94%A8%E6%96%87%E7%AB%A0)<br></code></pre></td></tr></table></figure><h2 id="注意">注意<a class="header-anchor" href="#注意">⁍</a></h2><p>要设置<code>anchors</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">anchors:</span><br>    <span class="hljs-comment"># Minimum level for ID creation. (Ex. h2 to h6)</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-number">2</span><br>    <span class="hljs-comment"># A suffix that is prepended to the number given if the ID is repeated.</span><br>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># If `true`, creates an anchor tag with a permalink besides the heading.</span><br>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Class used for the permalink anchor tag.</span><br>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">header-anchor</span><br>    <span class="hljs-comment"># Set to &#x27;right&#x27; to add permalink after heading</span><br>    <span class="hljs-attr">permalinkSide:</span> <span class="hljs-string">&#x27;right&#x27;</span><br>    <span class="hljs-comment"># The symbol used to make the permalink</span><br>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">⁍</span><br>    <span class="hljs-comment"># Transform anchor to (1) lower case; (2) upper case</span><br>    <span class="hljs-attr">case:</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># Replace space with a character</span><br>    <span class="hljs-attr">separator:</span> <span class="hljs-string">&#x27;-&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo建站与美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（十三）| 多线程</title>
      <link href="/augu1sto/9ded63ac5cb5/"/>
      <url>/augu1sto/9ded63ac5cb5/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程基础">多线程基础<a class="header-anchor" href="#多线程基础">⁍</a></h2><p>操作系统调度的最小任务单位是线程。</p><h3 id="进程-vs-线程">进程 vs 线程<a class="header-anchor" href="#进程-vs-线程">⁍</a></h3><p>多进程的 <strong>缺点</strong> 在于：</p><ul><li>开销更大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul><p>多进程的 <strong>优点</strong> 在于：</p><ul><li><strong>稳定性更高，</strong><ul><li>因为在多进程的情况下，一个进程崩溃不会影响其他进程，</li><li>而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</li></ul></li></ul><h3 id="多线程">多线程<a class="header-anchor" href="#多线程">⁍</a></h3><p>Java语言内置了多线程支持：</p><p>一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><h2 id="创建新线程">创建新线程<a class="header-anchor" href="#创建新线程">⁍</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> MyThread();<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 方法三 lamda表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>        &#125;);<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</p></li><li><p>一个线程对象必须且只能调用一次<code>start()</code>方法；</p></li><li><p>线程的执行代码写在<code>run()</code>方法中；</p></li><li><p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p></li><li><p>可以对线程设定优先级，设定优先级的方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Thread.setPriority(int n) // 1~10, 默认值5<br></code></pre></td></tr></table></figure><p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p></li><li><p><code>Thread.sleep()</code>可以把当前线程暂停一段时间(单位：毫秒)。</p></li></ul><h2 id="线程的状态">线程的状态<a class="header-anchor" href="#线程的状态">⁍</a></h2><p>Java线程对象<code>Thread</code>的状态包括：<code>New</code>、<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>、<code>Timed Waiting</code>和<code>Terminated</code>；</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；一旦<code>run()</code>方法执行完毕，线程就结束了。</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203031137010.png" alt="image-20220303113753841"></p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><h3 id="join">join<a class="header-anchor" href="#join">⁍</a></h3><p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，</p><p>主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。</p><p>主要作用就是 <strong>同步</strong> ，它可以使得线程之间的并行执行变为串行执行。</p><ul><li><p>可以指定等待时间（单位毫秒），超过等待时间线程仍然没有结束就不再等待；（join(0)等价于join()，等待无限时间）</p></li><li><p>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p></li><li><p>对没有启动的线程调用<code>join()</code>（即在<code>start</code>之前调用<code>join</code>），并不能起到同步作用</p></li></ul><blockquote><h4 id="join方法实现的原理">join方法实现的原理<a class="header-anchor" href="#join方法实现的原理">⁍</a></h4><p>join方法是通过调用线程的 <code>wait</code> 方法来达到同步的目的的。</p><p>例如，A线程中调用了B线程的join方法，</p><p>则相当于在A线程中调用了B线程的wait方法，A线程变成waiting状态</p><p>当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p></blockquote><h2 id="中断线程">中断线程<a class="header-anchor" href="#中断线程">⁍</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">t.interrupt(); <span class="hljs-comment">// 中断t线程</span><br></code></pre></td></tr></table></figure><p>中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p><ul><li><p>目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。</p></li><li><p>如果目标线程处于 <strong>等待状态</strong> ，该线程会捕获到<code>InterruptedException</code>；</p></li></ul><p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p><h3 id="volatile关键字——共享变量">volatile关键字——共享变量<a class="header-anchor" href="#volatile关键字——共享变量">⁍</a></h3><p>线程的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p><p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是 <strong>可见性问题</strong> ：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p><h2 id="守护线程-daemon-thread">守护线程 Daemon Thread<a class="header-anchor" href="#守护线程-daemon-thread">⁍</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t = <span class="hljs-keyword">new</span> MyThread();<br>t.setDaemon(<span class="hljs-keyword">true</span>);<br>t.start();<br></code></pre></td></tr></table></figure><p>守护线程是为其他线程服务的线程；</p><p>所有非守护线程都执行完毕后，虚拟机退出；</p><p>守护线程不能持有需要关闭的资源（如打开文件等）。</p><ul><li>如果注释掉，即都是非守护进程，则只要有一个进程在执行，程序都无法退出</li><li>守护线程会默默在后台执行，使得执行完毕的非守护线程可以正常退出<ul><li>举例： 垃圾回收机制</li></ul></li></ul><h2 id="线程同步">线程同步<a class="header-anchor" href="#线程同步">⁍</a></h2><p>如果多个线程同时读写共享变量，会出现数据不一致的问题，所以需要线程同步。</p><p><strong>原子操作</strong> ： 原子操作是指不能被中断的一个或一系列操作。对变量进行读取和写入时，结果要正确，必须保证是原子操作。</p><p>多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待</p><p>Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p><ol><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock) &#123; <span class="hljs-comment">// 加锁</span><br>                Counter.count += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-comment">// 释放锁</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</li><li>注意加锁对象必须是 <strong>同一个</strong> 实例；</li><li>对JVM定义的单个原子操作不需要同步。<ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；<ul><li><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</li></ul></li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul></li><li>如果是多行赋值语句，就必须保证是同步操作</li></ul><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 非原子操作</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first;<br>    <span class="hljs-keyword">int</span> last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">//加锁</span><br>            <span class="hljs-keyword">this</span>.first = first;<br>            <span class="hljs-keyword">this</span>.last = last;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 原子操作</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] pair;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] ps = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; first, last &#125;;<br>        <span class="hljs-keyword">this</span>.pair = ps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>            count += n;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 等价于下面的写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 锁住this</span><br>    count += n;<br>&#125; <span class="hljs-comment">// 解锁</span><br>    <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>            count -= n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> c1 = Counter();<br><span class="hljs-keyword">var</span> c2 = Counter();<br><br><span class="hljs-comment">// 对c1进行操作的线程:</span><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    c1.add();<br>&#125;).start();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    c1.dec();<br>&#125;).start();<br><br><span class="hljs-comment">// 对c2进行操作的线程:</span><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    c2.add();<br>&#125;).start();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    c2.dec();<br>&#125;).start();<br></code></pre></td></tr></table></figure><p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p><ul><li><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p></li><li><p><strong>不变类</strong> ，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p></li><li><p>最后，类似<code>Math</code>这些只提供静态方法， <strong>没有成员变量的类，也是线程安全的</strong> 。</p></li></ul><p>一个类没有特殊说明，默认不是thread-safe；</p><ul><li>大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</li></ul><p>对一个静态方法添加<code>synchronized</code>修饰符，锁住的是该类的<code>Class</code>实例。</p><h2 id="死锁">死锁<a class="header-anchor" href="#死锁">⁍</a></h2><p><strong>可重入锁：</strong></p><p>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p><p>Java的<code>synchronized</code>锁是可重入锁；</p><p><strong>死锁：</strong></p><p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(lockA) &#123; <span class="hljs-comment">// 获得lockA的锁</span><br>        <span class="hljs-keyword">this</span>.value += m;<br>        <span class="hljs-keyword">synchronized</span>(lockB) &#123; <span class="hljs-comment">// 获得lockB的锁</span><br>            <span class="hljs-keyword">this</span>.another += m;<br>        &#125; <span class="hljs-comment">// 释放lockB的锁</span><br>    &#125; <span class="hljs-comment">// 释放lockA的锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(lockB) &#123; <span class="hljs-comment">// 获得lockB的锁</span><br>        <span class="hljs-keyword">this</span>.another -= m;<br>        <span class="hljs-keyword">synchronized</span>(lockA) &#123; <span class="hljs-comment">// 获得lockA的锁</span><br>            <span class="hljs-keyword">this</span>.value -= m;<br>        &#125; <span class="hljs-comment">// 释放lockA的锁</span><br>    &#125; <span class="hljs-comment">// 释放lockB的锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序</p><h2 id="使用wait和notify">使用wait和notify<a class="header-anchor" href="#使用wait和notify">⁍</a></h2><p>必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法，因为<code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul><h2 id="使用reentrantlock">使用ReentrantLock<a class="header-anchor" href="#使用reentrantlock">⁍</a></h2><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>进行同步；</p><p><code>ReentrantLock</code>获取锁更安全；</p><p>必须先获取到锁，再进入<code>try &#123;...&#125;</code>代码块，最后使用<code>finally</code>保证释放锁；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            count += n;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用<code>tryLock()</code>尝试获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用condition">使用Condition<a class="header-anchor" href="#使用condition">⁍</a></h2><p><code>Condition</code>可以替代<code>wait</code>和<code>notify</code>；</p><p><code>Condition</code>对象必须从<code>Lock</code>对象获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition condition = lock.newCondition();<br></code></pre></td></tr></table></figure><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul><p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (condition.await(<span class="hljs-number">1</span>, TimeUnit.SECOND)) &#123;<br>    <span class="hljs-comment">// 被其他线程唤醒</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 指定时间内没有被其他线程唤醒</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用readwritelock">使用ReadWriteLock<a class="header-anchor" href="#使用readwritelock">⁍</a></h2><p>使用<code>ReadWriteLock</code>可以提高读取效率：</p><ul><li><code>ReadWriteLock</code>只允许一个线程写入；</li><li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li><li><code>ReadWriteLock</code>适合读多写少的场景。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReadWriteLock rwlock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock rlock = rwlock.readLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock wlock = rwlock.writeLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        wlock.lock(); <span class="hljs-comment">// 加写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            counts[index] += <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            wlock.unlock(); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] get() &#123;<br>        rlock.lock(); <span class="hljs-comment">// 加读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.copyOf(counts, counts.length);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rlock.unlock(); <span class="hljs-comment">// 释放读锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局限：</strong> 读的过程中不允许写</p><h2 id="使用stampedlock">使用StampedLock<a class="header-anchor" href="#使用stampedlock">⁍</a></h2><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><blockquote><ul><li><strong>乐观锁:</strong> 乐观地估计读的过程中大概率不会有写入</li><li><strong>悲观锁:</strong> 读的过程中拒绝有写入，也就是写入必须等待。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock stampedLock = <span class="hljs-keyword">new</span> StampedLock();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">double</span> deltaX, <span class="hljs-keyword">double</span> deltaY)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = stampedLock.writeLock(); <span class="hljs-comment">// 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            x += deltaX;<br>            y += deltaY;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">distanceFromOrigin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="hljs-comment">// 获得一个乐观读锁，返回版本号</span><br>        <span class="hljs-comment">// 注意下面两行代码不是原子操作</span><br>        <span class="hljs-comment">// 假设x,y = (100,200)</span><br>        <span class="hljs-keyword">double</span> currentX = x;<br>        <span class="hljs-comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span><br>        <span class="hljs-keyword">double</span> currentY = y;<br>        <span class="hljs-comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span><br>        <span class="hljs-comment">// 如果有写入，读取是错误的(100,400)</span><br>        <span class="hljs-keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="hljs-comment">// 通过validate()去验证版本号，检查乐观读锁后是否有其他写锁发生</span><br>            stamp = stampedLock.readLock(); <span class="hljs-comment">// 获取一个悲观读锁</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                currentX = x;<br>                currentY = y;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                stampedLock.unlockRead(stamp); <span class="hljs-comment">// 释放悲观读锁</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code>是不可重入锁，不能在一个线程中反复获取同一个锁。</p><h2 id="使用concurrent集合">使用Concurrent集合<a class="header-anchor" href="#使用concurrent集合">⁍</a></h2><p>使用<code>java.util.concurrent</code>包提供的线程安全的并发集合可以大大简化多线程编程：</p><p>多线程同时读写并发集合是安全的；</p><p>尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</p><table><thead><tr><th style="text-align:left">interface</th><th style="text-align:left">non-thread-safe</th><th style="text-align:left">thread-safe</th></tr></thead><tbody><tr><td style="text-align:left">List</td><td style="text-align:left">ArrayList</td><td style="text-align:left">CopyOnWriteArrayList</td></tr><tr><td style="text-align:left">Map</td><td style="text-align:left">HashMap</td><td style="text-align:left">ConcurrentHashMap</td></tr><tr><td style="text-align:left">Set</td><td style="text-align:left">HashSet / TreeSet</td><td style="text-align:left">CopyOnWriteArraySet</td></tr><tr><td style="text-align:left">Queue</td><td style="text-align:left">ArrayDeque / LinkedList</td><td style="text-align:left">ArrayBlockingQueue / LinkedBlockingQueue</td></tr><tr><td style="text-align:left">Deque</td><td style="text-align:left">ArrayDeque / LinkedList</td><td style="text-align:left">LinkedBlockingDeque</td></tr></tbody></table><h2 id="使用atomic">使用Atomic<a class="header-anchor" href="#使用atomic">⁍</a></h2><p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p><ul><li>原子操作实现了无锁的线程安全；</li><li>适用于计数器，累加器等。</li></ul><p>以<code>AtomicInteger</code>为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加1后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p><blockquote><p>CAS是指，在这个操作中，如果<code>AtomicInteger</code>的当前值是<code>prev</code>，那么就更新为<code>next</code>，返回<code>true</code>。如果<code>AtomicInteger</code>的当前值不是<code>prev</code>，就什么也不干，返回<code>false</code>。通过CAS操作并配合<code>do ... while</code>循环，即使其他线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。</p></blockquote><h2 id="使用线程池">使用线程池<a class="header-anchor" href="#使用线程池">⁍</a></h2><p><strong>线程池:</strong> 能接收大量小任务并进行分发处理的就是线程池。线程池内部维护了若干个线程:</p><ul><li>没有任务的时候，这些线程都处于等待状态。</li><li>如果有新任务，就分配一个空闲线程执行。</li><li>如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</li></ul><p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个固定大小的线程池:</span><br>        ExecutorService es = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-comment">// 提交任务</span><br>            es.submit(<span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;&quot;</span> + i));<br>        &#125;<br>        <span class="hljs-comment">// 关闭线程池:</span><br>        es.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p><ul><li>FixedThreadPool：线程数固定的线程池；</li><li>CachedThreadPool：线程数根据任务动态调整的线程池；</li><li>SingleThreadExecutor：仅单线程执行的线程池。</li></ul><p>线程池在程序结束的时候要关闭。</p><ul><li><code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。</li><li><code>shutdownNow()</code>会立刻停止正在执行的任务</li><li><code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</li></ul><h3 id="scheduledthreadpool">ScheduledThreadPool<a class="header-anchor" href="#scheduledthreadpool">⁍</a></h3><p>放入<code>ScheduledThreadPool</code>的任务可以定期反复执行。</p><p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><blockquote><p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务.</p></blockquote><h2 id="使用future">使用Future<a class="header-anchor" href="#使用future">⁍</a></h2><p>对线程池提交一个<code>Callable</code>任务，可以获得一个<code>Future</code>对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">4</span>); <br><span class="hljs-comment">// 定义任务:</span><br>Callable&lt;String&gt; task = <span class="hljs-keyword">new</span> Task();<br><span class="hljs-comment">// 提交任务并获得Future:</span><br>Future&lt;String&gt; future = executor.submit(task);<br><span class="hljs-comment">// 从Future获取异步执行返回的结果:</span><br>String result = future.get(); <span class="hljs-comment">// 可能阻塞</span><br></code></pre></td></tr></table></figure><p>可以用<code>Future</code>在将来某个时刻获取结果。一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p><ul><li><code>get()</code>：获取结果（可能会等待）</li><li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li><li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li><li><code>isDone()</code>：判断任务是否已完成。</li></ul><h2 id="使用completablefuture">使用CompletableFuture<a class="header-anchor" href="#使用completablefuture">⁍</a></h2><p><code>CompletableFuture</code>可以指定异步处理流程：</p><ul><li><code>thenAccept()</code>处理正常结果；</li><li><code>exceptional()</code>处理异常结果；</li><li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li><li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li></ul><h2 id="使用forkjoin">使用ForkJoin<a class="header-anchor" href="#使用forkjoin">⁍</a></h2><p>Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p><p>举例：对大数据进行并行求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建2000个随机数组成的数组:</span><br>        <span class="hljs-keyword">long</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">2000</span>];<br>        <span class="hljs-keyword">long</span> expectedSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i] = random(); <span class="hljs-comment">//构造数组</span><br>            expectedSum += array[i];<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Expected sum: &quot;</span> + expectedSum);<br>        <span class="hljs-comment">// fork/join:</span><br>        ForkJoinTask&lt;Long&gt; task = <span class="hljs-keyword">new</span> SumTask(array, <span class="hljs-number">0</span>, array.length);<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-comment">// </span><br>        Long result = ForkJoinPool.commonPool().invoke(task);<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;Fork/join sum: &quot;</span> + result + <span class="hljs-string">&quot; in &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; ms.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">random</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">10000</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THRESHOLD = <span class="hljs-number">500</span>; <span class="hljs-comment">// 判断任务大小的阈值</span><br>    <span class="hljs-keyword">long</span>[] array;<br>    <span class="hljs-keyword">int</span> start;<br>    <span class="hljs-keyword">int</span> end;<br><br>    SumTask(<span class="hljs-keyword">long</span>[] array, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end) &#123;<br>        <span class="hljs-keyword">this</span>.array = array;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end - start &lt;= THRESHOLD) &#123;<br>            <span class="hljs-comment">// 如果任务足够小,直接计算:</span><br>            <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; end; i++) &#123;<br>                sum += <span class="hljs-keyword">this</span>.array[i];<br>                <span class="hljs-comment">// 故意放慢计算速度:</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>        <span class="hljs-comment">// 任务太大,一分为二:</span><br>        <span class="hljs-keyword">int</span> middle = (end + start) / <span class="hljs-number">2</span>;<br>        System.out.println(String.format(<span class="hljs-string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));<br>        SumTask subtask1 = <span class="hljs-keyword">new</span> SumTask(<span class="hljs-keyword">this</span>.array, start, middle);<br>        SumTask subtask2 = <span class="hljs-keyword">new</span> SumTask(<span class="hljs-keyword">this</span>.array, middle, end);<br>        <span class="hljs-comment">// invokeAll会并行运行两个子任务:</span><br>        invokeAll(subtask1, subtask2);<br>        <span class="hljs-comment">// 获得子任务的结果:</span><br>        Long subresult1 = subtask1.join();<br>        Long subresult2 = subtask2.join();<br>        Long result = subresult1 + subresult2;<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + subresult1 + <span class="hljs-string">&quot; + &quot;</span> + subresult2 + <span class="hljs-string">&quot; ==&gt; &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用threadlocal">使用ThreadLocal<a class="header-anchor" href="#使用threadlocal">⁍</a></h2><p>在代码中调用<code>Thread.currentThread()</code>获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字。</p><p><strong>上下文（Context）：</strong> 在一个线程中，横跨若干方法调用，需要传递的对象，是一种状态，可以是用户身份、任务信息等。</p><p><code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processUser</span><span class="hljs-params">(user)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        threadLocalUser.set(user);<br>        step1();<br>        step2();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        threadLocalUser.remove(); <span class="hljs-comment">// 清除</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123;<br>    User u = threadLocalUser.get();<br>    log();<br>    printUser();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">()</span> </span>&#123;<br>    User u = threadLocalUser.get();<br>    println(u.name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;<br>    User u = threadLocalUser.get();<br>    checkUser(u.id);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ThreadLocal</code>表示线程的“局部变量”，它确保每个线程的<code>ThreadLocal</code>变量都是各自独立的；</p><p><code>ThreadLocal</code></p><p>使用<code>ThreadLocal</code>要用<code>try ... finally</code>结构，并在<code>finally</code>中清除。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|二叉树</title>
      <link href="/augu1sto/e55c8c160eac/"/>
      <url>/augu1sto/e55c8c160eac/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><a class="header-anchor" href="#基础知识">⁍</a></h2><h3 id="二叉树的定义">二叉树的定义<a class="header-anchor" href="#二叉树的定义">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>  TreeNode left;<br>  TreeNode right;<br>  TreeNode() &#123;&#125;<br>  TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>  TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>    <span class="hljs-keyword">this</span>.val = val;<br>    <span class="hljs-keyword">this</span>.left = left;<br>    <span class="hljs-keyword">this</span>.right = right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树种类">二叉树种类<a class="header-anchor" href="#二叉树种类">⁍</a></h3><ul><li><p>满二叉树： 每一层都是满的，第k层有2<sup>k-1</sup>个节点</p></li><li><p>完全二叉树： 最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2<sup>h-1</sup>  个节点。</p><blockquote><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p></blockquote></li><li><p>二叉搜索树： 有 <strong>数值</strong> ， <strong>二叉搜索树是一个有序树</strong> 。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>下面这两棵树都是搜索树</p><p><img src="https://img-blog.csdnimg.cn/20200806190304693.png" alt="img"></p></li><li><p>平衡二叉搜索树（AVL（Adelson-Velsky and Landis）树）</p><ul><li>它是一棵 <strong>空树</strong> 或它的左右两个子树的 <strong>高度差</strong> 的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li><li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</li></ul></li></ul><h3 id="二叉树的存储方式">二叉树的存储方式<a class="header-anchor" href="#二叉树的存储方式">⁍</a></h3><p>二叉树可以链式存储，也可以顺序存储（用数组）。</p><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><h3 id="二叉树的遍历方式">二叉树的遍历方式<a class="header-anchor" href="#二叉树的遍历方式">⁍</a></h3><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）：中左右</li><li>中序遍历（递归法，迭代法）：左中右</li><li>后序遍历（递归法，迭代法）：左右中</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><h4 id="递归遍历">递归遍历<a class="header-anchor" href="#递归遍历">⁍</a></h4><blockquote><h5 id="递归算法三要素">递归算法三要素<a class="header-anchor" href="#递归算法三要素">⁍</a></h5><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol></blockquote><h5 id="144-二叉树的前序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a><a class="header-anchor" href="#144-二叉树的前序遍历">⁍</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历·递归·LC144_二叉树的前序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function">ArrayList&lt;Integer&gt; <span class="hljs-title">preOrderReverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        preOrder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 确定递归函数的参数和返回值，传入ArrayList记录节点都数值</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">// 2. 终止条件，当前遍历的节点空了，那么本层递归就要要结束</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3. 确定单层递归的逻辑，三种遍历方法就这里不一样</span><br>        result.add(root.val);           <span class="hljs-comment">// 中</span><br>        preOrder(root.left, result);    <span class="hljs-comment">// 左</span><br>        preOrder(root.right, result);   <span class="hljs-comment">// 右</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="94-二叉树的中序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><a class="header-anchor" href="#94-二叉树的中序遍历">⁍</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中序遍历·递归·LC94_二叉树的中序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        inorder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>        inorder(root.right, list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="145-二叉树的后序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/">145. 二叉树的后序遍历</a><a class="header-anchor" href="#145-二叉树的后序遍历">⁍</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 后序遍历·递归·LC145_二叉树的后序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        postorder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left, list);<br>        postorder(root.right, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代遍历">迭代遍历<a class="header-anchor" href="#迭代遍历">⁍</a></h4><p>用栈的方式实现</p><p><strong>前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p><h5 id="144-二叉树的前序遍历-2"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a><a class="header-anchor" href="#144-二叉树的前序遍历-2">⁍</a></h5><p>按顺序将节点入栈，入栈的同时输出到result，到空的时候出栈，找右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        TreeNode node = root;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() || node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>                res.add(node.val);<br>                stack.push(node);<br>                node = node.left;<br>            &#125;<br>            node = stack.pop();<br>            node = node.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//作者：LeetCode-Solution</span><br><span class="hljs-comment">//链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/</span><br><br></code></pre></td></tr></table></figure><p><strong>改掉二重循环</strong></p><p>—— 出栈的时候把节点值加入result，要求中节点入栈后，先将右节点入栈，再将左节点入栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>            TreeNode node = stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                stack.push(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                stack.push(node.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="94-二叉树的中序遍历-2"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><a class="header-anchor" href="#94-二叉树的中序遍历-2">⁍</a></h5><p>按顺序将节点入栈，出栈的时候把值加入result</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        Deque&lt;TreeNode&gt; stk = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stk.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                stk.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stk.pop();<br>            res.add(root.val);<br>            <span class="hljs-comment">// 若有右节点，证明它也是这一层的“中”节点</span><br>            <span class="hljs-comment">// 若是最左的叶子节点，则返回Null，后面继续出栈</span><br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="145-二叉树的后序遍历-2"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a><a class="header-anchor" href="#145-二叉树的后序遍历-2">⁍</a></h5><p>与中序的不同之处在于：</p><ul><li>中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。</li><li>后序遍历中，从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。</li></ul><p>因此，我们在后序遍历中，引入了一个prev来记录历史访问记录。</p><ul><li>当访问完一棵子树的时候，我们用prev指向该节点。</li><li>这样，在回溯到父节点的时候，我们可以依据prev是指向左子节点，还是右子节点，来判断父节点的访问情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        TreeNode prev = <span class="hljs-keyword">null</span>;<br>        <br>        <span class="hljs-comment">//主要思想：</span><br>        <span class="hljs-comment">//由于在某颗子树访问完成以后，接着就要回溯到其父节点去</span><br>        <span class="hljs-comment">//因此可以用prev来记录访问历史，在回溯到父节点时，可以由此来判断，上一个访问的节点是否为右子树</span><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            <span class="hljs-comment">//从栈中弹出的元素，左子树一定是访问完了的</span><br>            root = stack.pop();<br>            <span class="hljs-comment">//现在需要确定的是是否有右子树，或者右子树是否访问过</span><br>            <span class="hljs-comment">//如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时</span><br>            <span class="hljs-comment">//说明可以访问当前节点</span><br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span> || root.right == prev) &#123;<br>                res.add(root.val);<br>                <span class="hljs-comment">//更新历史访问记录，这样回溯的时候父节点可以由此判断右子树是否访问完成</span><br>                prev = root;<br>                root = <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果右子树没有被访问，那么将当前节点压栈，访问右子树</span><br>                stack.push(root);<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="统一迭代法">统一迭代法<a class="header-anchor" href="#统一迭代法">⁍</a></h4><p><strong>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        Deque&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>                st.pop(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-keyword">null</span>) st.push(node.right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br>                <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-keyword">null</span>) st.push(node.left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                st.push(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.push(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br>                <br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.pop();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.peek();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.pop();<br>                result.add(node.val); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⭐-广度优先：层序遍历">⭐ 广度优先：层序遍历<a class="header-anchor" href="#⭐-广度优先：层序遍历">⁍</a></h4><h5 id="102-二叉树的层序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a><a class="header-anchor" href="#102-二叉树的层序遍历">⁍</a></h5><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br></code></pre></td></tr></table></figure><p><mark>不要把输入当作数组，输入还是树结构！！</mark></p><p>方法一：递归，记录树深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 102.二叉树的层序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        levelDFS(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelDFS</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(result.size()&lt;level+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 如果是新的一层，则加进结果</span><br>            List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            result.add(itemList);<br>        &#125;<br>        <span class="hljs-comment">// 将root节点加进相应层</span><br>        result.get(level).add(root.val);<br>        levelDFS(root.left, level+<span class="hljs-number">1</span>);<br>        levelDFS(root.right, level+<span class="hljs-number">1</span>);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：迭代，可借助队列实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 102.二叉树的层序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-comment">//创建队列存访二叉树节点（注意类型是TreeNode！）</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-comment">//先将第一个根节点加入队列</span><br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <span class="hljs-comment">//将队列中的元素都加入列表</span><br>            <span class="hljs-keyword">int</span> len = que.size();<br>            <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>                TreeNode curNode = que.poll();<br>                itemList.add(curNode.val);<br>                <span class="hljs-comment">//将左右节点入队</span><br>                <span class="hljs-keyword">if</span>(curNode.left!=<span class="hljs-keyword">null</span>) que.offer(curNode.left);<br>                <span class="hljs-keyword">if</span>(curNode.right!=<span class="hljs-keyword">null</span>) que.offer(curNode.right);<br>                len--;<br>            &#125;<br>            result.add(itemList);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>相关题：</strong></p><ul><li><a href="#102.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">102.二叉树的层序遍历</a></li><li>107.二叉树的层次遍历II</li><li>199.二叉树的右视图</li><li><a href="#637.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC">637.二叉树的层平均值</a></li><li>429.N叉树的层序遍历</li><li>515.在每个树行中找最大值</li><li>116.填充每个节点的下一个右侧节点指针</li><li>117.填充每个节点的下一个右侧节点指针II</li><li><a href="#104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">104.二叉树的最大深度</a></li><li>111.二叉树的最小深度</li></ul><h3 id="⭐-递归函数的返回值">⭐ 递归函数的返回值<a class="header-anchor" href="#⭐-递归函数的返回值">⁍</a></h3><p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且<u>不用处理</u>递归返回值，递归函数就不要返回值。（113.路径总和ii）</li><li>如果需要搜索整棵二叉树且<u>需要处理</u>递归返回值，递归函数就需要返回值。 （这种情况我们在<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li><li>如果要搜索<u>其中一条符合条件的路径</u>，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112.路径总和 的情况）</li></ul><p>搜索一条边的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (递归函数(root-&gt;left)) return ;<br><br>if (递归函数(root-&gt;right)) return ;<br></code></pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">left = 递归函数(root-&gt;left);<br>right = 递归函数(root-&gt;right);<br>left与right的逻辑处理;<br></code></pre></td></tr></table></figure><h3 id="⭐-递归与叶子节点">⭐ 递归与叶子节点<a class="header-anchor" href="#⭐-递归与叶子节点">⁍</a></h3><p>有些情况下，递归需要在叶子节点处终止，此时在递归左右子节点的时候判断是否为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">递归函数(root, ...)&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//终止逻辑</span><br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-keyword">null</span>) 递归函数(root.left, ...);<br>    <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-keyword">null</span>) 递归函数(root.right, ...);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先</a><a class="header-anchor" href="#236-二叉树的最近公共祖先">⁍</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>// 输入和返回的类型都是TreeNode<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><p>❌错解：</p><ul><li><p>分别记录先序遍历到p和q节点的路径，比对两个路径最后一个相同的节点</p></li><li><p>该节点可能是最近公共祖先，但也有可能是最近公共祖先的左子节点！</p><ul><li><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[3,5,1,6,2,0,8,null,null,7,4]<br>5<br>1<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>✔️正解<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><p><strong>遍历方式选择：</strong> 自底向上查找 --&gt; 二叉树回溯 --&gt; 后序遍历(最先处理的是叶子节点)</p><p>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</p><p><strong>递归三部曲：</strong></p><ul><li><p><strong>确定递归函数返回值及参数</strong></p><p>如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p></li><li><p><strong>确定终止条件</strong></p><p>如果找到了 节点p或者q，或者遇到空节点，就返回。</p></li><li><p><strong>确定单层递归逻辑</strong></p><ul><li><p>本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断</p></li><li><p>需要遍历整棵树，用left和right接住左子树和右子树的返回值，再处理left与right逻辑</p><ul><li><p>如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</p></li><li><p>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</p></li><li><p>如果left和right中有一个为空、一个不为空，就返回不为空的那个。</p><p><img src="https://img-blog.csdnimg.cn/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件和返回值</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p|| root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 后序遍历</span><br>        TreeNode left = lowestCommonAncestor(root.left, p, q);<br>        TreeNode right = lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-comment">// 处理左右子树逻辑</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 两个都空，返回空</span><br>            <span class="hljs-keyword">return</span> left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left !=<span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-comment">// 两个都不为空，返回根节点</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left !=<span class="hljs-keyword">null</span> )&#123;   <span class="hljs-comment">// 只有一个节点不为空，返回不为空的节点</span><br>            <span class="hljs-keyword">return</span> left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="637-二叉树的层平均值"><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值</a><a class="header-anchor" href="#637-二叉树的层平均值">⁍</a></h2><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 10<sup>-5</sup> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong> 层序遍历</p></blockquote><p><strong>注意点：</strong></p><ul><li><p>将sum写作double型，计算平均值时可以自动进行类型转换</p></li><li><p>提前记录队列长度</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Double&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Double&gt;();<br>        <br>        <span class="hljs-comment">// 二叉树非空</span><br>        <span class="hljs-comment">// 创建队列 层序遍历</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-comment">// 根节点入队</span><br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意直接写为double类型</span><br>            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> lenq = que.size(); <span class="hljs-comment">//因为后面涉及到出队操作，所以提前记录que的长度</span><br><br>            <span class="hljs-keyword">while</span>(len &lt; lenq)&#123;<br>                <span class="hljs-comment">// 出队</span><br>                TreeNode curNode = que.poll();<br>                <span class="hljs-comment">// 加入当前节点</span><br>                sum += curNode.val;<br>                <span class="hljs-comment">// 左右节点入队</span><br>                <span class="hljs-keyword">if</span>(curNode.left!=<span class="hljs-keyword">null</span>) que.offer(curNode.left);<br>                <span class="hljs-keyword">if</span>(curNode.right!=<span class="hljs-keyword">null</span>) que.offer(curNode.right);<br>                len++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!que.isEmpty()) &#123;<br>                <br>            &#125;<br>            result.add(sum/lenq);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度</a><a class="header-anchor" href="#104-二叉树的最大深度">⁍</a></h2><p>给定一个二叉树，找出其最大深度。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  3<br> / \<br>9  20<br>  /  \<br> 15   7<br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><blockquote><p>⭐ <strong>思路一：</strong> 深度=自底而上–&gt;后序遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> deepl = maxDepth(root.left);<br>        <span class="hljs-keyword">int</span> deepr = maxDepth(root.right);<br>        <span class="hljs-comment">// 返回更大的深度</span><br>        <span class="hljs-keyword">return</span> deepl&gt;deepr?(deepl+<span class="hljs-number">1</span>):(deepr+<span class="hljs-number">1</span>);<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路二：</strong> 迭代法 层序遍历，记录深度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 迭代法，使用层序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        deque.offer(root);<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!deque.isempty()) &#123;<br>            <span class="hljs-keyword">int</span> size = deque.size();<br>            depth++;<span class="hljs-comment">//记录深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                treenode poll = deque.poll();<br>                <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-keyword">null</span>) &#123;<br>                    deque.offer(poll.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-keyword">null</span>) &#123;<br>                    deque.offer(poll.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度</a><a class="header-anchor" href="#111-二叉树的最小深度">⁍</a></h2><h3 id="方法一：-递归法">方法一： 递归法<a class="header-anchor" href="#方法一：-递归法">⁍</a></h3><p>后序遍历</p><p>❌误区：</p><p>不能仿照<a href="#104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树的最大深度</a>写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int leftDepth = getDepth(node.left);<br>int rightDepth = getDepth(node.right);<br>return Math.min(leftDepth, rightDepth) + 1;<br></code></pre></td></tr></table></figure><p>这个代码就犯了此图中的误区：</p><p><img src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度"></p><p>如果这么求的话，没有左孩子的分支会算为最短深度。</p><p>✔️正解</p><ul><li>左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。</li><li>右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1</li><li>左右子树都不为空，按上面的写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> deepl = minDepth(root.left);<br>        <span class="hljs-keyword">int</span> deepr = minDepth(root.right);<br>        <span class="hljs-keyword">if</span> (root.left==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> deepr+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> deepl+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Math.min(deepl,deepr)+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：迭代法">方法二：迭代法<a class="header-anchor" href="#方法二：迭代法">⁍</a></h3><p>判断如果是叶子节点，直接返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            deep++; <span class="hljs-comment">// 记录量</span><br>            <span class="hljs-keyword">int</span> len = que.size();<br>            <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>                TreeNode curNode = que.poll();<br>                <span class="hljs-keyword">if</span> (curNode.left==<span class="hljs-keyword">null</span>&amp;&amp;curNode.right==<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//是叶子节点</span><br>                    <span class="hljs-keyword">return</span> deep;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (curNode.left != <span class="hljs-keyword">null</span>) que.offer(curNode.left);<br>                <span class="hljs-keyword">if</span> (curNode.right != <span class="hljs-keyword">null</span>) que.offer(curNode.right);<br>                len--; <span class="hljs-comment">//千万不要忘！！！！！！！</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep; <span class="hljs-comment">//最终的返回值！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="559-n-叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/description/">559. N 叉树的最大深度</a><a class="header-anchor" href="#559-n-叉树的最大深度">⁍</a></h2><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化 <strong>表示</strong> ，每组子节点由空值分隔（请参见示例）。（表示方法而已！）</p><p>⭐N叉树表示方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; children;<span class="hljs-comment">//List</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _val)</span> </span>&#123;<br>        val = _val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;<br>        val = _val;<br>        children = _children;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong></p></blockquote><p>和<a href="#104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树的最大深度</a>类似，左右子节点变为遍历一个列表的孩子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxd = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node i: root.children) &#123;<br>            <span class="hljs-keyword">int</span> di = maxDepth(i);<br>            maxd = Math.max(maxd, di); <br>        &#125;<br>        <span class="hljs-keyword">return</span> maxd+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">543. 二叉树的直径</a><a class="header-anchor" href="#543-二叉树的直径">⁍</a></h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    1<br>   / \<br>  2   3<br> / \     <br>4   5    <br></code></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><blockquote><p><strong>思路</strong></p></blockquote><p>长度 = 左子树深度 + 右子树深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxL = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> deep = getDepth(root);<br>        <span class="hljs-keyword">return</span> maxL;    <br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> deepl = getDepth(node.left);<br>        <span class="hljs-keyword">int</span> deepr = getDepth(node.right);<br>        <span class="hljs-comment">// 记录最长距离</span><br>        maxL = Math.max(maxL, deepl + deepr);<br>        <span class="hljs-keyword">return</span> Math.max(deepl, deepr)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点个数"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数</a><a class="header-anchor" href="#222-完全二叉树的节点个数">⁍</a></h2><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><blockquote><p><strong>思路：</strong> 利用完全二叉树的性质</p></blockquote><p>完全二叉树只有两种情况：</p><ul><li><p>满二叉树：可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1</p></li><li><p>最后一层叶子节点没有满。</p><ul><li><p>分别递归左孩子，和右孩子，递归到某一深度一定会有</p><ul><li><ol><li>左孩子为满二叉树</li><li>右孩子为满二叉树</li></ol><p>然后依然可以按照满二叉树来计算。</p></li></ul></li></ul></li></ul><p><strong>完全二叉树获得深度只需要不断遍历左节点就行了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// root.left为空时，说明只有一个节点即root，情况被包含进去了</span><br>        <span class="hljs-keyword">int</span> depL = getDepth(root.left);<br>        <span class="hljs-keyword">int</span> depR = getDepth(root.right);<br>        <span class="hljs-keyword">if</span> (depL==depR) &#123;<span class="hljs-comment">//说明左子树是满二叉树</span><br>            <span class="hljs-comment">//左子树+右子树+根节点</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;depL)-<span class="hljs-number">1</span> + countNodes(root.right) + <span class="hljs-number">1</span>; <br>            <span class="hljs-comment">//1&lt;&lt;depL-1 = (int)Math.pow(2, depL)-1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 否则，左子树非满二叉树，右子树是满二叉树</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;depR)-<span class="hljs-number">1</span> + countNodes(root.left) + <span class="hljs-number">1</span> ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            root = root.left;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：$O(\log^2 n)$</p><h2 id="110-平衡二叉树"><a href="https://leetcode-cn.com/problems/balanced-binary-tree/description/">110. 平衡二叉树</a><a class="header-anchor" href="#110-平衡二叉树">⁍</a></h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><blockquote><p><strong>思路：</strong> 递归算深度，设置标志位-1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (getDepth(root)==-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> dL = getDepth(root.left);<br>        <span class="hljs-keyword">int</span> dR = getDepth(root.right);<br><br>        <span class="hljs-comment">// 如果已经不是平衡树了，直接返回-1</span><br>        <span class="hljs-keyword">if</span> (dL==-<span class="hljs-number">1</span> || dR==-<span class="hljs-number">1</span> || Math.abs(dL-dR)&gt;<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Math.max(dL, dR)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a><a class="header-anchor" href="#226-翻转二叉树">⁍</a></h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><blockquote><p><strong>思路：</strong></p></blockquote><p>先序遍历/后序遍历二叉树，交换左右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">//后序遍历</span><br>    invertTree(root.left);<br>    invertTree(root.right);<br>    swapNode(root);<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapNode</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    TreeNode tmp = root.left;<br>    root.left = root.right;<br>    root.right = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a><a class="header-anchor" href="#101-对称二叉树">⁍</a></h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [1,2,2,3,4,4,3]<br>输出：true<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><ul><li>相当于比较根节点的左子树和右子树</li><li>后序遍历：<ul><li>左子树：左右中</li><li>右子树：右左中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//树中节点数目在范围 [1, 1000] 内</span><br>    <span class="hljs-keyword">return</span> biPostOrder(root.left, root.right);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">biPostOrder</span><span class="hljs-params">(TreeNode rootL, TreeNode rootR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((rootL == <span class="hljs-keyword">null</span> &amp;&amp; rootR != <span class="hljs-keyword">null</span>) || (rootL != <span class="hljs-keyword">null</span> &amp;&amp; rootR == <span class="hljs-keyword">null</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rootL == <span class="hljs-keyword">null</span> &amp;&amp; rootR == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rootL.val != rootR.val) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// if (rootL.val == rootR.val) &#123;</span><br>    <span class="hljs-comment">//   return true; 不可以直接判断！！要进底下递归</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> (<br>      biPostOrder(rootL.left, rootR.right) &amp;&amp;<br>      biPostOrder(rootL.right, rootR.left)<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a><a class="header-anchor" href="#257-二叉树的所有路径">⁍</a></h2><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><blockquote><p><strong>思路：</strong></p></blockquote><p>用先序遍历，在叶子节点处终止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;String&gt; paths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    findPath(root, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> paths;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPath</span><span class="hljs-params">(TreeNode root, String path)</span> </span>&#123;<br>    path = path + <span class="hljs-string">&quot;-&gt;&quot;</span> + String.valueOf(root.val);<br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>      paths.add(path.substring(<span class="hljs-number">2</span>)); <span class="hljs-comment">//去除开头的&quot;-&gt;&quot;</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) findPath(root.left, path);<br>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) findPath(root.right, path);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索"><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a><a class="header-anchor" href="#700-二叉搜索树中的搜索">⁍</a></h2><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p><h3 id="递归法">递归法<a class="header-anchor" href="#递归法">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 递归，利用二叉搜索树特点，优化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.val == val) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val &lt; root.val) &#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代法">迭代法<a class="header-anchor" href="#迭代法">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">//节点数在 [1, 5000] 范围内</span><br><br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (root.val == val) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (root.val &gt; val) &#123;<br>        root = root.left;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        root = root.right;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>清楚定义就行</p><h2 id="⭐-构造二叉树">⭐ 构造二叉树<a class="header-anchor" href="#⭐-构造二叉树">⁍</a></h2><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树</a><a class="header-anchor" href="#106-从中序与后序遍历序列构造二叉树">⁍</a></h3><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p><p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p><blockquote><p><strong>思路</strong></p></blockquote><p>后序遍历：左右中</p><p>中序遍历：左中右</p><p>通过后序遍历，从后往前，可以确定根节点</p><p>然后通过中序遍历，确定左子树的大小</p><p><img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p><p>逻辑：</p><ul><li><p>后序找根root</p><ol><li><p>遍历中序到根，确定左子树长度<code>llen</code></p></li><li><p>后序中根据左子树长度，找到左子树的根</p><p><code>root_l = post_start+llen-1;</code></p></li><li><p>算出后序中右子树起始位置<br><code>post_start_r = post_start+llen;</code></p><p>左子树起始即原来的起始位置</p><p><code>post_start_l = post_start;</code></p></li><li><p>中序遍历再＋1得到右子树在中序遍历中的起始位置</p><p><code>in_start_r = in_start+llen+1;</code></p><p>左子树的起始位置即原来的起始位置</p><p><code>in_start_l = in_start;</code></p></li></ol></li><li><p>右子树的根就是后序遍历中的下一个</p><p><code>root_r = root-1;</code></p></li></ul><p>终止：</p><p>通过后序的长度来判断元素个数</p><ul><li>没有元素：返回Null</li><li>只剩一个元素（叶子节点），返回节点</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202221846566.png" alt="image-20220222184650406"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> buildTree1(inorder, postorder, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, postorder.length-<span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> in_start, <span class="hljs-keyword">int</span> post_start, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">if</span> (root-post_start+<span class="hljs-number">1</span>&lt;<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//没有元素了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-post_start+<span class="hljs-number">1</span>==<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//只剩一个元素（无左右节点了）</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(postorder[root]);<br>        &#125;<br><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(postorder[root]); <span class="hljs-comment">// 倒序创建根节点</span><br>        <span class="hljs-keyword">int</span> llen = <span class="hljs-number">0</span>; <span class="hljs-comment">//左子树长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = in_start; i &lt; inorder.length ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i]==postorder[root]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            llen++;<br>        &#125;<br><br><br>        <span class="hljs-keyword">int</span> root_l = post_start+llen-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_r = root-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> post_start_l = post_start;<br>        <span class="hljs-keyword">int</span> post_start_r = post_start+llen;<br>        <span class="hljs-keyword">int</span> in_start_l = in_start;<br>        <span class="hljs-keyword">int</span> in_start_r = in_start+llen+<span class="hljs-number">1</span>;<br><br><br>        node.left = buildTree1(inorder, postorder, in_start_l,  post_start_l, root_l);<br>        node.right = buildTree1(inorder, postorder, in_start_r, post_start_r, root_r);<br>        <span class="hljs-keyword">return</span> node;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树</a><a class="header-anchor" href="#105-从前序与中序遍历序列构造二叉树">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> buildTree1(preorder, inorder, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, preorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> in_start, <span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> pre_end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root&gt;pre_end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(preorder[root]);<br><br>        <span class="hljs-keyword">if</span> (root==pre_end) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> llen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = in_start; i &lt; inorder.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i]==preorder[root]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            llen++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> in_start_l = in_start;<br>        <span class="hljs-keyword">int</span> in_start_r = in_start+llen+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_l = root+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_r = root+llen+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> pre_end_l = root+llen;<br>        <span class="hljs-keyword">int</span> pre_end_r = pre_end; <br><br>        node.left = buildTree1(preorder, inorder, in_start_l, root_l, pre_end_l);<br>        node.right = buildTree1(preorder, inorder, in_start_r, root_r, pre_end_r);<br>        <span class="hljs-keyword">return</span> node;<br><br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p><blockquote><p>另一个方法 ： <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/99ljye/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p>先遍历一遍中序的数组，以（值，下标）的形式存储到dict里，用的时候直接取出即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value:inorder) &#123;<br>            map.put(value,i);<br>            i++;<br>        &#125;<br>        TreeNode root = helper(preorder, <span class="hljs-number">0</span>, inorder, <span class="hljs-number">0</span>, preorder.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root &gt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(preorder[root]);<br><br>        <span class="hljs-keyword">int</span> p = map.get(preorder[root]); <span class="hljs-comment">// 中序遍历中根节点的位置，据此划分左子树和右子树</span><br>        <span class="hljs-keyword">int</span> leftLen = p - start;<br>        <span class="hljs-keyword">int</span> left = root+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right = left+leftLen;<br>        node.left = helper(preorder, left, inorder, start, right-<span class="hljs-number">1</span>);<br>        node.right = helper(preorder, right, inorder, start+leftLen+<span class="hljs-number">1</span>, end);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="108-将有序数组转换为二叉搜索树"><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树</a><a class="header-anchor" href="#108-将有序数组转换为二叉搜索树">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, nums.length);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">//左闭右开</span><br>    <span class="hljs-keyword">if</span> (left &gt; right - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left == right - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(nums[left]);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br>    root.left = buildTree(nums, left, mid);<br>    root.right = buildTree(nums, mid + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似： <a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></p><h3 id="⭐-109-有序链表转换二叉搜索树">⭐ <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a><a class="header-anchor" href="#⭐-109-有序链表转换二叉搜索树">⁍</a></h3><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><blockquote><p><strong>思路：</strong></p></blockquote><p>链表–&gt;数组–&gt;二叉树？————额外的空间 ❌（也不是完全不行啦）</p><p>✔ 快慢指针找中间的节点</p><p>快指针一次移动2，慢指针一次移动1</p><p>最后快指针到达右端点或快指针的下一个节点是右端点时，慢指针就可以指向中间节点。</p><p>同时，没有必要“先”找到中间节点：我们可以使用 <strong>中序遍历</strong> 先构建了左子树，建立结束后，指针自然指向中间结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> ListNode helpHead;<span class="hljs-comment">//重要！！不能直接放进去递归</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    helpHead = head;<br>    <span class="hljs-keyword">int</span> len = getListLength(head);<br>    <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>, len);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getListLength</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>      head = head.next;<br>      cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode();<br>    root.left = helper(left, mid);<br>    root.val = helpHead.val;<br>    helpHead = helpHead.next;<br>    root.right = helper(mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⭐-701-二叉搜索树中的插入操作">⭐ <a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a><a class="header-anchor" href="#⭐-701-二叉搜索树中的插入操作">⁍</a></h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><blockquote><p><strong>思路：</strong></p></blockquote><p>不需要改变二叉树结构</p><p>只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);<br>            <br>        <span class="hljs-keyword">if</span> (root.val &lt; val)&#123;<br>            root.right = insertIntoBST(root.right, val); <span class="hljs-comment">// 递归创建右子树</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; val)&#123;<br>            root.left = insertIntoBST(root.left, val); <span class="hljs-comment">// 递归创建左子树</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a><a class="header-anchor" href="#450-删除二叉搜索树中的节点">⁍</a></h2><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [5,3,6,2,4,null,7], key = 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><ul><li>假如要删除的节点为叶节点，直接删除</li><li>假如要删除的节点左节点不为空但右节点为空，则直接用左节点替换当前节点</li><li>假如要删除的节点右节点不为空但左节点为空，则直接用右节点替换当前节点</li><li>最后要删除的节点左右均不为空，寻找右子树中最左节点，用这个最左节点（就是后继节点）替换当前节点，并且将最左节点从原位置删除。 代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> helper(root, key);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>      root.left = helper(root.left, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>      root.right = helper(root.right, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//找到了，删除</span><br>      <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right; <span class="hljs-comment">//左孩子空，直接补上右节点</span><br>      <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br>      <span class="hljs-comment">//删除右子树的最左节点</span><br>      TreeNode tmp = root.right;<br>      <span class="hljs-keyword">while</span> (tmp.left != <span class="hljs-keyword">null</span>) &#123;<br>        tmp = tmp.left; <span class="hljs-comment">//找到最左节点</span><br>      &#125;<br>      root.val = tmp.val; <span class="hljs-comment">//赋值</span><br>      root.right = helper(root.right, tmp.val); <span class="hljs-comment">//删除右子树最左节点的值</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="449-序列化和反序列化二叉搜索树"><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/description/">449. 序列化和反序列化二叉搜索树</a><a class="header-anchor" href="#449-序列化和反序列化二叉搜索树">⁍</a></h2><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p><strong>编码的字符串应尽可能紧凑。</strong></p><blockquote><p><strong>思路</strong></p></blockquote><ul><li>序列化：后序遍历</li><li>反序列化：最后一个节点是root，从后往前搜索第一个小于根节点的就是左子树的根</li><li>编码：用4位十六进制编码会缩短空间<ul><li>十六进制转换为十进制： Integer.parseInt(String s, 16)</li><li>十进制转换为4位十六进制（十六进制格式化）<ul><li>String.format(“%04x”, num)</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(); <span class="hljs-comment">//用StringBuilder拼接字符串更高效</span><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        postorder(root);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left);<br>        postorder(root.right);<br>        sb.append(encode(root.val));<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        <span class="hljs-comment">//先将data转换为十进制数据</span><br>        <span class="hljs-keyword">int</span> len = data.length()/<span class="hljs-number">4</span>;<span class="hljs-comment">//节点个数</span><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<span class="hljs-comment">//节点值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            nums[i] = decode(data.substring(<span class="hljs-number">4</span>*i, <span class="hljs-number">4</span>*(i+<span class="hljs-number">1</span>)));<br>        &#125;<br>        <span class="hljs-comment">//通过nums构造二叉树</span><br>        <span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>        <span class="hljs-comment">//root代表根在nums中的下标</span><br>        <span class="hljs-comment">//start标示树开始的下标</span><br>        <span class="hljs-keyword">if</span> (root&lt;start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(nums[root]);<br><br>        <span class="hljs-keyword">if</span> (root==start) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> root_r = root-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_l = start-<span class="hljs-number">1</span>;<span class="hljs-comment">//如果该树不存在，则会root_l&lt;start_l，会返回null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = root-<span class="hljs-number">1</span>; i &gt;= start; i--) &#123;<br>            <span class="hljs-comment">//倒序查找第一个&lt;nums[root]的值</span><br>            <span class="hljs-keyword">if</span> (nums[i]&lt;=nums[root]) &#123;<br>                root_l=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> start_l = start;<br>        <span class="hljs-keyword">int</span> start_r = root_l+<span class="hljs-number">1</span>;<br>        node.left = buildTree(nums, start_l, root_l);<br>        node.right = buildTree(nums, start_r, root_r);<br>        <span class="hljs-keyword">return</span> node;<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%04x&quot;</span>, val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(String val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(val,<span class="hljs-number">16</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>python简单编码版</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.st = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        self.postOrder(root)<br>        <span class="hljs-keyword">return</span> self.st<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span><br>        self.postOrder(root.left)<br>        self.postOrder(root.right)<br>        self.st += self.encode(root.val)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;#&#x27;</span><br>        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type data: str</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">return</span> []<br>        nodes = self.decode(data)<br>        <span class="hljs-comment"># 根节点在最后</span><br>        root_index = <span class="hljs-built_in">len</span>(nodes) - <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(nodes)<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span>(<span class="hljs-params">root_index, start_index</span>):</span><br>            <span class="hljs-keyword">if</span> root_index &lt; start_index:<br>                <span class="hljs-keyword">return</span><br>            <br>            node = TreeNode(nodes[root_index])<br><br>            left_start = start_index <span class="hljs-comment"># 左子树的起始就是根的起始</span><br>            right_root = root_index - <span class="hljs-number">1</span> <span class="hljs-comment"># 右子树的根就是根左边一个</span><br>            <span class="hljs-comment"># 左子树的根是倒序查找第一个小于根节点的数的下标</span><br>            left_root = root_index - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> left_root &gt;= start_index <span class="hljs-keyword">and</span> nodes[left_root] &gt; nodes[root_index]:<br>                left_root-=<span class="hljs-number">1</span><br>            right_start = left_root + <span class="hljs-number">1</span><br>            node.left = buildTree(left_root, left_start)<br>            node.right = buildTree(right_root, right_start)<br><br>            <span class="hljs-keyword">return</span> node<br>        <span class="hljs-keyword">return</span> buildTree(root_index, <span class="hljs-number">0</span>)<br><br><br>        <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span>(<span class="hljs-params">self, data</span>):</span><br>        li = data.split(<span class="hljs-string">&#x27;#&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">int</span>(e) <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> li]<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/">617. 合并二叉树</a><a class="header-anchor" href="#617-合并二叉树">⁍</a></h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><blockquote><p><strong>思路：递归</strong></p></blockquote><p>因为不知道两棵树的深度，所以一定是先序遍历，从根节点开始</p><ul><li>都不为空，相加，返回</li><li>一个为空，一个不为空，返回一个</li><li>两个都为空，返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root1==<span class="hljs-keyword">null</span>&amp;&amp;root2==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root1==<span class="hljs-keyword">null</span>&amp;&amp;root2!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root2==<span class="hljs-keyword">null</span>&amp;&amp;root1!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(root1.val+root2.val);<br>        node.left = mergeTrees(root1.left, root2.left);<br>        node.right = mergeTrees(root1.right, root2.right);<br><br>        <span class="hljs-keyword">return</span> node;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 (programmercarl.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#java">0236.二叉树的最近公共祖先-代码随想录 (programmercarl.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（十二）| 加密与安全</title>
      <link href="/augu1sto/378b031eea17/"/>
      <url>/augu1sto/378b031eea17/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="biginteger">* BigInteger<a class="header-anchor" href="#biginteger">⁍</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BigInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum,  <span class="hljs-keyword">byte</span>[] magnitude)</span></span><br></code></pre></td></tr></table></figure><p>将BigInteger的符号幅度表示转换为BigInteger。</p><p>符号表示为整数符号值：-1表示负数，0表示零，或1表示正数。 大小是<em>big-endian</em>字节顺序的字节数组：最重要的字节是第0个元素。</p><p>允许使用零长度数组，并且将导致BigInteger值为0，无论signum是-1,0还是1.假定<code>magnitude</code>数组在构造函数调用期间保持不变。</p><ul><li><p><strong>参数</strong></p><p><code>signum</code> - 数字的符号（-1表示负数，0表示零，1表示正数）。</p><p><code>magnitude</code> - 数字大小的big-endian二进制表示。</p></li></ul><p><code>BigInteger(1, x)</code>就代表根据x字节流生成正数</p></blockquote><h2 id="编码算法">编码算法<a class="header-anchor" href="#编码算法">⁍</a></h2><h3 id="url编码">URL编码<a class="header-anchor" href="#url编码">⁍</a></h3><ul><li>如果字符是<code>A</code>~<code>Z</code>， <code>a</code>~<code>z</code>， <code>0</code>~<code>9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</li><li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li></ul><p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码，Java标准库的<code>URLDecoder</code>就可以解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><span class="hljs-keyword">import</span> java.net.URLDecoder;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//编码</span><br>        String encoded = URLEncoder.encode(<span class="hljs-string">&quot;中文!&quot;</span>, StandardCharsets.UTF_8);<br>        System.out.println(encoded);<br>        <span class="hljs-comment">//解码</span><br>        String decoded = URLDecoder.decode(<span class="hljs-string">&quot;%E4%B8%AD%E6%96%87%21&quot;</span>, StandardCharsets.UTF_8);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="base64编码">Base64编码<a class="header-anchor" href="#base64编码">⁍</a></h3><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code>~<code>Z</code>、 <code>a</code>~<code>z</code>、 <code>0</code>~<code>9</code>、 <code>+</code>、 <code>/</code>、 <code>=</code>这些字符。</p><p><strong>原理：</strong> 把3字节的二进制数据按6bit一组，转为16进制，得到编码后的字符串。</p><p>如果输入的<code>byte[]</code>数组长度不是3的整数倍，，需要对输入的末尾补一个或两个<code>0x00</code>，编码后，在结尾加一个<code>=</code>表示补充了1个<code>0x00</code>，加两个<code>=</code>表示补充了2个<code>0x00</code>，解码的时候，去掉末尾补充的一个或两个<code>0x00</code>即可。</p><p>实际上，因为编码后的长度加上<code>=</code>总是4的倍数，所以即使不加<code>=</code>也可以计算出原始输入的<code>byte[]</code>。Base64编码的时候可以用<code>withoutPadding()</code>去掉<code>=</code>，解码出来的结果是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] input = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[] &#123; (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0xe4</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0xb8</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0xad</span>, <span class="hljs-number">0x21</span> &#125;;<br>        String b64encoded = Base64.getEncoder().encodeToString(input);<br>        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);<br>        System.out.println(b64encoded);<br>        System.out.println(b64encoded2);<br>        <span class="hljs-keyword">byte</span>[] output = Base64.getDecoder().decode(b64encoded2);<br>        System.out.println(Arrays.toString(output));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p><h2 id="哈希算法">哈希算法<a class="header-anchor" href="#哈希算法">⁍</a></h2><h3 id="常用哈希算法">常用哈希算法<a class="header-anchor" href="#常用哈希算法">⁍</a></h3><table><thead><tr><th style="text-align:left">算法</th><th style="text-align:left">输出长度（位）</th><th style="text-align:left">输出长度（字节）</th></tr></thead><tbody><tr><td style="text-align:left">MD5</td><td style="text-align:left">128 bits</td><td style="text-align:left">16 bytes</td></tr><tr><td style="text-align:left">SHA-1</td><td style="text-align:left">160 bits</td><td style="text-align:left">20 bytes</td></tr><tr><td style="text-align:left">RipeMD-160</td><td style="text-align:left">160 bits</td><td style="text-align:left">20 bytes</td></tr><tr><td style="text-align:left">SHA-256</td><td style="text-align:left">256 bits</td><td style="text-align:left">32 bytes</td></tr><tr><td style="text-align:left">SHA-512</td><td style="text-align:left">512 bits</td><td style="text-align:left">64 bytes</td></tr></tbody></table><h3 id="接口">接口<a class="header-anchor" href="#接口">⁍</a></h3><p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建一个MessageDigest实例:</span><br>        MessageDigest md = MessageDigest.getInstance(<span class="hljs-string">&quot;MD5&quot;</span>);<span class="hljs-comment">//可以换成SHA-1等算法</span><br>        <span class="hljs-comment">// 反复调用update输入数据:</span><br>        md.update(<span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        md.update(<span class="hljs-string">&quot;World&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-keyword">byte</span>[] result = md.digest(); <span class="hljs-comment">// MD5(&quot;HelloWorld&quot;) 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span><br>        System.out.println(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, result).toString(<span class="hljs-number">16</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="彩虹表与加盐">彩虹表与加盐<a class="header-anchor" href="#彩虹表与加盐">⁍</a></h3><p>彩虹表指常见口令对应的哈希表</p><p>加盐(salt)指对每个口令额外添加随机数 <code>digest = hash(salt+inputPassword)</code></p><h2 id="第三方库——bouncycastle">第三方库——BouncyCastle<a class="header-anchor" href="#第三方库——bouncycastle">⁍</a></h2><p>BouncyCastle是一个开源的第三方算法提供商；</p><p>BouncyCastle提供了很多Java标准库没有提供的哈希算法和加密算法；</p><p>使用第三方算法前需要通过<code>Security.addProvider()</code>注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 注册BouncyCastle:</span><br>        Security.addProvider(<span class="hljs-keyword">new</span> BouncyCastleProvider());<br>        <span class="hljs-comment">// 按名称正常调用:</span><br>        MessageDigest md = MessageDigest.getInstance(<span class="hljs-string">&quot;RipeMD160&quot;</span>);<br>        md.update(<span class="hljs-string">&quot;HelloWorld&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-keyword">byte</span>[] result = md.digest();<br>        System.out.println(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, result).toString(<span class="hljs-number">16</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hmac算法">Hmac算法<a class="header-anchor" href="#hmac算法">⁍</a></h2><p>salt可以看作是一个额外的“认证码”，Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p><p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5， <strong>计算的摘要长度和原摘要算法长度相同</strong> 。</p><p>和MD5相比，使用HmacMD5的 <strong>步骤</strong> 是：</p><ol><li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li><li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li><li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li><li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li><li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li><li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">import</span> javax.crypto.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建指定算法的KeyGenerator实例</span><br>        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="hljs-string">&quot;HmacMD5&quot;</span>);<br>        <span class="hljs-comment">// 通过KeyGenerator实例创建Secretkey实例</span><br>        SecretKey key = keyGen.generateKey();<br>        <span class="hljs-comment">// 打印随机生成的key:</span><br>        <span class="hljs-keyword">byte</span>[] skey = key.getEncoded();<br>        System.out.println(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, skey).toString(<span class="hljs-number">16</span>));<br>        <span class="hljs-comment">// 创建指定算法的Mac实例</span><br>        Mac mac = Mac.getInstance(<span class="hljs-string">&quot;HmacMD5&quot;</span>);<br>        <span class="hljs-comment">// 使用key初始化Mac实例</span><br>        mac.init(key);<br>        <span class="hljs-comment">// 输入数据</span><br>        mac.update(<span class="hljs-string">&quot;HelloWorld&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-comment">// 调用doFinal获取最终的哈希值</span><br>        <span class="hljs-keyword">byte</span>[] result = mac.doFinal();<br>        System.out.println(<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, result).toString(<span class="hljs-number">16</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>验证时，从一个<code>byte[]</code>数组恢复<code>SecretKey</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SecretKey key = <span class="hljs-keyword">new</span> SecretKeySpec(hkey, <span class="hljs-string">&quot;HmacMD5&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="对称加密算法">对称加密算法<a class="header-anchor" href="#对称加密算法">⁍</a></h2><h3 id="常用的对称加密算法">常用的对称加密算法<a class="header-anchor" href="#常用的对称加密算法">⁍</a></h3><table><thead><tr><th style="text-align:left">算法</th><th style="text-align:left">密钥长度</th><th style="text-align:left">工作模式</th><th style="text-align:left">填充模式</th></tr></thead><tbody><tr><td style="text-align:left">DES</td><td style="text-align:left">56/64</td><td style="text-align:left">ECB/CBC/PCBC/CTR/…</td><td style="text-align:left">NoPadding/PKCS5Padding/…</td></tr><tr><td style="text-align:left">AES</td><td style="text-align:left">128/192/256</td><td style="text-align:left">ECB/CBC/PCBC/CTR/…</td><td style="text-align:left">NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr><tr><td style="text-align:left">IDEA</td><td style="text-align:left">128</td><td style="text-align:left">ECB</td><td style="text-align:left">PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><h3 id="java调用对称加密接口步骤">JAVA调用对称加密接口步骤<a class="header-anchor" href="#java调用对称加密接口步骤">⁍</a></h3><p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p><ol><li>根据算法名称/工作模式/填充模式获取Cipher实例；</li><li>根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；</li><li>使用SerectKey初始化Cipher实例，并设置加密或解密模式；</li><li>传入明文或密文，获得密文或明文。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.*;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">import</span> javax.crypto.*;<br><span class="hljs-keyword">import</span> javax.crypto.spec.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 原文:</span><br>        String message = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;Message: &quot;</span> + message);<br>        <span class="hljs-comment">// ECB模式需要128位密钥 = 16 bytes Key:</span><br>        <span class="hljs-keyword">byte</span>[] key = <span class="hljs-string">&quot;1234567890abcdef&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 加密:</span><br>        <span class="hljs-keyword">byte</span>[] data = message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] encrypted = encrypt(key, data); <span class="hljs-comment">// 调用加密算法</span><br>        System.out.println(<span class="hljs-string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));<br>        <span class="hljs-comment">// 解密:</span><br>        <span class="hljs-keyword">byte</span>[] decrypted = decrypt(key, encrypted);<br>        System.out.println(<span class="hljs-string">&quot;Decrypted: &quot;</span> + <span class="hljs-keyword">new</span> String(decrypted, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 加密:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] encrypt(<span class="hljs-keyword">byte</span>[] key, <span class="hljs-keyword">byte</span>[] input) <span class="hljs-keyword">throws</span> GeneralSecurityException &#123;<br>        <span class="hljs-comment">// 选择算法名称/工作模式/填充模式</span><br>        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>);<br>        <span class="hljs-comment">// 初始化SecretKey</span><br>        SecretKey keySpec = <span class="hljs-keyword">new</span> SecretKeySpec(key, <span class="hljs-string">&quot;AES&quot;</span>);<br>        <span class="hljs-comment">// 使用SerectKey初始化Cipher实例，并设置加密或解密模式</span><br>        cipher.init(Cipher.ENCRYPT_MODE, keySpec);<br>        <span class="hljs-keyword">return</span> cipher.doFinal(input);<br>    &#125;<br><br>    <span class="hljs-comment">// 解密:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(<span class="hljs-keyword">byte</span>[] key, <span class="hljs-keyword">byte</span>[] input) <span class="hljs-keyword">throws</span> GeneralSecurityException &#123;<br>        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>);<br>        SecretKey keySpec = <span class="hljs-keyword">new</span> SecretKeySpec(key, <span class="hljs-string">&quot;AES&quot;</span>);<br>        <span class="hljs-comment">// 使用SerectKey初始化Cipher实例，并设置解密模式</span><br>        cipher.init(Cipher.DECRYPT_MODE, keySpec);<br>        <span class="hljs-keyword">return</span> cipher.doFinal(input);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="pbe口令加密算法">PBE口令加密算法<a class="header-anchor" href="#pbe口令加密算法">⁍</a></h2><p>PBE就是Password Based Encryption的缩写，它的作用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">key = generate(userPassword, secureRandomPassword);<br></code></pre></td></tr></table></figure><p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。</p><p>让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的口令，再进行加密</p><p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是<code>PBEwithSHA1and128bitAES-CBC-BC</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 把BouncyCastle作为Provider添加到java.security:</span><br>        Security.addProvider(<span class="hljs-keyword">new</span> BouncyCastleProvider());<br>        <span class="hljs-comment">// 原文:</span><br>        String message = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>        <span class="hljs-comment">// 加密口令:</span><br>        String password = <span class="hljs-string">&quot;hello12345&quot;</span>;<br>        <span class="hljs-comment">// 16 bytes随机Salt:</span><br>        <span class="hljs-keyword">byte</span>[] salt = SecureRandom.getInstanceStrong().generateSeed(<span class="hljs-number">16</span>);<br>        System.out.printf(<span class="hljs-string">&quot;salt: %032x\n&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, salt));<br>        <span class="hljs-comment">// 加密:</span><br>        <span class="hljs-keyword">byte</span>[] data = message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] encrypted = encrypt(password, salt, data);<br>        System.out.println(<span class="hljs-string">&quot;encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));<br>        <span class="hljs-comment">// 解密:</span><br>        <span class="hljs-keyword">byte</span>[] decrypted = decrypt(password, salt, encrypted);<br>        System.out.println(<span class="hljs-string">&quot;decrypted: &quot;</span> + <span class="hljs-keyword">new</span> String(decrypted, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 加密:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] encrypt(String password, <span class="hljs-keyword">byte</span>[] salt, <span class="hljs-keyword">byte</span>[] input) <span class="hljs-keyword">throws</span> GeneralSecurityException &#123;<br>        PBEKeySpec keySpec = <span class="hljs-keyword">new</span> PBEKeySpec(password.toCharArray());<br>        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="hljs-string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);<br>        SecretKey skey = skeyFactory.generateSecret(keySpec);<br>        PBEParameterSpec pbeps = <span class="hljs-keyword">new</span> PBEParameterSpec(salt, <span class="hljs-number">1000</span>);<br>        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);<br>        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);<br>        <span class="hljs-keyword">return</span> cipher.doFinal(input);<br>    &#125;<br><br>    <span class="hljs-comment">// 解密:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(String password, <span class="hljs-keyword">byte</span>[] salt, <span class="hljs-keyword">byte</span>[] input) <span class="hljs-keyword">throws</span> GeneralSecurityException &#123;<br>        PBEKeySpec keySpec = <span class="hljs-keyword">new</span> PBEKeySpec(password.toCharArray());<br>        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="hljs-string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);<br>        SecretKey skey = skeyFactory.generateSecret(keySpec);<br>        PBEParameterSpec pbeps = <span class="hljs-keyword">new</span> PBEParameterSpec(salt, <span class="hljs-number">1000</span>);<br>        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);<br>        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);<br>        <span class="hljs-keyword">return</span> cipher.doFinal(input);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="密钥交换算法——diffie-hellman算法">密钥交换算法——Diffie-Hellman算法<a class="header-anchor" href="#密钥交换算法——diffie-hellman算法">⁍</a></h2><p>Diffie-Hellman算法是一种密钥交换协议，通信双方通过不安全的信道协商密钥，然后进行对称加密传输。</p><p>DH算法没有解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。</p><h3 id="步骤">步骤<a class="header-anchor" href="#步骤">⁍</a></h3><ol><li>甲首选选择一个 <strong>素数</strong> <code>p</code>，例如509， <strong>底数</strong> <code>g</code>，任选，例如5， <strong>随机数</strong> <code>a</code>，例如123，然后 <strong>计算<code>A=g^a mod p</code></strong> ，结果是215，然后，甲 <strong>发送<code>p＝509</code>，<code>g=5</code>，<code>A=215</code></strong> 给乙；</li><li>乙方收到后，也选择一个 <strong>随机数</strong> <code>b</code>，例如，456，然后 <strong>计算<code>B=g^b mod p</code></strong> ，结果是181，乙再同时 <strong>计算<code>s=A^b mod p</code></strong> ，结果是121；</li><li>乙把计算的<code>B=181</code>发给甲，甲计算<code>s＝B^a mod p</code>的余数，计算结果与乙算出的结果一样，都是121。</li></ol><p>把<code>a</code>看成甲的私钥，<code>A</code>看成甲的公钥，<code>b</code>看成乙的私钥，<code>B</code>看成乙的公钥</p><h3 id="实现">实现<a class="header-anchor" href="#实现">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">import</span> java.security.*;<br><span class="hljs-keyword">import</span> java.security.spec.*;<br><br><span class="hljs-keyword">import</span> javax.crypto.KeyAgreement;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// Bob和Alice:</span><br>        Person bob = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        Person alice = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>);<br><br>        <span class="hljs-comment">// 各自生成KeyPair:</span><br>        bob.generateKeyPair();<br>        alice.generateKeyPair();<br><br>        <span class="hljs-comment">// 双方交换各自的PublicKey:</span><br>        <span class="hljs-comment">// Bob根据Alice的PublicKey生成自己的本地密钥:</span><br>        bob.generateSecretKey(alice.publicKey.getEncoded());<br>        <span class="hljs-comment">// Alice根据Bob的PublicKey生成自己的本地密钥:</span><br>        alice.generateSecretKey(bob.publicKey.getEncoded());<br><br>        <span class="hljs-comment">// 检查双方的本地密钥是否相同:</span><br>        bob.printKeys();<br>        alice.printKeys();<br>        <span class="hljs-comment">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> PublicKey publicKey;<br>    <span class="hljs-keyword">private</span> PrivateKey privateKey;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] secretKey;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 生成本地KeyPair:</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateKeyPair</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="hljs-string">&quot;DH&quot;</span>);<br>            kpGen.initialize(<span class="hljs-number">512</span>);<br>            KeyPair kp = kpGen.generateKeyPair();<br>            <span class="hljs-keyword">this</span>.privateKey = kp.getPrivate();<br>            <span class="hljs-keyword">this</span>.publicKey = kp.getPublic();<br>        &#125; <span class="hljs-keyword">catch</span> (GeneralSecurityException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateSecretKey</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] receivedPubKeyBytes)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从byte[]恢复PublicKey:</span><br>            X509EncodedKeySpec keySpec = <span class="hljs-keyword">new</span> X509EncodedKeySpec(receivedPubKeyBytes);<br>            KeyFactory kf = KeyFactory.getInstance(<span class="hljs-string">&quot;DH&quot;</span>);<br>            PublicKey receivedPublicKey = kf.generatePublic(keySpec);<br>            <span class="hljs-comment">// 生成本地密钥:</span><br>            KeyAgreement keyAgreement = KeyAgreement.getInstance(<span class="hljs-string">&quot;DH&quot;</span>);<br>            keyAgreement.init(<span class="hljs-keyword">this</span>.privateKey); <span class="hljs-comment">// 自己的PrivateKey</span><br>            keyAgreement.doPhase(receivedPublicKey, <span class="hljs-keyword">true</span>); <span class="hljs-comment">// 对方的PublicKey</span><br>            <span class="hljs-comment">// 生成SecretKey密钥:</span><br>            <span class="hljs-keyword">this</span>.secretKey = keyAgreement.generateSecret();<br>        &#125; <span class="hljs-keyword">catch</span> (GeneralSecurityException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printKeys</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;Name: %s\n&quot;</span>, <span class="hljs-keyword">this</span>.name);<br>        System.out.printf(<span class="hljs-string">&quot;Private key: %x\n&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.privateKey.getEncoded()));<br>        System.out.printf(<span class="hljs-string">&quot;Public key: %x\n&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.publicKey.getEncoded()));<br>        System.out.printf(<span class="hljs-string">&quot;Secret key: %x\n&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.secretKey));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="非对称加密算法">非对称加密算法<a class="header-anchor" href="#非对称加密算法">⁍</a></h2><p>非对称加密就是加密和解密使用的不是相同的密钥，只有同一个公钥-私钥对才能正常加解密；</p><p>非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。</p><p>所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p><ol><li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li><li>小红用自己的RSA私钥解密得到AES口令；</li><li>双方使用这个共享的AES口令用AES加密通信。</li></ol><h3 id="实现-2">实现<a class="header-anchor" href="#实现-2">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">import</span> java.security.*;<br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 明文:</span><br>        <span class="hljs-keyword">byte</span>[] plain = <span class="hljs-string">&quot;Hello, encrypt use RSA&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 创建公钥／私钥对:</span><br>        Person alice = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        <span class="hljs-comment">// 用Alice的公钥加密:</span><br>        <span class="hljs-keyword">byte</span>[] pk = alice.getPublicKey();<br>        System.out.println(String.format(<span class="hljs-string">&quot;public key: %x&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, pk)));<br>        <span class="hljs-keyword">byte</span>[] encrypted = alice.encrypt(plain);<br>        System.out.println(String.format(<span class="hljs-string">&quot;encrypted: %x&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, encrypted)));<br>        <span class="hljs-comment">// 用Alice的私钥解密:</span><br>        <span class="hljs-keyword">byte</span>[] sk = alice.getPrivateKey();<br>        System.out.println(String.format(<span class="hljs-string">&quot;private key: %x&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, sk)));<br>        <span class="hljs-keyword">byte</span>[] decrypted = alice.decrypt(encrypted);<br>        System.out.println(<span class="hljs-keyword">new</span> String(decrypted, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-comment">// 私钥:</span><br>    PrivateKey sk;<br>    <span class="hljs-comment">// 公钥:</span><br>    PublicKey pk;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> GeneralSecurityException </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-comment">// 生成公钥／私钥对:</span><br>        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);<br>        kpGen.initialize(<span class="hljs-number">1024</span>);<br>        KeyPair kp = kpGen.generateKeyPair();<br>        <span class="hljs-keyword">this</span>.sk = kp.getPrivate();<br>        <span class="hljs-keyword">this</span>.pk = kp.getPublic();<br>    &#125;<br><br>    <span class="hljs-comment">// 把私钥导出为字节</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getPrivateKey() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sk.getEncoded();<br>    &#125;<br><br>    <span class="hljs-comment">// 把公钥导出为字节</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getPublicKey() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pk.getEncoded();<br>    &#125;<br><br>    <span class="hljs-comment">// 用公钥加密:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] encrypt(<span class="hljs-keyword">byte</span>[] message) <span class="hljs-keyword">throws</span> GeneralSecurityException &#123;<br>        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);<br>        cipher.init(Cipher.ENCRYPT_MODE, <span class="hljs-keyword">this</span>.pk);<br>        <span class="hljs-keyword">return</span> cipher.doFinal(message);<br>    &#125;<br><br>    <span class="hljs-comment">// 用私钥解密:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] decrypt(<span class="hljs-keyword">byte</span>[] input) <span class="hljs-keyword">throws</span> GeneralSecurityException &#123;<br>        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);<br>        cipher.init(Cipher.DECRYPT_MODE, <span class="hljs-keyword">this</span>.sk);<br>        <span class="hljs-keyword">return</span> cipher.doFinal(input);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>RSA的公钥和私钥都可以通过<code>getEncoded()</code>方法获得以<code>byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从<code>byte[]</code>数组恢复公钥或私钥，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] pkData = ...<br><span class="hljs-keyword">byte</span>[] skData = ...<br>KeyFactory kf = KeyFactory.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);<br><span class="hljs-comment">// 恢复公钥:</span><br>X509EncodedKeySpec pkSpec = <span class="hljs-keyword">new</span> X509EncodedKeySpec(pkData);<br>PublicKey pk = kf.generatePublic(pkSpec);<br><span class="hljs-comment">// 恢复私钥:</span><br>PKCS8EncodedKeySpec skSpec = <span class="hljs-keyword">new</span> PKCS8EncodedKeySpec(skData);<br>PrivateKey sk = kf.generatePrivate(skSpec);<br></code></pre></td></tr></table></figure><p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p><p>如果修改待加密的<code>byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</p><p>此外，只使用非对称加密算法不能防止中间人攻击。</p><h2 id="签名算法">签名算法<a class="header-anchor" href="#签名算法">⁍</a></h2><p>数字签名就是用发送方的私钥对原始数据进行签名，只有用发送方公钥才能通过签名验证。</p><ul><li>签名： <code>signature = encrypt(privateKey, sha256(message))</code></li><li>解密： <code>hash = decrypt(publicKey, signature)</code> 把解密后的哈希与原始消息的哈希进行对比。</li></ul><p>数字签名用于：</p><ul><li>防止伪造；</li><li>防止抵赖；</li><li>检测篡改。</li></ul><p>常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。</p><h3 id="实现-3">实现<a class="header-anchor" href="#实现-3">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.security.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> GeneralSecurityException </span>&#123;<br>        <span class="hljs-comment">// 生成RSA公钥/私钥:</span><br>        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);<br>        kpGen.initialize(<span class="hljs-number">1024</span>);<br>        KeyPair kp = kpGen.generateKeyPair();<br>        PrivateKey sk = kp.getPrivate();<br>        PublicKey pk = kp.getPublic();<br><br>        <span class="hljs-comment">// 待签名的消息:</span><br>        <span class="hljs-keyword">byte</span>[] message = <span class="hljs-string">&quot;Hello, I am Bob!&quot;</span>.getBytes(StandardCharsets.UTF_8);<br><br>        <span class="hljs-comment">// 用私钥签名:</span><br>        Signature s = Signature.getInstance(<span class="hljs-string">&quot;SHA1withRSA&quot;</span>);<br>        s.initSign(sk);<br>        s.update(message);<br>        <span class="hljs-keyword">byte</span>[] signed = s.sign();<br>        System.out.println(String.format(<span class="hljs-string">&quot;signature: %x&quot;</span>, <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, signed)));<br><br>        <span class="hljs-comment">// 用公钥验证:</span><br>        Signature v = Signature.getInstance(<span class="hljs-string">&quot;SHA1withRSA&quot;</span>);<br>        v.initVerify(pk);<br>        v.update(message);<br>        <span class="hljs-keyword">boolean</span> valid = v.verify(signed);<br>        System.out.println(<span class="hljs-string">&quot;valid? &quot;</span> + valid);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="数字证书">数字证书<a class="header-anchor" href="#数字证书">⁍</a></h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227968188450">数字证书 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p><p>数字证书采用链式签名管理，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。顶级的Root CA证书已内置在操作系统中。</p><p>数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。</p><p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">keytool -storepass <span class="hljs-number">123456</span> -genkeypair -keyalg RSA -keysize <span class="hljs-number">1024</span> -sigalg SHA1withRSA -validity <span class="hljs-number">3650</span> -alias mycert -keystore my.keystore -dname <span class="hljs-string">&quot;CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN&quot;</span><br></code></pre></td></tr></table></figure><p>几个主要的参数是：</p><ul><li>keyalg：指定RSA加密算法；</li><li>sigalg：指定SHA1withRSA签名算法；</li><li>validity：指定证书有效期3650天；</li><li>alias：指定证书在程序中引用的名称；</li><li>dname：最重要的<code>CN=www.sample.com</code>指定了<code>Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li></ul><p>执行上述命令，JDK会在当前目录创建一个<code>my.keystore</code>文件，并存储创建成功的一个私钥和一个证书，它的别名是<code>mycert</code>。</p><p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p><ol><li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li><li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li><li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li></ol><p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（十一）| 单元测试</title>
      <link href="/augu1sto/ded4a46e4a5c/"/>
      <url>/augu1sto/ded4a46e4a5c/</url>
      
        <content type="html"><![CDATA[<h2 id="单元测试">单元测试<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><a class="header-anchor" href="#单元测试">⁍</a></h2><p>利用Java平台最常用的测试框架JUnit，并详细介绍如何编写单元测试。</p><h3 id="编写junit测试">编写JUnit测试<a class="header-anchor" href="#编写junit测试">⁍</a></h3><h4 id="测试驱动开发tdd">测试驱动开发TDD<a class="header-anchor" href="#测试驱动开发tdd">⁍</a></h4><p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ascii">    编写接口<br>     │<br>     ▼<br>    编写测试<br>     │<br>     ▼<br>┌─&gt; 编写实现<br>│    │<br>│ N  ▼<br>└── 运行测试<br>     │ Y<br>     ▼<br>    任务完成<br></code></pre></td></tr></table></figure><h4 id="junit">JUnit<a class="header-anchor" href="#junit">⁍</a></h4><p>一个JUnit测试包含若干<code>@Test</code>方法，并使用<code>Assertions</code>进行断言，注意浮点数<code>assertEquals()</code>要指定<code>delta</code>。</p><p><code>Assertion</code>还定义了其他断言方法，例如：</p><ul><li><code>assertEquals(expected, actual)</code>: 期待结果为<code>true</code></li><li><code>assertTrue()</code>: 期待结果为<code>true</code></li><li><code>assertFalse()</code>: 期待结果为<code>false</code></li><li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li><li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li><li>…</li></ul><h4 id="idea添加junit">IDEA添加JUnit<a class="header-anchor" href="#idea添加junit">⁍</a></h4><p><a href="https://blog.csdn.net/qq_43012792/article/details/107189778">新版IDEA如何简单添加JUnit4 jar包单元测试（不用下载)【图文】超详细_一个长不胖的程序YUAN的博客-CSDN博客_idea 添加junit</a></p><p>ctrl+shift+T 可以生成测试单元</p><p>（右击test文件夹可以将文件夹改为测试文件夹）</p><h3 id="使用fixture">使用Fixture<a class="header-anchor" href="#使用fixture">⁍</a></h3><p>编写Fixture是指针对每个<code>@Test</code>方法，编写<code>@BeforeEach</code>方法用于初始化测试资源，编写<code>@AfterEach</code>用于清理测试资源；</p><p>必要时，可以编写<code>@BeforeAll</code>和<code>@AfterAll</code>，使用静态变量来初始化耗时的资源，并且在所有<code>@Test</code>方法的运行前后仅执行一次。</p><p><strong>编写Fixture的套路如下：</strong></p><ol><li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li><li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li></ol><p>大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p><p>最后，注意到每次运行一个<code>@Test</code>方法前，JUnit首先创建一个<code>XxxTest</code>实例，因此，每个<code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个<code>@Test</code>方法带到另一个<code>@Test</code>方法。</p><h3 id="异常测试">异常测试<a class="header-anchor" href="#异常测试">⁍</a></h3><p>测试异常可以使用<code>assertThrows()</code>，期待捕获到指定类型的异常；</p><p>对可能发生的每种类型的异常都必须进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testNegative</span><span class="hljs-params">()</span> </span>&#123;<br>    assertThrows(IllegalArgumentException.class, () -&gt; &#123;<br>        Factorial.fact(-<span class="hljs-number">1</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件测试">条件测试<a class="header-anchor" href="#条件测试">⁍</a></h3><p>JUnit根据不同的条件注解，决定是否运行当前的<code>@Test</code>方法。</p><h3 id="参数化测试">参数化测试<a class="header-anchor" href="#参数化测试">⁍</a></h3><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p><p>JUnit提供了一个<code>@ParameterizedTest</code>注解代替<code>@Test</code>，用来进行参数化测试。</p><ul><li><p>用<code>@ValueSource()</code>注解传入参数</p></li><li><p>用<code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数</p><p>构造参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ParameterizedTest</span><br><span class="hljs-meta">@MethodSource</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCapitalize</span><span class="hljs-params">(String input, String result)</span> </span>&#123;<br>assertEquals(result, StringUtils.capitalize(input));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Arguments&gt; <span class="hljs-title">testCapitalize</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> List.of( <span class="hljs-comment">// arguments:</span><br>Arguments.arguments(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;Abc&quot;</span>), <span class="hljs-comment">//</span><br>Arguments.arguments(<span class="hljs-string">&quot;APPLE&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>), <span class="hljs-comment">//</span><br>Arguments.arguments(<span class="hljs-string">&quot;gooD&quot;</span>, <span class="hljs-string">&quot;Good&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用<code>@CsvSource</code>注解，它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔</p></li><li><p>用<code>@CsvFileSource</code>注解，指定<code>resources</code>所在CSV文件</p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945269146912">单元测试 - 廖雪峰的官方网站 (liaoxuefeng.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（十）| 日期与时间、正则表达式</title>
      <link href="/augu1sto/5856b11dc1a2/"/>
      <url>/augu1sto/5856b11dc1a2/</url>
      
        <content type="html"><![CDATA[<h2 id="日期与时间">日期与时间<a class="header-anchor" href="#日期与时间">⁍</a></h2><p>计算机通过<code>Locale</code>来针对当地用户习惯格式化日期、时间、数字、货币等。</p><p><code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p><p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p><ul><li>zh_CN：2016-11-30</li><li>en_US：11/30/2016</li></ul><p>Java有两套日期和时间的API：</p><ul><li>旧的Date、Calendar和TimeZone；</li><li>新的LocalDateTime、ZonedDateTime、ZoneId等。</li></ul><p>分别位于<code>java.util</code>和<code>java.time</code>包中。</p><p>⭐ 从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p><ul><li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li><li>带时区的日期和时间：<code>ZonedDateTime</code>；</li><li>时刻：<code>Instant</code>；</li><li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li><li>时间间隔：<code>Duration</code>。</li></ul><p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p><h3 id="date和calendar-旧api">Date和Calendar(旧API)<a class="header-anchor" href="#date和calendar-旧api">⁍</a></h3><p>计算机表示的时间是以整数表示的时间戳存储的，即<code>Epoch Time</code>，Java使用<code>long</code>型来表示以毫秒为单位的时间戳，通过<code>System.currentTimeMillis()</code>获取当前时间戳。</p><blockquote><p><code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数</p></blockquote><h4 id="date">Date<a class="header-anchor" href="#date">⁍</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Date date = <span class="hljs-keyword">new</span> Date();<br>System.out.println(date.getYear() + <span class="hljs-number">1900</span>); <span class="hljs-comment">// 必须加上1900</span><br>System.out.println(date.getMonth() + <span class="hljs-number">1</span>); <span class="hljs-comment">// 0~11，必须加上1</span><br>System.out.println(date.getDate()); <span class="hljs-comment">// 1~31，不能加1</span><br></code></pre></td></tr></table></figure><p>自定义格式输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Date date = <span class="hljs-keyword">new</span> Date();<br><span class="hljs-keyword">var</span> sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(sdf.format(date));<br></code></pre></td></tr></table></figure><p>假设当前月份是9月：</p><ul><li><code>M</code>：输出<code>9</code></li><li><code>MM</code>：输出<code>09</code></li><li><code>MMM</code>：输出<code>Sep</code></li><li><code>MMMM</code>：输出<code>September</code></li></ul><h4 id="calendar">Calendar<a class="header-anchor" href="#calendar">⁍</a></h4><p>和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p><p><code>Calendar</code>的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前时间:</span><br>Calendar c = Calendar.getInstance();<br><span class="hljs-keyword">int</span> y = c.get(Calendar.YEAR);<br><span class="hljs-keyword">int</span> m = <span class="hljs-number">1</span> + c.get(Calendar.MONTH);<br><span class="hljs-keyword">int</span> d = c.get(Calendar.DAY_OF_MONTH);<br><span class="hljs-keyword">int</span> w = c.get(Calendar.DAY_OF_WEEK);<br></code></pre></td></tr></table></figure><h4 id="timezone">TimeZone<a class="header-anchor" href="#timezone">⁍</a></h4><p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示</p><p>利用<code>Calendar</code>进行时区转换的步骤是：</p><ol><li>清除所有字段；</li><li>设定指定时区；</li><li>设定日期和时间；</li><li>创建<code>SimpleDateFormat</code>并设定目标时区；</li><li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li></ol><h3 id="localdatetime">LocalDateTime<a class="header-anchor" href="#localdatetime">⁍</a></h3><p><mark>import java.time.*;</mark></p><h4 id="获取日期和时间">获取日期和时间<a class="header-anchor" href="#获取日期和时间">⁍</a></h4><ul><li>当前日期：<code>LocalDate d = LocalDate.now();</code> //2022-02-15</li><li>当前时间：<code>LocalTime t = LocalTime.now();</code> //08:51:53.807637953</li><li>当前日期和时间：<code>LocalDateTime dt = LocalDateTime.now();</code> //2022-02-15T08:51:53.807670493</li><li>用标准输出会严格按照ISO 8601格式打印</li></ul><p>如果要在同一个时刻分别输出当前日期和时间，可以采用以下方法：（如果按上述分开写，每一行程序的执行时间可能会带来影响）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime dt = LocalDateTime.now(); <span class="hljs-comment">// 当前日期和时间</span><br>LocalDate d = dt.toLocalDate(); <span class="hljs-comment">// 转换到当前日期</span><br>LocalTime t = dt.toLocalTime(); <span class="hljs-comment">// 转换到当前时间</span><br></code></pre></td></tr></table></figure><h4 id="创建指定日期和时间">创建指定日期和时间<a class="header-anchor" href="#创建指定日期和时间">⁍</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定日期和时间:</span><br>LocalDate d2 = LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 2019-11-30, 注意11=11月</span><br>LocalTime t2 = LocalTime.of(<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>); <span class="hljs-comment">// 15:16:17</span><br>LocalDateTime dt2 = LocalDateTime.of(<span class="hljs-number">2019</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);<br>LocalDateTime dt3 = LocalDateTime.of(d2, t2);<br><span class="hljs-comment">//按照ISO 8601格式直接传入字符串</span><br>LocalDateTime dt = LocalDateTime.parse(<span class="hljs-string">&quot;2019-11-19T15:16:17&quot;</span>);<br>LocalDate d = LocalDate.parse(<span class="hljs-string">&quot;2019-11-19&quot;</span>);<br>LocalTime t = LocalTime.parse(<span class="hljs-string">&quot;15:16:17&quot;</span>);<br></code></pre></td></tr></table></figure><p>ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p><ul><li>日期：yyyy-MM-dd</li><li>时间：HH:mm:ss</li><li>带毫秒的时间：HH:mm:ss.SSS</li><li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li><li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li></ul><h4 id="datetimeformatter">DateTimeFormatter<a class="header-anchor" href="#datetimeformatter">⁍</a></h4><p><mark>import java.time.format.*;</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 自定义格式化:</span><br>    DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);<br>    System.out.println(dtf.format(LocalDateTime.now()));<br><br>    <span class="hljs-comment">// 用自定义格式解析:</span><br>    LocalDateTime dt2 = LocalDateTime.parse(<span class="hljs-string">&quot;2019/11/30 15:16:17&quot;</span>, dtf);<br>    System.out.println(dt2);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时间加减">时间加减<a class="header-anchor" href="#时间加减">⁍</a></h4><p>加5天减3小时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime dt2 = dt.plusDays(<span class="hljs-number">5</span>).minusHours(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>减一个月</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime dt3 = dt2.minusMonths(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="时间调整">时间调整<a class="header-anchor" href="#时间调整">⁍</a></h4><p>对日期和时间进行调整则使用<code>withXxx()</code>方法，例如：<code>withHour(15)</code>会把<code>10:11:12</code>改为<code>15:11:12</code>：</p><ul><li>调整年：withYear()</li><li>调整月：withMonth()</li><li>调整日：withDayOfMonth()</li><li>调整时：withHour()</li><li>调整分：withMinute()</li><li>调整秒：withSecond()</li></ul><p>其他，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.temporal.*;<br><span class="hljs-comment">// 本月最后1天:</span><br>LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());<br></code></pre></td></tr></table></figure><h4 id="时间比较">时间比较<a class="header-anchor" href="#时间比较">⁍</a></h4><p>可以使用<code>isBefore()</code>、<code>isAfter()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDate.now().isBefore(LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">11</span>, <span class="hljs-number">19</span>))<br></code></pre></td></tr></table></figure><h4 id="duration和period">Duration和Period<a class="header-anchor" href="#duration和period">⁍</a></h4><ul><li><p><code>Duration</code>表示两个时刻之间的时间间隔</p></li><li><p><code>Period</code>表示两个日期之间的天数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Duration d = Duration.between(start_dt, end_dt);<span class="hljs-comment">// PT1235H10M30S</span><br>Period p = LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">11</span>, <span class="hljs-number">19</span>).until(LocalDate.of(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>)); <span class="hljs-comment">//P1M21D</span><br></code></pre></td></tr></table></figure></li><li><p>利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Duration d1 = Duration.ofHours(<span class="hljs-number">10</span>); <span class="hljs-comment">// 10 hours</span><br>Duration d2 = Duration.parse(<span class="hljs-string">&quot;P1DT2H3M&quot;</span>); <span class="hljs-comment">// 1 day, 2 hours, 3 minutes</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="zoneddatetime">ZonedDateTime<a class="header-anchor" href="#zoneddatetime">⁍</a></h3><h4 id="获得不同时区的当前时间">获得不同时区的当前时间<a class="header-anchor" href="#获得不同时区的当前时间">⁍</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ZonedDateTime zbj = ZonedDateTime.now(); <span class="hljs-comment">// 默认时区</span><br>ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>)); <span class="hljs-comment">// 用指定时区获取当前时间</span><br></code></pre></td></tr></table></figure><p>表示同一时间</p><h4 id="给当前时间附加不同时区">给当前时间附加不同时区<a class="header-anchor" href="#给当前时间附加不同时区">⁍</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime ldt = LocalDateTime.of(<span class="hljs-number">2019</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);<br>ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());<br>ZonedDateTime zny = ldt.atZone(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br></code></pre></td></tr></table></figure><p>表示不同时间</p><h4 id="时区转换">时区转换<a class="header-anchor" href="#时区转换">⁍</a></h4><p>将一个<code>ZonedDateTime</code>对象，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区</p><p><mark>涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以中国时区获取当前时间:</span><br>ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>));<br><span class="hljs-comment">// 转换为纽约时间:</span><br>ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br></code></pre></td></tr></table></figure><p><code>ZonedDateTime</code>转换为本地时间:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ZonedDateTime zdt = ...<br>LocalDateTime ldt = zdt.toLocalDateTime(); <span class="hljs-comment">//无时区信息</span><br></code></pre></td></tr></table></figure><h3 id="datetimeformatter-2">DateTimeFormatter<a class="header-anchor" href="#datetimeformatter-2">⁍</a></h3><p>和<code>SimpleDateFormat</code>不同的是，<code>DateTimeFormatter</code>不但是不变对象，它还是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm&quot;</span>);<br><br>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;E, yyyy-MMMM-dd HH:mm&quot;</span>, Locale.US); <span class="hljs-comment">//按照Locale默认习惯格式化(E是星期几)</span><br><br>System.out.println(formatter.format(zdt));<br></code></pre></td></tr></table></figure><h3 id="instant">Instant<a class="header-anchor" href="#instant">⁍</a></h3><p>用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似，精度更高</p><p>可以和<code>ZonedDateTime</code>以及<code>long</code>互相转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以指定时间戳创建Instant:</span><br>Instant ins = Instant.ofEpochSecond(<span class="hljs-number">1568568760</span>);<br>ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());<br>System.out.println(zdt); <span class="hljs-comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure><h3 id="最佳实践——新旧api处理">最佳实践——新旧API处理<a class="header-anchor" href="#最佳实践——新旧api处理">⁍</a></h3><p>处理日期和时间时，尽量使用新的<code>java.time</code>包；</p><p>在数据库中存储时间戳时，尽量使用<code>long</code>型时间戳，它具有省空间，效率高，不依赖数据库的优点。</p><table><thead><tr><th style="text-align:left">数据库</th><th style="text-align:left">对应Java类（旧）</th><th style="text-align:left">对应Java类（新）</th></tr></thead><tbody><tr><td style="text-align:left">DATETIME</td><td style="text-align:left">java.util.Date</td><td style="text-align:left">LocalDateTime</td></tr><tr><td style="text-align:left">DATE</td><td style="text-align:left">java.sql.Date</td><td style="text-align:left">LocalDate</td></tr><tr><td style="text-align:left">TIME</td><td style="text-align:left">java.sql.Time</td><td style="text-align:left">LocalTime</td></tr><tr><td style="text-align:left">TIMESTAMP</td><td style="text-align:left">java.sql.Timestamp</td><td style="text-align:left">LocalDateTime</td></tr></tbody></table><h2 id="正则表达式">正则表达式<a class="header-anchor" href="#正则表达式">⁍</a></h2><h3 id="匹配规则">匹配规则<a class="header-anchor" href="#匹配规则">⁍</a></h3><p>单个字符的匹配规则如下：</p><table><thead><tr><th style="text-align:left">正则表达式</th><th style="text-align:left">规则</th><th style="text-align:left">可以匹配</th></tr></thead><tbody><tr><td style="text-align:left"><code>A</code></td><td style="text-align:left">指定字符</td><td style="text-align:left"><code>A</code></td></tr><tr><td style="text-align:left"><code>\u548c</code></td><td style="text-align:left">指定Unicode字符</td><td style="text-align:left"><code>和</code></td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">任意字符</td><td style="text-align:left"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td></tr><tr><td style="text-align:left"><code>\d</code></td><td style="text-align:left">数字0~9</td><td style="text-align:left"><code>0</code>~<code>9</code></td></tr><tr><td style="text-align:left"><code>\w</code></td><td style="text-align:left">大小写字母，数字和下划线</td><td style="text-align:left"><code>a</code>~<code>z</code>， <code>A</code>~<code>Z</code>， <code>0</code>~<code>9</code>，<code>_</code></td></tr><tr><td style="text-align:left"><code>\s</code></td><td style="text-align:left">空格、Tab键</td><td style="text-align:left">空格，Tab</td></tr><tr><td style="text-align:left"><code>\D</code></td><td style="text-align:left">非数字</td><td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr><tr><td style="text-align:left"><code>\W</code></td><td style="text-align:left">非\w</td><td style="text-align:left"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td></tr><tr><td style="text-align:left"><code>\S</code></td><td style="text-align:left">非\s</td><td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr></tbody></table><p>多个字符的匹配规则如下：</p><table><thead><tr><th style="text-align:left">正则表达式</th><th style="text-align:left">规则</th><th style="text-align:left">可以匹配</th></tr></thead><tbody><tr><td style="text-align:left"><code>A*</code></td><td style="text-align:left">任意个数字符</td><td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr><td style="text-align:left"><code>A+</code></td><td style="text-align:left">至少1个字符</td><td style="text-align:left"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr><td style="text-align:left"><code>A?</code></td><td style="text-align:left">0个或1个字符</td><td style="text-align:left">空，<code>A</code></td></tr><tr><td style="text-align:left"><code>A&#123;3&#125;</code></td><td style="text-align:left">指定个数字符</td><td style="text-align:left"><code>AAA</code></td></tr><tr><td style="text-align:left"><code>A&#123;2,3&#125;</code></td><td style="text-align:left">指定范围个数字符</td><td style="text-align:left"><code>AA</code>，<code>AAA</code></td></tr><tr><td style="text-align:left"><code>A&#123;2,&#125;</code></td><td style="text-align:left">至少n个字符</td><td style="text-align:left"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td></tr><tr><td style="text-align:left"><code>A&#123;0,3&#125;</code></td><td style="text-align:left">最多n个字符</td><td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td></tr></tbody></table><h3 id="复杂匹配规则">复杂匹配规则<a class="header-anchor" href="#复杂匹配规则">⁍</a></h3><table><thead><tr><th style="text-align:left">正则表达式</th><th style="text-align:left">规则</th><th style="text-align:left">可以匹配</th></tr></thead><tbody><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">开头</td><td style="text-align:left">字符串开头</td></tr><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">结尾</td><td style="text-align:left">字符串结束</td></tr><tr><td style="text-align:left"><code>[ABC]</code></td><td style="text-align:left">[…]内任意字符</td><td style="text-align:left">A，B，C</td></tr><tr><td style="text-align:left"><code>[A-F0-9xy]</code></td><td style="text-align:left">指定范围的字符</td><td style="text-align:left"><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td></tr><tr><td style="text-align:left"><code>[^A-F]</code></td><td style="text-align:left">指定范围外的任意字符</td><td style="text-align:left">非<code>A</code>~<code>F</code></td></tr><tr><td style="text-align:left"><code>AB|CD|EF</code></td><td style="text-align:left">AB或CD或EF</td><td style="text-align:left"><code>AB</code>，<code>CD</code>，<code>EF</code></td></tr></tbody></table><h3 id="分组匹配">分组匹配<a class="header-anchor" href="#分组匹配">⁍</a></h3><p><mark>引入<code>java.util.regex</code>包</mark>，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串</p><p>正则表达式用<code>(...)</code>分组可以通过<code>Matcher</code>对象快速提取子串：</p><ul><li><code>group(0)</code>表示匹配的整个字符串；</li><li><code>group(1)</code>表示第1个子串，<code>group(2)</code>表示第2个子串，以此类推</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pattern p = Pattern.compile(<span class="hljs-string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);<br>        Matcher m = p.matcher(<span class="hljs-string">&quot;010-12345678&quot;</span>);<br>        <span class="hljs-keyword">if</span> (m.matches()) &#123;<br>            String g1 = m.group(<span class="hljs-number">1</span>);<br>            String g2 = m.group(<span class="hljs-number">2</span>);<br>            System.out.println(g1);<br>            System.out.println(g2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;匹配失败!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="非贪婪匹配">非贪婪匹配<a class="header-anchor" href="#非贪婪匹配">⁍</a></h3><p>正则表达式匹配默认使用贪婪匹配，可以使用<code>?</code>表示对某一规则进行非贪婪匹配。</p><p>例：给定一个字符串表示的数字，判断该数字末尾<code>0</code>的个数。例如：</p><ul><li><code>&quot;123000&quot;</code>：3个<code>0</code></li><li><code>&quot;10100&quot;</code>：2个<code>0</code></li><li><code>&quot;1001&quot;</code>：0个<code>0</code></li></ul><p>正则表达式<code>(\d+?)(0*)</code>，后面<code>?</code>表示非贪婪匹配，让<code>\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配</p><h3 id="搜索和替换">搜索和替换<a class="header-anchor" href="#搜索和替换">⁍</a></h3><p>使用正则表达式可以：</p><ul><li><p>分割字符串：<code>String.split()</code></p></li><li><p>搜索子串：<code>Matcher.find()</code></p></li><li><p>替换字符串：<code>String.replaceAll()</code></p><ul><li><p>反向引用 可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ```java">    String s = &quot;the quick brown fox jumps over the lazy dog.&quot;;<br>    <br>    String r = s.replaceAll(&quot;\\s([a-z]&#123;4&#125;)\\s&quot;, &quot; &lt;b&gt;$1&lt;/b&gt; &quot;);<br>    //the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.<br><br>[Matcher (Java SE 11 &amp; JDK 11 ) (runoob.com)](https://www.runoob.com/manual/jdk11api/java.base/java/util/regex/Matcher.html)<br><br>&gt; #### 模板引擎<br>&gt;<br>&gt; 模板引擎是指，定义一个字符串作为模板：<br>&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>Hello, ${name}! You are learning ${lang}!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>其中，以`$&#123;key&#125;`表示的是变量，也就是将要被替换的内容<br><br>当传入一个`Map&lt;String, String&gt;`给模板后，需要把对应的key替换为Map的value。<br><br>例如，传入`Map`为：<br><br>```json<br>&#123;<br>&quot;name&quot;: &quot;Bob&quot;,<br>&quot;lang&quot;: &quot;Java&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，<code>$&#123;name&#125;</code>被替换为<code>Map</code>对应的值&quot;Bob”，<code>$&#123;lang&#125;</code>被替换为<code>Map</code>对应的值&quot;Java&quot;，最终输出的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Hello, Bob! You are learning Java!<br></code></pre></td></tr></table></figure><p><strong>用正则表达式实现：</strong></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,java.lang.String)">Matcher.appendReplacement (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itranswarp.learnjava;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Learn Java from https://www.liaoxuefeng.com/</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liaoxuefeng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span> </span>&#123;<br><br><span class="hljs-keyword">final</span> String template;<br><span class="hljs-keyword">final</span> Pattern pattern = Pattern.compile(<span class="hljs-string">&quot;\\$\\&#123;(\\w+)\\&#125;&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Template</span><span class="hljs-params">(String template)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.template = template;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">render</span><span class="hljs-params">(Map&lt;String, Object&gt; data)</span> </span>&#123;<br>Matcher m = pattern.matcher(template);<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-keyword">while</span> (m.find()) &#123;<br>m.appendReplacement(sb,data.get(m.group(<span class="hljs-number">1</span>)).toString());<br>&#125;<br>m.appendTail(sb);<br><span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（九）| IO</title>
      <link href="/augu1sto/13244dc8c38f/"/>
      <url>/augu1sto/13244dc8c38f/</url>
      
        <content type="html"><![CDATA[<h2 id="io">IO<a class="header-anchor" href="#io">⁍</a></h2><p>IO流是一种流式的数据输入/输出模型：</p><ul><li>二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>/<code>OutputStream</code>中单向流动；</li><li>字符数据以<code>char</code>为最小单位在<code>Reader</code>/<code>Writer</code>中单向流动。</li></ul><p>Java标准库的<code>java.io</code>包提供了同步IO功能：</p><ul><li>字节流接口：<code>InputStream</code>/<code>OutputStream</code>；</li><li>字符流接口：<code>Reader</code>/<code>Writer</code>。</li></ul><p>而<code>java.nio</code>则是异步IO</p><blockquote><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p></blockquote><h3 id="file对象">File对象<a class="header-anchor" href="#file对象">⁍</a></h3><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li><p>创建<code>File</code>对象本身不涉及IO操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br>File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Windows\\notepad.exe&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符</p></blockquote></li><li><p>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</p></li><li><p>调用<code>isFile()</code>，判断该<code>File</code>对象是否是一个已存在的文件，调用<code>isDirectory()</code>，判断该<code>File</code>对象是否是一个已存在的目录</p></li><li><p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li><code>boolean canRead()</code>：是否可读；</li><li><code>boolean canWrite()</code>：是否可写；</li><li><code>boolean canExecute()</code>：是否可执行；</li><li><code>long length()</code>：文件字节大小。</li></ul></li><li><p>可以创建或删除文件和目录。</p><ul><li><code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件</li><li>File对象如果表示一个目录，可以通过以下方法创建和删除目录：<ul><li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul></li><li>File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File f = File.createTempFile(<span class="hljs-string">&quot;tmp-&quot;</span>, <span class="hljs-string">&quot;.txt&quot;</span>); <span class="hljs-comment">// 提供临时文件的前缀和后缀</span><br>        f.deleteOnExit(); <span class="hljs-comment">// JVM退出时自动删除</span><br>        System.out.println(f.isFile());<br>        System.out.println(f.getAbsolutePath());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>(遍历)可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</p><ul><li><code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录</li></ul></li></ul><h3 id="path对象">Path对象<a class="header-anchor" href="#path对象">⁍</a></h3><p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path p1 = Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;project&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>); <span class="hljs-comment">// 构造一个Path对象</span><br>        System.out.println(p1);<br>        Path p2 = p1.toAbsolutePath(); <span class="hljs-comment">// 转换为绝对路径</span><br>        System.out.println(p2);<br>        Path p3 = p2.normalize(); <span class="hljs-comment">// 转换为规范路径</span><br>        System.out.println(p3);<br>        File f = p3.toFile(); <span class="hljs-comment">// 转换为File对象</span><br>        System.out.println(f);<br>        <span class="hljs-keyword">for</span> (Path p : Paths.get(<span class="hljs-string">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class="hljs-comment">// 可以直接遍历Path</span><br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + p);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果需要对目录进行复杂的拼接、遍历等操作，使用<code>Path</code>对象更方便。</p><h3 id="inputstream">InputStream<a class="header-anchor" href="#inputstream">⁍</a></h3><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类（抽象类）</p><p>常用方法：<a href="https://www.runoob.com/manual/jdk11api/java.base/java/io/InputStream.html">InputStream (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><ul><li><code>int read()：</code> 读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）</li><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭，代替<code>try ... finally</code>。推荐的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> (InputStream input = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/readme.txt&quot;</span>)) &#123;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1000</span>]; <span class="hljs-comment">//定义1000个字节大小的缓冲区</span><br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">while</span> (n = input.read(buffer)) != -<span class="hljs-number">1</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;read &quot;</span> + n + <span class="hljs-string">&quot; bytes.&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-comment">// 编译器在此自动为我们写入finally并调用close()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有与IO操作相关的代码都必须正确处理<code>IOException</code>。</p><h4 id="阻塞">阻塞<a class="header-anchor" href="#阻塞">⁍</a></h4><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n;<br>n = input.read(); <span class="hljs-comment">// 必须等待read()方法返回才能执行下一行代码</span><br><span class="hljs-keyword">int</span> m = n;<br></code></pre></td></tr></table></figure><p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p><h4 id="inputstream实现类">InputStream实现类<a class="header-anchor" href="#inputstream实现类">⁍</a></h4><ul><li><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。</p></li><li><p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，测试常用</p></li><li><p><a href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletInputStream.html"><code>ServletInputStream</code></a>：从HTTP请求读取数据；</p><blockquote><p>属于Javax（Java扩展包）</p></blockquote></li></ul><h3 id="outputstream">OutputStream<a class="header-anchor" href="#outputstream">⁍</a></h3><p>整体与InputStream相似，常用方法是<code>write</code></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/io/OutputStream.html">OutputStream (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p><mark>⭐</mark> 某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p><blockquote><h5 id="为什么要有flush-？">为什么要有<code>flush()</code>？<a class="header-anchor" href="#为什么要有flush-？">⁍</a></h5><p>因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个<strong>缓冲区</strong>里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。</p><p>对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>实际上，<code>InputStream</code>也有缓冲区。例如，从<code>FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code>int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code>read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p></blockquote><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><h4 id="输入写入到输出">输入写入到输出<a class="header-anchor" href="#输入写入到输出">⁍</a></h4><ul><li><code>long transferTo(OutputStream out)</code>： 从该输入流中读取所有字节，并按读取顺序将字节写入给定的输出流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyFile</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">2</span>) &#123;<br>System.err.println(<span class="hljs-string">&quot;Usage:\n  java CopyFile.java &lt;source&gt; &lt;target&gt;&quot;</span>);<br>System.exit(<span class="hljs-number">1</span>);<br>&#125;<br>copy(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String source, String target)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">// 友情提示：测试时请使用无关紧要的文件</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br><span class="hljs-keyword">try</span>(InputStream input = <span class="hljs-keyword">new</span> FileInputStream(source);<br>OutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(target))&#123;<br>input.transferTo(output);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="filter模式（或者装饰器模式：decorator）">Filter模式（或者装饰器模式：Decorator）<a class="header-anchor" href="#filter模式（或者装饰器模式：decorator）">⁍</a></h3><table><thead><tr><th>Ⅰ. 直接提供数据的基础<code>InputStream</code></th><th>Ⅱ. 提供额外附加功能的<code>InputStream</code><br />（<code>FilterInputSream</code>）</th></tr></thead><tbody><tr><td>FileInputStream</td><td>BufferedInputStream</td></tr><tr><td>ByteArrayInputStream</td><td>DigestInputStream</td></tr><tr><td>ServletInputStream</td><td>CipherInputStream</td></tr></tbody></table><p>可以用第Ⅱ类对第Ⅰ类进行包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">InputStream file = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.gz&quot;</span>);<br>InputStream buffered = <span class="hljs-keyword">new</span> BufferedInputStream(file);<br>InputStream gzip = <span class="hljs-keyword">new</span> GZIPInputStream(buffered);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌─────────────────────────┐<br>│GZIPInputStream          │<br>│┌───────────────────────┐│<br>││BufferedFileInputStream││<br>││┌─────────────────────┐││<br>│││   FileInputStream   │││<br>││└─────────────────────┘││<br>│└───────────────────────┘│<br>└─────────────────────────┘<br></code></pre></td></tr></table></figure><ul><li>OutputStream同理</li><li>可以自己编写<code>FilterInputStream</code>，以便可以把自己的<code>FilterInputStream</code>“叠加”到任何一个<code>InputStream</code>中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FilterInputStream</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h3 id="操作zip">操作Zip<a class="header-anchor" href="#操作zip">⁍</a></h3><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────────────────┐<br>│    InputStream    │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│ FilterInputStream │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│InflaterInputStream│<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│  ZipInputStream   │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│  JarInputStream   │<br>└───────────────────┘<br></code></pre></td></tr></table></figure><h4 id="读zip">读Zip<a class="header-anchor" href="#读zip">⁍</a></h4><p>传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p><p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(ZipInputStream zip = <span class="hljs-keyword">new</span> ZipInputStream(<span class="hljs-keyword">new</span> FileInputStream(...)))&#123;<br>    ZipEntry entry = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//定义entry</span><br>    <span class="hljs-keyword">while</span>(entry = zip.getNextEntry()!=<span class="hljs-keyword">null</span>)&#123;<br>        String name = entry.getName();<span class="hljs-comment">//获得文件名</span><br>        <span class="hljs-keyword">if</span>(!entry.isDirectory())&#123;<span class="hljs-comment">//如果是文件</span><br>            <span class="hljs-keyword">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = zip.read()) != -<span class="hljs-number">1</span>)&#123;<br>                ...<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="写zip">写Zip<a class="header-anchor" href="#写zip">⁍</a></h4><p>先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，</p><p>然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(ZipOutputStream zip = <span class="hljs-keyword">new</span> ZipOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(...)))&#123;<br>    File[] files = ...<br>    <span class="hljs-keyword">for</span>(File file : files)&#123;<br>        zip.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(file.getName()));<br>        zip.write(getFileDataAsBytes(file));<br>        zip.closeEntry();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的<code>name</code>要用相对路径。</p><h4 id="读取classpath资源">读取classpath资源<a class="header-anchor" href="#读取classpath资源">⁍</a></h4><p>路径无关的读取文件的方式：把资源存储在classpath中可以避免文件路径依赖；</p><p>在classpath中的资源文件，路径总是以<code>／</code>开头，我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件；</p><p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，如果为<code>null</code>，表示资源文件在classpath中没有找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="hljs-string">&quot;/default.properties&quot;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(inputStreamFromClassPath(<span class="hljs-string">&quot;/default.properties&quot;</span>));<br>props.load(inputStreamFromFile(<span class="hljs-string">&quot;./conf.properties&quot;</span>));<br></code></pre></td></tr></table></figure><p>这样读取配置文件，应用程序启动就更加灵活。</p><h3 id="序列化">序列化<a class="header-anchor" href="#序列化">⁍</a></h3><h4 id="概念">概念<a class="header-anchor" href="#概念">⁍</a></h4><p>把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程</p><p>通过反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p><h4 id="条件">条件<a class="header-anchor" href="#条件">⁍</a></h4><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p><h4 id="实现">实现<a class="header-anchor" href="#实现">⁍</a></h4><p>需要使用<code>ObjectOutputStream</code>包装<code>ByteArrayOutputStream</code>，可以写入任何实现了<code>Serializable</code>接口的<code>Object</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteArrayOutputStream buffer = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        <span class="hljs-keyword">try</span> (ObjectOutputStream output = <span class="hljs-keyword">new</span> ObjectOutputStream(buffer)) &#123;<br>            <span class="hljs-comment">// 写入int:</span><br>            output.writeInt(<span class="hljs-number">12345</span>);<br>            <span class="hljs-comment">// 写入String:</span><br>            output.writeUTF(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            <span class="hljs-comment">// 写入Object:</span><br>            output.writeObject(Double.valueOf(<span class="hljs-number">123.456</span>));<br>        &#125;<br>        System.out.println(Arrays.toString(buffer.toByteArray()));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="反序列化">反序列化<a class="header-anchor" href="#反序列化">⁍</a></h4><p><code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (ObjectInputStream input = <span class="hljs-keyword">new</span> ObjectInputStream(...)) &#123;<br>    <span class="hljs-keyword">int</span> n = input.readInt();<br>    String s = input.readUTF();<br>    Double d = (Double) input.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；A电脑把传递对象给B电脑，但B电脑上没有定义该对象的类</li><li><code>InvalidClassException</code>：Class不匹配。反序列化时的字段类型与元对象不一致</li></ul><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2709425275741743919L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>要特别注意反序列化的几个重要特点：</p><p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><h4 id="安全性问题">安全性问题<a class="header-anchor" href="#安全性问题">⁍</a></h4><p>一个精心构造的<code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>更好的序列化方法是<strong>通过JSON这样的通用数据结构</strong>来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h3 id="reader">Reader<a class="header-anchor" href="#reader">⁍</a></h3><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p><table><thead><tr><th style="text-align:left">InputStream</th><th style="text-align:left">Reader</th></tr></thead><tbody><tr><td style="text-align:left">字节流，以<code>byte</code>为单位</td><td style="text-align:left">字符流，以<code>char</code>为单位</td></tr><tr><td style="text-align:left">读取字节（-1，0~255）：<code>int read()</code></td><td style="text-align:left">读取字符（-1，0~65535）：<code>int read()</code></td></tr><tr><td style="text-align:left">读到字节数组：<code>int read(byte[] b)</code></td><td style="text-align:left">读到字符数组：<code>int read(char[] c)</code></td></tr></tbody></table><p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~<code>65535</code>。如果已读到末尾，返回<code>-1</code>。</p><p><code>Reader</code>定义了所有字符输入流的超类：</p><ul><li><p><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Reader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure></li><li><p><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</p></li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p><h3 id="writer">Writer<a class="header-anchor" href="#writer">⁍</a></h3><p><code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p><table><thead><tr><th style="text-align:left">OutputStream</th><th style="text-align:left">Writer</th></tr></thead><tbody><tr><td style="text-align:left">字节流，以<code>byte</code>为单位</td><td style="text-align:left">字符流，以<code>char</code>为单位</td></tr><tr><td style="text-align:left">写入字节（0~255）：<code>void write(int b)</code></td><td style="text-align:left">写入字符（0~65535）：<code>void write(int c)</code></td></tr><tr><td style="text-align:left">写入字节数组：<code>void write(byte[] b)</code></td><td style="text-align:left">写入字符数组：<code>void write(char[] c)</code></td></tr><tr><td style="text-align:left">无对应方法</td><td style="text-align:left">写入String：<code>void write(String s)</code></td></tr></tbody></table><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Writer writer = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;readme.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>)) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="printstream和printwriter">PrintStream和PrintWriter<a class="header-anchor" href="#printstream和printwriter">⁍</a></h3><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p><ul><li><code>System.out</code>是标准输出；</li><li><code>System.err</code>是标准错误输出。</li></ul><p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p><h3 id="使用files">使用Files<a class="header-anchor" href="#使用files">⁍</a></h3><p>对于简单的小文件读写操作（不可一次读入几个G的大文件），可以使用<code>Files</code>工具类简化代码。</p><h4 id="读文件">读文件<a class="header-anchor" href="#读文件">⁍</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认使用UTF-8编码读取:</span><br>String content1 = Files.readString(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>));<br><span class="hljs-comment">// 可指定编码:</span><br>String content2 = Files.readString(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);<br><span class="hljs-comment">// 按行读取并返回每行内容:</span><br>List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="写文件">写文件<a class="header-anchor" href="#写文件">⁍</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写入二进制文件:</span><br><span class="hljs-keyword">byte</span>[] data = ...<br>Files.write(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), data);<br><span class="hljs-comment">// 写入文本并指定编码:</span><br>Files.writeString(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), <span class="hljs-string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);<br><span class="hljs-comment">// 按行写入文本:</span><br>List&lt;String&gt; lines = ...<br>Files.write(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), lines);<br></code></pre></td></tr></table></figure><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提取Leetbook和Leetcode题解为markdown笔记</title>
      <link href="/augu1sto/b44ffb96c7e8/"/>
      <url>/augu1sto/b44ffb96c7e8/</url>
      
        <content type="html"><![CDATA[<h2 id="项目源码地址">项目源码地址<a class="header-anchor" href="#项目源码地址">⁍</a></h2><p><a href="https://github.com/Augu1sto/leet2md">Augu1sto/leet2md: 将leetcode.cn上面的部分leetbook和solution题解保存为markdown文件 (github.com)</a></p><h2 id="需求分析">需求分析<a class="header-anchor" href="#需求分析">⁍</a></h2><p>在阅读Leetcode题解、Leetbook（如<a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a>）要做markdown笔记时，复制粘贴总会出现格式混乱/公式渲染等问题。经过一阵尝试和分析之后，打算直接用python爬取整个网页内容，将文章保存存为markdown格式再进行编辑。</p><h2 id="网页分析">网页分析<a class="header-anchor" href="#网页分析">⁍</a></h2><p>以<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/phn3m1/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a>为例</p><p>通过查看网页源码发现，文章的具体内容是动态加载的，【F12】-<code>网络</code>-<code>Fetch/XHR</code>-刷新，可以查看捕获的数据包。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201301801080.png" alt="image-20220130180134972"></p><p>按<code>大小</code>进行排序，在<code>预览</code>里可以看到每个数据包大致的内容，如下图的数据包大致就是整本书的一个目录索引</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201301803685.png" alt="image-20220130180311633"></p><p>看到大概第4个<code>graphql</code>的时候，就看到目标文章了</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201301806435.png" alt="image-20220130180656396"></p><blockquote><p>注意这里的<code>type</code>是<code>MARKDOWN</code>，<code>value</code>的内容就是Markdown格式的文章。而有的leetbook的<code>type</code>是其他类型比如HTML，这里就不考虑、不处理了。</p></blockquote><p>接下来的工作重点就是将这个<code>value</code>值爬下来。</p><h2 id="graphql">GraphQL<a class="header-anchor" href="#graphql">⁍</a></h2><p>GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>GrapgQL是Facebook发明的，在Facebook/Github/coursera/…中有广泛应用。</p><p>GraphQL的使用与学习主要集中在描述与请求上，本文设计的问题应该就是要请求查询，可以参考<a href="https://graphql.cn/code/#python-client">GraphQL Code Libraries, Tools and Services</a>进行学习。</p><p><mark>但文章中选择直接利用requests实现<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</mark></p><h2 id="request实现leetbook中markdown类型文章爬取">request实现Leetbook中markdown类型文章爬取<a class="header-anchor" href="#request实现leetbook中markdown类型文章爬取">⁍</a></h2><h3 id="构造post请求">构造POST请求<a class="header-anchor" href="#构造post请求">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">response = requests.request(<span class="hljs-string">&quot;POST&quot;</span>,url,headers=headers,data=json.dumps(payload))<br></code></pre></td></tr></table></figure><h4 id="url">url<a class="header-anchor" href="#url">⁍</a></h4><p>在<a href="#%E7%BD%91%E9%A1%B5%E5%88%86%E6%9E%90">前文</a>提到的捕获的数据包中查看<code>标头</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201301857021.png" alt="image-20220130185718992"></p><p>所需的url即为<code>https://leetcode-cn.com/graphql/</code></p><blockquote><p>可以发现前面是<code>https://leetcode-cn.com/</code>，也就是整个leetcode网站的url。</p><p>据我观察，大部分<code>url</code>都是<code>[根站点网址]/graphql</code>的形式</p></blockquote><h4 id="headers">headers<a class="header-anchor" href="#headers">⁍</a></h4><p>即<code>请求标头</code>这一栏，其中最为重要的是<code>cookie</code>、<code>origin</code>、<code>refer</code>三个字段</p><ul><li><code>cookie</code>：包含了你的登录ID、session等信息，直接复制下来就可以</li><li><code>origin</code>：网站根地址，这里就是<code>https://leetcode-cn.com/</code></li><li><code>refer</code>：你要爬的文章的地址</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201301903076.png" alt="image-20220130190341031"></p><h4 id="payload">payload<a class="header-anchor" href="#payload">⁍</a></h4><p>选择<code>payload</code>，右击-<code>复制值</code>即可</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201301908095.png" alt="image-20220130190837060"></p><p><strong>注意，</strong> <code>payload</code>的<code>variables</code>里有一项<code>pageId</code>，即为文章网址最后的一串字符，同时在第一个<code>graphql</code>中也有记录（见下图），我们可以通过这种方式来<mark>爬取整本书的内容</mark>。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201301803685.png" alt="image-20220130180311633"></p><h3 id="解析内容">解析内容<a class="header-anchor" href="#解析内容">⁍</a></h3><p>对<code>response.content</code>进行解码，即可获得<code>预览</code>中的数据</p><p>首先分析该文章是否是markdown形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;leetbookPage&quot;</span>][<span class="hljs-string">&quot;blocks&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;type&quot;</span>]!=<span class="hljs-string">&#x27;MARKDOWN&#x27;</span>:<br>    print(<span class="hljs-string">&quot;非markdown类型\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果是，我们即可提取出内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mdtext = b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;leetbookPage&quot;</span>][<span class="hljs-string">&quot;blocks&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;value&quot;</span>]<br>mdtitle = b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;leetbookPage&quot;</span>][<span class="hljs-string">&quot;title&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="源码">源码<a class="header-anchor" href="#源码">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"># <span class="hljs-meta">@author</span>: augu1sto<br># blog: augu1sto.gitee.io<br><br># 将leetbook存为markdown（仅适用于源网页是markdown类型的书籍）<br># 例 图解算法数据结构 https:<span class="hljs-comment">//leetcode-cn.com/leetbook/read/illustration-of-algorithm</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><br>url = <span class="hljs-string">&quot;https://leetcode-cn.com/graphql/&quot;</span><br><br><br>headers = &#123;<br><br><span class="hljs-string">&#x27;accept&#x27;</span>: <span class="hljs-string">&#x27;*/*&#x27;</span>,<br><span class="hljs-string">&#x27;accept-encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate, br&#x27;</span>,<br><span class="hljs-string">&#x27;accept-language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN&#x27;</span>,<br><span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br><span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-string">&#x27;origin&#x27;</span>: <span class="hljs-string">&#x27;https://leetcode-cn.com&#x27;</span>,<br><span class="hljs-string">&#x27;referer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Edg/97.0.1072.55&#x27;</span>,<br><br><br>&#125;<br><br>payload = &#123;<span class="hljs-string">&quot;operationName&quot;</span>:<span class="hljs-string">&quot;leetbookPageDetail&quot;</span>,<br><span class="hljs-string">&quot;variables&quot;</span>:&#123;<span class="hljs-string">&quot;pageId&quot;</span>:<span class="hljs-string">&quot;&quot;</span>&#125;,<br><span class="hljs-string">&quot;query&quot;</span>:<span class="hljs-string">&quot;query leetbookPageDetail($pageId: ID!) &#123;\n  leetbookPage(pageId: $pageId) &#123;\n    title\n    subtitle\n    id\n    pageType\n    blocks &#123;\n      type\n      value\n      __typename\n    &#125;\n    commonTags &#123;\n      nameTranslated\n      name\n      slug\n      __typename\n    &#125;\n    qaQuestionUuid\n    ...leetbookQuestionPageNode\n    __typename\n  &#125;\n&#125;\n\nfragment leetbookQuestionPageNode on LeetbookQuestionPage &#123;\n  question &#123;\n    questionId\n    envInfo\n    judgeType\n    metaData\n    enableRunCode\n    sampleTestCase\n    judgerAvailable\n    langToValidPlayground\n    questionFrontendId\n    style\n    content\n    translatedContent\n    questionType\n    questionTitleSlug\n    editorType\n    mysqlSchemas\n    codeSnippets &#123;\n      lang\n      langSlug\n      code\n      __typename\n    &#125;\n    topicTags &#123;\n      slug\n      name\n      translatedName\n      __typename\n    &#125;\n    __typename\n  &#125;\n  __typename\n&#125;\n&quot;</span>&#125;<br><br><br>site_url = input(<span class="hljs-string">&quot;site_url: &quot;</span>)<br>page_id = input(<span class="hljs-string">&quot;page_id: &quot;</span>)<br>cookie = input(<span class="hljs-string">&quot;cookie: &quot;</span>)<br><br><br>headers[<span class="hljs-string">&#x27;referer&#x27;</span>]= site_url<br>payload[<span class="hljs-string">&#x27;variables&#x27;</span>][<span class="hljs-string">&#x27;pageId&#x27;</span>] = page_id<br>headers[<span class="hljs-string">&#x27;cookie&#x27;</span>] = cookie<br><br>response = requests.request(<span class="hljs-string">&quot;POST&quot;</span>,url,headers=headers,data=json.dumps(payload))<br><br>a=response.content.decode()<br>b=json.loads(a)<br><br><span class="hljs-keyword">if</span> b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;leetbookPage&quot;</span>][<span class="hljs-string">&quot;blocks&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;type&quot;</span>]!=<span class="hljs-string">&#x27;MARKDOWN&#x27;</span>:<br>    print(<span class="hljs-string">&quot;非markdown类型\n&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    mdtext = b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;leetbookPage&quot;</span>][<span class="hljs-string">&quot;blocks&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;value&quot;</span>]<br>    mdtitle = b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;leetbookPage&quot;</span>][<span class="hljs-string">&quot;title&quot;</span>]<br><br>    <span class="hljs-function">with <span class="hljs-title">open</span><span class="hljs-params">(mdtitle+<span class="hljs-string">&#x27;.md&#x27;</span>,<span class="hljs-string">&#x27;w+&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span> as f:</span><br><span class="hljs-function">        f.<span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-string">&quot;# &quot;</span>+mdtitle+<span class="hljs-string">&quot;\n\n&quot;</span>)</span></span><br><span class="hljs-function">        f.<span class="hljs-title">write</span><span class="hljs-params">(mdtext)</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h2 id="request实现leetcode中官方题解的爬取">request实现Leetcode中官方题解的爬取<a class="header-anchor" href="#request实现leetcode中官方题解的爬取">⁍</a></h2><p>通过类似的分析思路，我们也可以爬取leetcode指定链接的题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"># <span class="hljs-meta">@author</span>: augu1sto<br># blog: augu1sto.gitee.io<br><br># 将leetcode的solution存为markdown<br># 仅测试了官方题解<br><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><br>url = <span class="hljs-string">&quot;https://leetcode-cn.com/graphql/&quot;</span><br><br><br>headers = &#123;<br><br><span class="hljs-string">&#x27;accept&#x27;</span>: <span class="hljs-string">&#x27;*/*&#x27;</span>,<br><span class="hljs-string">&#x27;accept-encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate, br&#x27;</span>,<br><span class="hljs-string">&#x27;accept-language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN&#x27;</span>,<br><span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br><span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-string">&#x27;origin&#x27;</span>: <span class="hljs-string">&#x27;https://leetcode-cn.com&#x27;</span>,<br><span class="hljs-string">&#x27;referer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Edg/97.0.1072.55&#x27;</span>,<br><br><br>&#125;<br><br>payload = &#123;<span class="hljs-string">&quot;operationName&quot;</span>:<span class="hljs-string">&quot;solutionDetailArticle&quot;</span>,<br><span class="hljs-string">&quot;variables&quot;</span>:&#123;<span class="hljs-string">&quot;slug&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;orderBy&quot;</span>:<span class="hljs-string">&quot;DEFAULT&quot;</span>&#125;,<br><span class="hljs-string">&quot;query&quot;</span>:<span class="hljs-string">&quot;query solutionDetailArticle($slug: String!, $orderBy: SolutionArticleOrderBy!) &#123;\n  solutionArticle(slug: $slug, orderBy: $orderBy) &#123;\n    ...solutionArticle\n    content\n    question &#123;\n      questionTitleSlug\n      __typename\n    &#125;\n    position\n    next &#123;\n      slug\n      title\n      __typename\n    &#125;\n    prev &#123;\n      slug\n      title\n      __typename\n    &#125;\n    __typename\n  &#125;\n&#125;\n\nfragment solutionArticle on SolutionArticleNode &#123;\n  rewardEnabled\n  canEditReward\n  uuid\n  title\n  slug\n  sunk\n  chargeType\n  status\n  identifier\n  canEdit\n  canSee\n  reactionType\n  reactionsV2 &#123;\n    count\n    reactionType\n    __typename\n  &#125;\n  tags &#123;\n    name\n    nameTranslated\n    slug\n    tagType\n    __typename\n  &#125;\n  createdAt\n  thumbnail\n  author &#123;\n    username\n    profile &#123;\n      userAvatar\n      userSlug\n      realName\n      __typename\n    &#125;\n    __typename\n  &#125;\n  summary\n  topic &#123;\n    id\n    commentCount\n    viewCount\n    __typename\n  &#125;\n  byLeetcode\n  isMyFavorite\n  isMostPopular\n  isEditorsPick\n  hitCount\n  videosInfo &#123;\n    videoId\n    coverUrl\n    duration\n    __typename\n  &#125;\n  __typename\n&#125;\n&quot;</span>&#125;<br><br><br>site_url = input(<span class="hljs-string">&quot;site_url: &quot;</span>)<br><br>U = site_url.split(<span class="hljs-string">&#x27;/&#x27;</span>)<br><span class="hljs-keyword">if</span> U[-<span class="hljs-number">1</span>]!=<span class="hljs-string">&#x27;&#x27;</span>:<br>    sol_name = U[-<span class="hljs-number">1</span>]<br><span class="hljs-keyword">else</span>:<br>    sol_name = U[-<span class="hljs-number">2</span>]<br><br>cookie = input(<span class="hljs-string">&quot;cookie: &quot;</span>)<br><br><br>headers[<span class="hljs-string">&#x27;referer&#x27;</span>]= site_url<br>payload[<span class="hljs-string">&#x27;variables&#x27;</span>][<span class="hljs-string">&#x27;slug&#x27;</span>] = sol_name<br>headers[<span class="hljs-string">&#x27;cookie&#x27;</span>] = cookie<br><br>response = requests.request(<span class="hljs-string">&quot;POST&quot;</span>,url,headers=headers,data=json.dumps(payload))<br><br>a=response.content.decode()<br>b=json.loads(a)<br><br>mdtext = b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;solutionArticle&quot;</span>][<span class="hljs-string">&quot;content&quot;</span>]<br>mdtitle = b[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;solutionArticle&quot;</span>][<span class="hljs-string">&quot;title&quot;</span>]<br><br><span class="hljs-function">with <span class="hljs-title">open</span><span class="hljs-params">(mdtitle+<span class="hljs-string">&#x27;.md&#x27;</span>,<span class="hljs-string">&#x27;w+&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span> as f:</span><br><span class="hljs-function">    f.<span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-string">&quot;#&quot;</span>+mdtitle+<span class="hljs-string">&quot;\n\n&quot;</span>)</span></span><br><span class="hljs-function">    f.<span class="hljs-title">write</span><span class="hljs-params">(mdtext)</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h2 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h2><ul><li><p>通过对leetcode网站数据包的分析，实现了指定链接的markdown文章内容的获取，从而保留完整的文章格式和公式。</p></li><li><p>对graphql可以进行深一步了解，比如用<a href="https://github.com/graphql-python/gql">GitHub - graphql-python/gql: A GraphQL client in Python</a>改写代码。</p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/question/264629587">什么是 GraphQL？ - 知乎 (zhihu.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://graphql.cn/">GraphQL | A query language for your API</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://blog.csdn.net/Ezrealer/article/details/106664656">【爬虫】requests 实现 graphql 请求_Ezrealer的博客-CSDN博客_graphql 爬虫</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> GraphQL </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】TrajGAIL·Generating urban vehicle trajectories using  generative adversarial imitation learning</title>
      <link href="/augu1sto/b8163cc89113/"/>
      <url>/augu1sto/b8163cc89113/</url>
      
        <content type="html"><![CDATA[<h2 id="论文基本信息">论文基本信息<a class="header-anchor" href="#论文基本信息">⁍</a></h2><ul><li>作者：Chu Cao, Mo Li（南洋理工）</li><li>年份：2021</li><li>会议/期刊：Transportation Research Part C: Emerging Technologies</li><li>相关下载：<ul><li><a href="https://www.sciencedirect.com/science/article/pii/S0968090X21001121">原文PDF (acm.org)</a></li></ul></li><li><h2 id="阅读参考：">阅读参考：<a class="header-anchor" href="#阅读参考：">⁍</a></h2></li><li>开源信息： <a href="https://github.com/benchoi93/TrajGAIL">github</a> ()</li><li>简介：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 轨迹合成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轨迹 </tag>
            
            <tag> 隐私保护 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|排序</title>
      <link href="/augu1sto/f9cf7ed28499/"/>
      <url>/augu1sto/f9cf7ed28499/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/55frat/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><h2 id="排序算法简介">排序算法简介<a class="header-anchor" href="#排序算法简介">⁍</a></h2><h3 id="概述">概述<a class="header-anchor" href="#概述">⁍</a></h3><p>排序算法用作实现列表的排序，列表元素可以是整数，也可以是浮点数、字符串等其他数据类型。生活中有许多需要排序算法的场景，例如：</p><ul><li><strong>整数排序：</strong> 对于一个整数数组，我们希望将所有数字从小到大排序；</li><li><strong>字符串排序：</strong> 对于一个姓名列表，我们希望将所有单词按照字符先后排序；</li><li><strong>自定义排序：</strong> 对于任意一个 <strong>已定义比较规则</strong> 的集合，我们希望将其按规则排序；</li></ul><p>同时，某些算法需要在排序算法的基础上使用（即在排序数组上运行），例如：</p><ul><li><strong>二分查找：</strong> 根据数组已排序的特性，才能每轮确定排除两部分中的哪一部分；</li><li><strong>双指针：</strong> 例如<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">合并两个排序链表</a>，根据已排序特性，才能通过双指针移动在线性时间内将其合并为一个排序链表。</li></ul><blockquote><p>接下来，本文将从「常见排序算法」、「分类方法」、「时间与空间复杂度」三方面入手，简要介绍排序算法。「各排序算法详细介绍」请见后续专栏文章。</p></blockquote><h3 id="常见算法">常见算法<a class="header-anchor" href="#常见算法">⁍</a></h3><p>常见排序算法包括「冒泡排序」、「插入排序」、「选择排序」、「快速排序」、「归并排序」、「堆排序」、「基数排序」、「桶排序」。如下图所示，为各排序算法的核心特性与时空复杂度总结。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201052356444.png" alt="Picture2.png"></p><p>如下图所示，为在 「随机乱序」、「接近有序」、「完全倒序」、「少数独特」四类输入数据下，各常见排序算法的排序过程。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131710829.gif" alt="krahets-bubble-sort.gif"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131711421.gif" alt="krahets-insertion-sort.gif"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131711698.gif" alt="krahets-selection-sort.gif"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131711416.gif" alt="krahets-quick-sort.gif"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131711277.gif" alt="krahets-merge-sort.gif"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131711504.gif" alt="krahets-heap-sort.gif"></p><h3 id="分类方法">分类方法<a class="header-anchor" href="#分类方法">⁍</a></h3><p>排序算法主要可根据 <strong>稳定性</strong> 、<strong>就地性</strong> 、<strong>自适应性</strong> 分类。理想的排序算法具有以下特性：</p><ul><li>具有稳定性，即相等元素的相对位置不变化；</li><li>具有就地性，即不使用额外的辅助空间；</li><li>具有自适应性，即时间复杂度受元素分布影响；</li></ul><p>特别地，任意排序算法都 不同时具有以上所有特性 。因此，排序算法的选型使用取决于具体的列表类型、元素数量、元素分布情况等应用场景特点。</p><h4 id="稳定性：">稳定性：<a class="header-anchor" href="#稳定性：">⁍</a></h4><p>根据 <strong>相等元素</strong> 在数组中的 <strong>相对顺序</strong> 是否被改变，排序算法可分为「稳定排序」和「非稳定排序」两类。</p><ul><li>「稳定排序」在完成排序后，<strong>不改变</strong> 相等元素在数组中的相对顺序。例如：冒泡排序、插入排序、归并排序、基数排序、桶排序。</li><li>「非稳定排序」在完成排序后，相等素在数组中的相对位置 <strong>可能被改变</strong> 。例如：选择排序、快速排序、堆排序。</li></ul><h4 id="就地性：">就地性：<a class="header-anchor" href="#就地性：">⁍</a></h4><p>根据排序过程中 <strong>是否使用额外内存（辅助数组）</strong>，排序算法可分为「原地排序」和「异地排序」两类。一般地，由于不使用外部内存，原地排序相比非原地排序的执行效率更高。</p><ul><li>「原地排序」不使用额外辅助数组，例如：冒泡排序、插入排序、选择排序、快速排序、堆排序。</li></ul><p>「非原地排序」使用额外辅助数组，例如：归并排序、基数排序、桶排序。</p><h4 id="自适应性：">自适应性：<a class="header-anchor" href="#自适应性：">⁍</a></h4><p>根据算法 <strong>时间复杂度</strong> 是否 <strong>受待排序数组的元素分布影响</strong> ，排序算法可分为「自适应排序」和「非自适应排序」两类。</p><ul><li>「自适应排序」的时间复杂度受元素分布影响；例如：冒泡排序、插入排序、快速排序、桶排序。</li><li>「非自适应排序」的时间复杂度恒定；例如：选择排序、归并排序、堆排序、基数排序。</li></ul><h4 id="比较类：">比较类：<a class="header-anchor" href="#比较类：">⁍</a></h4><p>比较类排序基于元素之间的 <strong>比较算子</strong>（小于、相等、大于）来决定元素的相对顺序；相对的，非比较排序则不基于比较算子实现。</p><ul><li>「比较类排序」基于元素之间的比较完成排序，例如：冒泡排序、插入排序、选择排序、快速排序、归并排序、堆排序。</li><li>「非比较类排序」不基于元素之间的比较完成排序，例如：基数排序、桶排序。</li></ul><h3 id="时空复杂度">时空复杂度<a class="header-anchor" href="#时空复杂度">⁍</a></h3><p>总体上看，排序算法追求时间与空间复杂度最低。而即使某些排序算法的时间复杂度相等，但实际性能还受 输入列表性质、元素数量、元素分布等 等因素影响。</p><p>设输入列表元素数量为$N$，常见排序算法的「时间复杂度」和「空间复杂度」如下图所示。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201060001696.png" alt="image-20220106000130643"></p><p>对于上表，需要特别注意：</p><ul><li>「基数排序」适用于正整数、字符串、特定格式的浮点数排序，$k$ 为最大数字的位数；「桶排序」中 $k$ 为桶的数量。</li><li>普通「冒泡排序」的最佳时间复杂度为 $O(N^2)$，通过增加标志位实现 提前返回 ，可以将最佳时间复杂度降低至 $O(N)$。</li><li>在输入列表完全倒序下，普通「快速排序」的空间复杂度劣化至 $O(N)$，通过代码优化 <strong>Tail Call Optimization</strong> 保持算法递归较短子数组，可以将最差递归深度降低至 $\log N$。</li><li>普通「快速排序」总以最左或最右元素为基准数，因此在输入列表有序或倒序下，时间复杂度劣化至 $O(N^2)$；通过 随机选择基准数 ，可极大减少此类最差情况发生，尽可能地保持 $O(N \log N)$的时间复杂度。</li><li>若输入列表是数组，则归并排序的空间复杂度为 $O(N)$ ；而若排序 <strong>链表</strong> ，则「归并排序」不需要借助额外辅助空间，空间复杂度可以降低至 $O(1)$ 。</li></ul><h2 id="冒泡排序">冒泡排序<a class="header-anchor" href="#冒泡排序">⁍</a></h2><ul><li><strong>内循环：</strong> 使用相邻双指针 <code>j</code> , <code>j + 1</code> 从左至右遍历，依次比较相邻元素大小，若左元素大于右元素则将它们交换；遍历完成时，<strong>最大元素会被交换至数组最右边</strong> 。</li><li><strong>外循环：</strong> 不断重复「内循环」，每轮将当前最大元素交换至 <strong>剩余未排序数组最右边</strong> ，直至所有元素都被交换至正确位置时结束。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.length - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                Common common = <span class="hljs-keyword">new</span> Common();<br>                common.swap(j, j + <span class="hljs-number">1</span>, nums);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析：">复杂度分析：<a class="header-anchor" href="#复杂度分析：">⁍</a></h3><ul><li><p><strong>时间复杂度 $O(N^2)$ ：</strong> 其中 $N$ 为输入数组的元素数量；「外循环」共 $N - 1$ 轮，使用 $O(N)$ 时间；每轮「内循环」分别遍历 $N - 1$ , $N - 2$ , $\cdots$ , $2$ , $1$ 次，平均 $\frac{N}{2}$ 次，使用 $O(\frac{N}{2}) = O(N)$ 时间；因此，总体时间复杂度为 $O(N^2)$ 。</p></li><li><p><strong>空间复杂度 $O(1)$ ：</strong> 只需原地交换元素，使用常数大小的额外空间。</p></li></ul><h3 id="算法特性：">算法特性：<a class="header-anchor" href="#算法特性：">⁍</a></h3><ul><li><p>时间复杂度为 $O(N^2)$ ，因为其是通过不断 <strong>交换元素</strong> 实现排序（交换 2 个元素需要 3 次赋值操作），因此速度较慢；</p></li><li><p><strong>原地：</strong> 指针变量仅使用常数大小额外空间，空间复杂度为 $O(1)$ ；</p></li><li><p><strong>稳定：</strong> 元素值相同时不交换，因此不会改变相同元素的相对位置；</p></li><li><p><strong>自适应：</strong> 通过增加一个标志位 <code>flag</code> ，若某轮内循环未执行任何交换操作时，说明已经完成排序，因此直接返回。此优化使冒泡排序的最优时间复杂度达到 $O(N)$（当输入数组已排序时）；</p></li></ul><h2 id="快速排序">快速排序<a class="header-anchor" href="#快速排序">⁍</a></h2><p>快速排序算法有两个核心点，分别为 <strong>哨兵划分</strong> 和 <strong>递归</strong> 。</p><ul><li><p><strong>哨兵划分：</strong> 以数组某个元素（一般选取首元素）为 <strong>基准数</strong> ，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p><ul><li>流程： 取基准；将基准后面的元素进行划分——左边的是小于基准的元素，右边的是大于基准的元素；将基准交换至临界处；完毕。<img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131718879.png" alt="Picture2.png"></li></ul></li><li><p><strong>递归：</strong> 对 <strong>左子数组</strong> 和 <strong>右子数组</strong> 分别递归执行 <strong>哨兵划分</strong>，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。</p><blockquote><p>如下图所示，为示例数组 <code>[2,4,1,0,3,5]</code> 的快速排序流程。观察发现，快速排序和 <strong>二分法</strong> 的原理类似，都是以 $\log$ 时间复杂度实现搜索区间缩小。</p></blockquote><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131718872.png" alt="Picture1.png">{:width=550}</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// 基准nums[l]</span><br>    <span class="hljs-keyword">int</span> i = l;<br>    <span class="hljs-keyword">int</span> j = r;<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-comment">// 找从右往左第一个&lt;基准的数</span><br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= nums[l])&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 找从左往右第一个&gt;基准的数</span><br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= nums[l])&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 交换两个数</span><br>        Common common = <span class="hljs-keyword">new</span> Common();<br>        common.swap(i, j, nums);<br><br>    &#125;<br>    <span class="hljs-comment">// 将基准交换到中间临界处</span><br>    Common common = <span class="hljs-keyword">new</span> Common();<br>    common.swap(i, l, nums);<br><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> t = partition(nums, l, r);<br>    quickSort(nums, l, t-<span class="hljs-number">1</span>);<br>    quickSort(nums, t+<span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析<a class="header-anchor" href="#复杂度分析">⁍</a></h3><ul><li><p><strong>时间复杂度：</strong></p><ul><li><p><strong>最佳 $\Omega(N \log N )$ ：</strong> 最佳情况下， 每轮哨兵划分操作将数组划分为等长度的两个子数组；哨兵划分操作为线性时间复杂度 $O(N)$ ；递归轮数共 $O(\log N)$ 。</p></li><li><p><strong>平均 $\Theta(N \log N)$ ：</strong> 对于随机输入数组，哨兵划分操作的递归轮数也为 $O(\log N)$ 。</p></li><li><p><strong>最差 $O(N^2)$ ：</strong> 对于某些特殊输入数组，每轮哨兵划分操作都将长度为 $N$ 的数组划分为长度为 $1$ 和 $N - 1$ 的两个子数组，此时递归轮数达到 $N$ 。</p><blockquote><p>通过 「<strong>随机选择基准数</strong>」优化，可尽可能避免出现最差情况。</p><p>每轮在子数组中随机选择一个元素作为基准数，这样就可以极大概率避免以上劣化情况。</p><p>值得注意的是，由于仍然可能出现最差情况，因此快速排序的最差时间复杂度仍为$O(N^2)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 在闭区间 [l, r] 随机选取任意索引，并与 nums[l] 交换</span><br>    <span class="hljs-keyword">int</span> ra = (<span class="hljs-keyword">int</span>)(l + Math.random() * (r - l + <span class="hljs-number">1</span>));<br>    swap(nums, l, ra);<br>    <span class="hljs-comment">// 以 nums[l] 作为基准数，下同</span><br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><p><strong>空间复杂度 $O(N)$ ：</strong> 快速排序的递归深度最好与平均皆为 $\log N$ ；输入数组完全倒序下，达到最差递归深度 $N$ 。</p><blockquote><p>通过「<strong>Tail Call</strong>」优化，可将最差空间复杂度降低至 $O(\log N)$ 。</p><p>每轮递归时，仅对 <strong>较短的子数组</strong> 执行哨兵划分 <code>partition()</code> ，就可将最差的递归深度控制在 $O(\log N)$ （每轮递归的子数组长度都 $\leq$ 当前数组长度 $/ 2$ ），即实现最差空间复杂度 $O(\log N)$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 子数组长度为 1 时终止递归</span><br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-comment">// 哨兵划分操作</span><br>        <span class="hljs-keyword">int</span> i = partition(nums, l, r);<br>        <span class="hljs-comment">// 仅递归至较短子数组，控制递归深度</span><br>        <span class="hljs-keyword">if</span> (i - l &lt; r - i) &#123;<br>            quickSort(nums, l, i - <span class="hljs-number">1</span>);<br>            l = i + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quickSort(nums, i + <span class="hljs-number">1</span>, r);<br>            r = i - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="算法特性">算法特性<a class="header-anchor" href="#算法特性">⁍</a></h3><ul><li><p>虽然平均时间复杂度与「归并排序」和「堆排序」一致，但在实际使用中快速排序 <strong>效率更高</strong> ，这是因为：</p><ul><li><p><strong>最差情况稀疏性：</strong> 虽然快速排序的最差时间复杂度为 $O(N^2)$ ，差于归并排序和堆排序，但统计意义上看，这种情况出现的机率很低。大部分情况下，快速排序以 $O(N \log N)$ 复杂度运行。</p></li><li><p><strong>缓存使用效率高：</strong> 哨兵划分操作时，将整个子数组加载入缓存中，访问元素效率很高；堆排序需要跳跃式访问元素，因此不具有此特性。</p></li><li><p><strong>常数系数低：</strong> 在提及的三种算法中，快速排序的 <strong>比较</strong>、<strong>赋值</strong>、<strong>交换</strong> 三种操作的综合耗时最低（类似于插入排序快于冒泡排序的原理）。</p></li></ul></li><li><p><strong>原地：</strong> 不用借助辅助数组的额外空间，递归仅使用 $O(\log N)$ 大小的栈帧空间。</p></li><li><p><strong>非稳定：</strong> 哨兵划分操作可能改变相等元素的相对顺序。</p></li><li><p><strong>自适应：</strong> 对于极少输入数据，每轮哨兵划分操作都将长度为 $N$ 的数组划分为长度 $1$ 和 $N - 1$ 两个子数组，此时时间复杂度劣化至 $O(N^2)$ 。</p></li></ul><h2 id="归并排序">归并排序<a class="header-anchor" href="#归并排序">⁍</a></h2><p>归并排序体现了 “分而治之” 的算法思想，具体为：</p><ul><li><p><strong>「分」：</strong> 不断将数组从 <strong>中点位置</strong> 划分开，将原数组的排序问题转化为子数组的排序问题；</p></li><li><p><strong>「治」：</strong> 划分到子数组长度为 1 时，开始向上合并，不断将 <strong>左右两个较短排序数组</strong> 合并为 <strong>一个较长排序数组</strong>，直至合并至原数组时完成排序；</p></li></ul><blockquote><p>如下图所示，为数组 <code>[7,3,2,6,0,1,5,4]</code> 的归并排序过程。</p></blockquote><p><img src="https://pic.leetcode-cn.com/1632675739-CNHaOu-Picture1.png" alt="Picture1.png">{:width=500}</p><h4 id="算法流程：">算法流程：<a class="header-anchor" href="#算法流程：">⁍</a></h4><ol><li><p><strong>递归划分：</strong></p><ol><li><p>计算数组中点 $m$ ，递归划分左子数组 <code>merge_sort(l, m)</code> 和右子数组 <code>merge_sort(m + 1, r)</code> ；</p></li><li><p>当 $l \geq r$  时，代表子数组长度为 1 或 0 ，此时 <strong>终止划分</strong> ，开始合并；</p></li></ol></li><li><p><strong>合并子数组：</strong></p><ol><li><p>暂存数组 $nums$ 闭区间 $[l, r]$ 内的元素至辅助数组 $tmp$ ；</p></li><li><p><strong>循环合并：</strong> 设置双指针 $i$ , $j$ 分别指向 $tmp$ 的左 / 右子数组的首元素；</p><blockquote><p><strong>注意：</strong> $nums$ 子数组的左边界、中点、右边界分别为 $l$ , $m$ , $r$ ，而辅助数组 $tmp$ 中的对应索引为 $0$ , $m - l$ , $r - l$ ；</p></blockquote><ul><li><strong>当 $i == m - l + 1$ 时：</strong> 代表左子数组已合并完，因此添加右子数组元素 $tmp[j]$ ，并执行 $j = j + 1$ ；</li><li><strong>否则，当 $j == r - l + 1$ 时：</strong> 代表右子数组已合并完，因此添加左子数组元素 $tmp[i]$ ，并执行 $i = i + 1$ ；</li><li><strong>否则，当 $tmp[i] \leq tmp[j]$ 时：</strong> 添加左子数组元素 $tmp[i]$ ，并执行 $i = i + 1$ ；</li><li><strong>否则（即当 $tmp[i] &gt; tmp[j]$ 时）：</strong> 添加右子数组元素 $tmp[j]$ ，并执行 $j = j + 1$ ；</li></ul></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 递归划分</span><br>    <span class="hljs-keyword">int</span> m = (r + l) / <span class="hljs-number">2</span>;<br>    mergeSort(nums,l,m);<br>    mergeSort(nums,m+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-comment">// 暂存需要合并的区间的元素</span><br>    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br>        tmp[k-l] = nums[k];<br>    &#125;<br>    <span class="hljs-comment">// 设置双指针 i , j 分别指向 tmp 的左 / 右子数组的首元素</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br>        <span class="hljs-keyword">if</span> (i == m - l + <span class="hljs-number">1</span>)&#123;<br>            nums[k] = tmp[j++];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == r - l + <span class="hljs-number">1</span>)&#123;<br>            nums[k] = tmp[i++];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[i] &lt;= tmp[j])&#123;<br>            nums[k] = tmp[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            nums[k] = tmp[j++];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    mergeSort(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2">复杂度分析<a class="header-anchor" href="#复杂度分析-2">⁍</a></h3><ul><li><p><strong>时间复杂度：</strong> 最佳 $\Omega(N \log N )$ ，平均 $\Theta(N \log N)$ ，最差 $O(N \log N)$ 。</p></li><li><p><strong>空间复杂度 $O(N)$ ：</strong> 合并过程中需要借助辅助数组 $tmp$ ，使用 $O(N)$ 大小的额外空间；划分的递归深度为 $\log N$ ，使用 $O(\log N)$ 大小的栈帧空间。</p></li><li><p>若输入数据是 <strong>链表</strong> ，则归并排序的空间复杂度可被优化至 $O(1)$ ，这是因为：</p><ul><li><p>通过应用「双指针法」，可在 $O(1)$ 空间下完成两个排序链表的合并，省去辅助数组 $tmp$ 使用的额外空间；</p></li><li><p>通过使用「迭代」代替「递归划分」，可省去递归使用的栈帧空间；</p><blockquote><p>详情请参考：<a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/">148. 排序链表</a></p></blockquote></li></ul></li></ul><h3 id="算法特性-2">算法特性<a class="header-anchor" href="#算法特性-2">⁍</a></h3><ul><li><p><strong>非原地：</strong> 辅助数组 $tmp$ 需要使用额外空间。</p></li><li><p><strong>稳定：</strong> 归并排序不改变相等元素的相对顺序。</p></li><li><p><strong>非自适应：</strong> 对于任意输入数据，归并排序的时间复杂度皆相同。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（八）| 集合</title>
      <link href="/augu1sto/e49df870bd32/"/>
      <url>/augu1sto/e49df870bd32/</url>
      
        <content type="html"><![CDATA[<h2 id="java集合简介">Java集合简介<a class="header-anchor" href="#java集合简介">⁍</a></h2><p>Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p><ul><li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li><li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li><li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li></ul><p>几个特点：</p><ol><li>实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等</li><li>支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素</li></ol><p>Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><hr><h3 id="java集合框架">java集合框架<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><a class="header-anchor" href="#java集合框架">⁍</a></h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="img"></p><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p><ul><li>**接口：**是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li>**实现（类）：**是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li>**算法：**是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><h3 id="集合框架体系如图所示">集合框架体系如图所示<a class="header-anchor" href="#集合框架体系如图所示">⁍</a></h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/java-coll-2020-11-16.png" alt="img"></p><p>Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</p><h3 id="集合接口">集合接口<a class="header-anchor" href="#集合接口">⁍</a></h3><p>集合框架定义了一些接口。本节提供了每个接口的概述：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">接口描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Collection 接口<br />Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">List 接口<br />List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Set<br />Set 具有与 Collection 完全一样的接口，只是行为上不同，**Set 不保存重复的元素。**Set 接口存储一组唯一，无序的对象。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">SortedSet<br />继承于Set保存有序的集合。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">Map<br />Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">Map.Entry<br />描述在一个Map中的一个元素（键/值对）。是一个 Map 的内部接口。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">SortedMap<br />继承于 Map，使 Key 保持在升序排列。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">Enumeration<br />这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td></tr></tbody></table><h4 id="set和list的区别">Set和List的区别<a class="header-anchor" href="#set和list的区别">⁍</a></h4><ol><li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</li><li>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <strong>&lt;实现类有HashSet,TreeSet&gt;</strong></li><li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> 。</li></ol><hr><h3 id="集合实现类（集合类）">集合实现类（集合类）<a class="header-anchor" href="#集合实现类（集合类）">⁍</a></h3><p>Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。</p><p>标准集合类汇总于下表：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>AbstractCollection</strong>  实现了大部分的集合接口。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>AbstractList</strong>  继承于AbstractCollection 并且实现了大部分List接口。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>AbstractSequentialList</strong>  继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/java/java-linkedlist.html">LinkedList</a> 该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：<code>List list=Collections.synchronizedList(newLinkedList(...));</code>LinkedList 查找效率低。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a> 该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>AbstractSet</strong>  继承于AbstractCollection 并且实现了大部分Set接口。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashset.html">HashSet</a> 该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">LinkedHashSet 具有可预知迭代顺序的 <code>Set</code> 接口的哈希表和链接列表实现。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">TreeSet 该类实现了Set接口，可以实现排序等功能。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong>AbstractMap</strong>  实现了大部分的Map接口。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/java/java-hashmap.html">HashMap</a> HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">TreeMap 继承了AbstractMap，并且使用一颗树。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">WeakHashMap 继承AbstractMap类，使用弱密钥的哈希表。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">LinkedHashMap 继承于HashMap，使用元素的自然顺序对元素进行排序.</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">IdentityHashMap 继承AbstractMap类，比较文档时使用引用相等。</td></tr></tbody></table><p>在前面的教程中已经讨论通过java.util包中定义的类，如下所示：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Vector 该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Stack 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Dictionary Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">Hashtable Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">Properties Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">BitSet 一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</td></tr></tbody></table><hr><h3 id="集合算法">集合算法<a class="header-anchor" href="#集合算法">⁍</a></h3><p>集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。</p><p>在尝试比较不兼容的类型时，一些方法能够抛出 ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。</p><p>集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP的。这些变量都不可改变。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">算法描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Collection Algorithms 这里是一个列表中的所有算法实现。</td></tr></tbody></table><h2 id="list">List<a class="header-anchor" href="#list">⁍</a></h2><p><code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p><ul><li>在末尾添加一个元素：<code>boolean add(E e)</code></li><li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li><li>删除指定索引的元素：<code>E remove(int index)</code></li><li>删除某个元素：<code>boolean remove(Object e)</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>返回某个元素索引（不存在则返回<code>-1</code>）：<code>int indexOf(Objext o)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li><li>判断<code>List</code>是否包含某个指定元素：<code>boolean contains(Object o)</code></li><li>修改元素：<code>E set(int index, E e)</code></li></ul><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/List.html">List (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/ArrayList.html">ArrayList (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedList.html">LinkedList (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p><code>ArrayList</code>是List的数组实现，<code>LinkedList</code>则是List的链表实现</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td style="text-align:left">获取指定元素</td><td style="text-align:left">速度很快</td><td>需要从头开始查找元素</td></tr><tr><td style="text-align:left">添加元素到末尾</td><td style="text-align:left">速度很快</td><td>速度很快</td></tr><tr><td style="text-align:left">在指定位置添加/删除</td><td style="text-align:left">需要移动元素</td><td>不需要移动元素</td></tr><tr><td style="text-align:left">内存占用</td><td style="text-align:left">少</td><td>较大</td></tr></tbody></table><p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p><p><mark>import java.util.List;</mark></p><p><mark>import java.util.ArrayList;</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><h3 id="list的特点">List的特点<a class="header-anchor" href="#list的特点">⁍</a></h3><ul><li>允许添加重复元素</li><li>允许添加null</li></ul><h3 id="创建list">创建List<a class="header-anchor" href="#创建list">⁍</a></h3><p>通过给定元素快速创建List：<code>List.of(...)</code>（不接受<code>null</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h3 id="遍历list">遍历List<a class="header-anchor" href="#遍历list">⁍</a></h3><ul><li><p>（不推荐）用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历</p><blockquote><p><code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢</p></blockquote></li><li><p>坚持使用迭代器<code>Iterator</code>来访问<code>List</code>。</p><ul><li><p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>            String s = it.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><mark>常用</mark>Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p></li></ul></li></ul><h3 id="list和array转换">List和Array转换<a class="header-anchor" href="#list和array转换">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br></code></pre></td></tr></table></figure><p>把<code>List</code>变为<code>Array</code>有三种方法：</p><ol><li><p>(很少用)调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组（会丢失类型信息）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] array = list.toArray();<br></code></pre></td></tr></table></figure></li><li><p>给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[<span class="hljs-number">3</span>]);<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[list.size()]);<br></code></pre></td></tr></table></figure></li><li><p>函数式写法，通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = list.toArray(Integer[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure></li></ol><p>把<code>Array</code>变为<code>List</code></p><ol><li><p>通过<code>List.of(T...)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(array);<br></code></pre></td></tr></table></figure></li><li><p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code></p></li></ol><p>返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个<mark>只读</mark><code>List</code>（对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。）</p><blockquote><h3 id="问题：">问题：<a class="header-anchor" href="#问题：">⁍</a></h3><p>怎么初始化ArrayList</p><p>Array变回List怎么才能写</p><p>直接打印List(调试用)<code>System.out.println(list.toString());</code></p></blockquote><h2 id="编写equals方法">编写equals方法<a class="header-anchor" href="#编写equals方法">⁍</a></h2><p><code>List</code>内部并不是通过<code>==</code>判断两个元素是否相等，而是使用<code>equals()</code>方法判断两个元素是否相等。</p><p>要正确使用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写<code>equals()</code>方法，否则，放进去的实例，查找不到。</p><p><mark>例子：</mark><code>Person</code>类没有覆写<code>equals()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; list = List.of(<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Ming&quot;</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Hong&quot;</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>)<br>        );<br>        System.out.println(list.contains(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="编写equals">编写equals<a class="header-anchor" href="#编写equals">⁍</a></h3><p><mark>如果不在<code>List</code>中查找元素，就不必覆写<code>equals()</code>方法。</mark></p><p><code>equals()</code>方法要求我们必须满足以下条件：</p><ul><li>**自反性（Reflexive）：**对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li><li>**对称性（Symmetric）：**对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li><li>**传递性（Transitive）：**对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li><li>**一致性（Consistent）：**对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li><li>**对<code>null</code>的比较：**即<code>x.equals(null)</code>永远返回<code>false</code>。</li></ul><p><code>equals()</code>方法的正确编写方法：</p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，转型继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。<mark>import java.util.Objects</mark></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(<span class="hljs-keyword">this</span>.name, p.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断<code>null</code>的麻烦。两个引用类型都是<code>null</code>时它们也是相等的。</p><p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现<code>equals()</code>方法。</p><blockquote><p>问题</p><p>模式变量？</p><p>用IDEA编写的时候，提示可以把p换成模式变量，即写为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">o <span class="hljs-keyword">instanceof</span> Person p<br></code></pre></td></tr></table></figure></blockquote><h2 id="map">Map<a class="header-anchor" href="#map">⁍</a></h2><p><mark>import java.util.HashMap;</mark></p><p><mark>import java.util.Map;</mark></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Map.html">Map (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p>初始化(<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">变量和类型</th><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>size()</code></td><td style="text-align:left">返回此映射中键 - 值映射的数量。</td></tr><tr><td style="text-align:left"><code>V</code></td><td style="text-align:left"><code>put(K key, V value)</code></td><td style="text-align:left">将指定的值与此映射中的指定键相关联（可选操作）。</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>putAll(Map&lt;? extends K,? extends V&gt; m)</code></td><td style="text-align:left">将指定映射中的所有映射复制到此映射（可选操作）。</td></tr><tr><td style="text-align:left"><code>V</code></td><td style="text-align:left"><code>get(Object key)</code></td><td style="text-align:left">返回指定键映射到的值，如果此映射不包含键的映射，则返回 <code>null</code> 。</td></tr><tr><td style="text-align:left"><code>Collection&lt;V&gt;</code></td><td style="text-align:left"><code>values()</code></td><td style="text-align:left">返回此映射中包含的值的<a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Collection.html"><code>Collection</code></a>视图。</td></tr><tr><td style="text-align:left"><code>Set&lt;K&gt;</code></td><td style="text-align:left"><code>keySet()</code></td><td style="text-align:left">返回此映射中包含的键的<a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Set.html"><code>Set</code></a>视图。</td></tr><tr><td style="text-align:left"><code>V</code></td><td style="text-align:left"><code>get(Object key)</code></td><td style="text-align:left">返回指定键映射到的值，如果此映射不包含键的映射，则返回 <code>null</code> 。</td></tr><tr><td style="text-align:left"><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td><td style="text-align:left"><code>entrySet()</code></td><td style="text-align:left">返回此映射中包含的映射的<a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Set.html"><code>Set</code></a>视图。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>isEmpty()</code></td><td style="text-align:left">如果此映射不包含键 - 值映射，则返回 <code>true</code> 。</td></tr><tr><td style="text-align:left"><code>default V</code></td><td style="text-align:left"><code>replace(K key, V value)</code></td><td style="text-align:left">仅当指定键当前映射到某个值时，才替换该条目的条目。</td></tr><tr><td style="text-align:left"><code>default boolean</code></td><td style="text-align:left"><code>replace(K key, V oldValue, V newValue)</code></td><td style="text-align:left">仅当前映射到指定值时，才替换指定键的条目。</td></tr><tr><td style="text-align:left"><code>V</code></td><td style="text-align:left"><code>remove(Object key)</code></td><td style="text-align:left">如果存在，则从该映射中移除键的映射（可选操作）。</td></tr><tr><td style="text-align:left"><code>default boolean</code></td><td style="text-align:left"><code>remove(Object key, Object value)</code></td><td style="text-align:left">仅当指定键当前映射到指定值时才删除该条目的条目。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>containsKey(Object key)</code></td><td style="text-align:left">如果此映射包含指定键的映射，则返回 <code>true</code> 。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>containsValue(Object value)</code></td><td style="text-align:left">如果此映射将一个或多个键映射到指定值，则返回 <code>true</code> 。</td></tr></tbody></table><p>Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。？</p><h3 id="嵌套类？map-entry">嵌套类？Map.Entry<a class="header-anchor" href="#嵌套类？map-entry">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Map.Entry.html">Map.Entry (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p>映射条目（键值对）。 <code>Map.entrySet</code>方法返回地图的集合视图，其元素属于此类。这些<code>Map.Entry</code>对象<em>仅</em>在迭代期间有效; 更正式地说，如果在迭代器返回条目后修改了支持映射，则映射条目的行为是未定义的，除非通过映射条目上的<code>setValue</code>操作。</p><table><thead><tr><th style="text-align:left">变量和类型</th><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>equals(Object o)</code></td><td style="text-align:left">将指定对象与此条目进行比较以获得相等性。</td></tr><tr><td style="text-align:left"><code>K</code></td><td style="text-align:left"><code>getKey()</code></td><td style="text-align:left">返回与此条目对应的键。</td></tr><tr><td style="text-align:left"><code>V</code></td><td style="text-align:left"><code>getValue()</code></td><td style="text-align:left">返回与此条目对应的值。</td></tr><tr><td style="text-align:left"><code>V</code></td><td style="text-align:left"><code>setValue(V value)</code></td><td style="text-align:left">用指定的值替换此条目对应的值（可选操作）。</td></tr></tbody></table><h3 id="遍历map">遍历Map<a class="header-anchor" href="#遍历map">⁍</a></h3><ul><li><p>使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合</p></li><li><p>使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">123</span>);<br>        map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">456</span>);<br>        map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">789</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>            String key = entry.getKey();<br>            Integer value = entry.getValue();<br>            System.out.println(key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>遍历Map时，不可假设输出的key是有序的！</p><blockquote><h3 id="运用实例">运用实例<a class="header-anchor" href="#运用实例">⁍</a></h3><p>根据<code>name</code>查找<code>score</code>，并利用<code>Map</code>充当缓存。</p><p>先在Map中找，没有再去List中找，找到了添加到Map中，相当于实现了cache，提高之后的查找效率</p></blockquote><h2 id="编写equals和hashcode">编写equals和hashCode<a class="header-anchor" href="#编写equals和hashcode">⁍</a></h2><p>正确使用<code>Map</code>必须保证：</p><ol><li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li><li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：</li></ol><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul><p>即对应两个实例<code>a</code>和<code>b</code>：</p><ul><li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li><li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li></ul><p>上述第一条规范是正确性，必须保证实现，否则<code>HashMap</code>不能正常工作。</p><p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code>hashCode()</code>，会造成<code>Map</code>内部存储冲突，使存取的效率下降。</p><p>⭐借助<code>Objects.hash()</code>来计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(firstName, lastName, age);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p><ul><li><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；</li><li><code>equals()</code>中没有使用到的字段，<mark>绝不</mark>可放在<code>hashCode()</code>中计算。</li></ul><p>另外注意，对于放入<code>HashMap</code>的<code>value</code>对象，没有任何要求。</p><blockquote><ul><li><p><code>HashMap</code>初始化时默认的数组大小只有16，任何<code>key</code>，无论它的<code>hashCode()</code>有多大，都可以简单地通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> index = key.hashCode() &amp; <span class="hljs-number">0xf</span>; <span class="hljs-comment">// 0xf = 15</span><br></code></pre></td></tr></table></figure><p>把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p></li><li><p>添加超过一定数量的<code>key-value</code>时，<code>HashMap</code>会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定<code>hashCode()</code>计算的索引位置。</p></li><li><p>（哈希冲突）使用<code>Map</code>的时候，只要<code>key</code>不相同，它们映射的<code>value</code>就互不干扰。存在不同的<code>key</code>，映射到相同的<code>hashCode()</code>的时候，在<code>HashMap</code>的数组中，实际存储的不是一个<code>Person</code>实例，而是一个<code>List</code>，它包含两个<code>Entry</code>，分别对应两个key的映射</p><p>JDK中源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(e.hash == hash &amp;&amp; <br>   (<br>       (k = e.key) == key || <br>       (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))<br>   )<br>  )&#123;ops;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>重写equals方法，是为了解决hash冲突，如果两个key的hash值相同，就会调用equals方法，比较key值是否相同，在存储时：如果equals结果相同就覆盖更新value值，如果不同就用List他们都存储起来。在取出来是：如果equals结果相同就返回当前value值，如果不同就遍历List中下一个元素。即要key与hash同时匹配才会认为是同一个key。</p></blockquote></li></ul></blockquote><h2 id="使用enummap">使用EnumMap<a class="header-anchor" href="#使用enummap">⁍</a></h2><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间。</p><p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p><h2 id="使用treemap">使用TreeMap<a class="header-anchor" href="#使用treemap">⁍</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───┐<br>       │Map│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashMap│ │SortedMap│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeMap │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p><code>SortedMap</code>接口在内部会对Key进行排序，在遍历时严格按照Key的顺序（<code>String</code>类型就是默认按字母排序）在遍历，最常用的实现类是<code>TreeMap</code>；</p><p>出于“排序”的要求，放入的Key必须实现<code>Comparable</code>接口。</p><p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p><code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a&lt;b</code>，则返回负数，通常是<code>-1</code>，如果<code>a==b</code>，则返回<code>0</code>，如果<code>a&gt;b</code>，则返回正数，通常是<code>1</code>。</p></blockquote><p>可以自定义compare方法，但是在两个Key相等时，必须返回<code>0</code>。</p><h2 id="使用properties配置文件">使用Properties配置文件<a class="header-anchor" href="#使用properties配置文件">⁍</a></h2><p>Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。</p><h3 id="读取配置文件">读取配置文件<a class="header-anchor" href="#读取配置文件">⁍</a></h3><p>用<code>Properties</code>读取配置文件，一共有三步：</p><ol><li>创建<code>Properties</code>实例；</li><li>调用<code>load()</code>读取文件；</li><li>调用<code>getProperty()</code>获取配置。</li></ol><p>如果key不存在，将返回<code>null</code>。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p><p>可以从文件系统中读也可以从classpath中读字节流</p><p>如果有多个<code>.properties</code>文件，可以反复调用<code>load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(getClass().getResourceAsStream(<span class="hljs-string">&quot;/common/setting.properties&quot;</span>));<br>props.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>));<br></code></pre></td></tr></table></figure><p>上面的代码演示了<code>Properties</code>的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p><h3 id="写入配置文件">写入配置文件<a class="header-anchor" href="#写入配置文件">⁍</a></h3><p>用<code>setProperty()</code>修改<code>Properties</code>实例</p><p>用<code>store()</code>方法写入配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.setProperty(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;http://www.liaoxuefeng.com&quot;</span>);<br>props.setProperty(<span class="hljs-string">&quot;language&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>props.store(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="hljs-string">&quot;这是写入的properties注释&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="编码">编码<a class="header-anchor" href="#编码">⁍</a></h3><p>由于<code>load(InputStream)</code>默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法<code>load(Reader)</code>读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure><p>就可以正常读取中文。<code>InputStream</code>和<code>Reader</code>的区别是一个是字节流，一个是字符流。字符流在内存中已经以<code>char</code>类型表示了，不涉及编码问题。</p><h2 id="set">Set<a class="header-anchor" href="#set">⁍</a></h2><p><mark>import java.util.*;</mark></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Set.html">Set (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul><table><thead><tr><th style="text-align:left">变量和类型</th><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>add(E e)</code></td><td style="text-align:left">如果指定的元素尚不存在，则将其添加到此集合（可选操作）。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td style="text-align:left">如果指定集合中的所有元素尚未存在（可选操作），则将其添加到此集合中。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>contains(Object o)</code></td><td style="text-align:left">如果此set包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>remove(Object o)</code></td><td style="text-align:left">如果存在，则从该集合中移除指定的元素（可选操作）。</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>size()</code></td><td style="text-align:left">返回此集合中的元素数（基数）。</td></tr><tr><td style="text-align:left"><code>Object[]</code></td><td style="text-align:left"><code>toArray()</code></td><td style="text-align:left">返回包含此set中所有元素的数组。</td></tr><tr><td style="text-align:left"><code>&lt;T&gt; T[]</code></td><td style="text-align:left"><code>toArray(T[] a)</code></td><td style="text-align:left">返回一个包含此set中所有元素的数组; 返回数组的运行时类型是指定数组的运行时类型。</td></tr></tbody></table><p>经常用<code>Set</code>用于去除重复元素。</p><p>因为放入<code>Set</code>的元素和<code>Map</code>的key类似，都要正确实现<code>equals()</code>和<code>hashCode()</code>方法，否则该元素无法正确地放入<code>Set</code>。</p><h3 id="实现类">实现类<a class="header-anchor" href="#实现类">⁍</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───┐<br>       │Set│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashSet│ │SortedSet│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeSet │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p><code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装</p><p><code>SortedSet</code>接口则保证元素是有序的</p><ul><li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li><li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li></ul><h2 id="queue">Queue<a class="header-anchor" href="#queue">⁍</a></h2><p>也是一个接口，可以用LinkedList实现</p><p><mark>import java.util.LinkedList</mark></p><p><mark>import java.util.Queue</mark></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Queue.html">Queue (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><table><thead><tr><th style="text-align:left">变量和类型</th><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>add(E e)</code></td><td style="text-align:left">如果可以在不违反容量限制的情况下立即执行此操作，则将指定的元素插入此队列，成功时返回 <code>true</code> ，如果当前没有空间，则抛出 <code>IllegalStateException</code> 。</td></tr><tr><td style="text-align:left"><code>E</code></td><td style="text-align:left"><code>element()</code></td><td style="text-align:left">检索但不删除此队列的头部。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>offer(E e)</code></td><td style="text-align:left">如果可以在不违反容量限制的情况下立即执行此操作，则将指定的元素插入此队列。</td></tr><tr><td style="text-align:left"><code>E</code></td><td style="text-align:left"><code>peek()</code></td><td style="text-align:left">检索但不删除此队列的头部，如果此队列为空，则返回 <code>null</code> 。</td></tr><tr><td style="text-align:left"><code>E</code></td><td style="text-align:left"><code>poll()</code></td><td style="text-align:left">检索并删除此队列的头部，如果此队列为空，则返回 <code>null</code> 。</td></tr><tr><td style="text-align:left"><code>E</code></td><td style="text-align:left"><code>remove()</code></td><td style="text-align:left">检索并删除此队列的头部。</td></tr></tbody></table><p>注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">throw Exception</th><th style="text-align:left">返回false或null</th></tr></thead><tbody><tr><td style="text-align:left">添加元素到队尾</td><td style="text-align:left">add(E e)</td><td style="text-align:left">boolean offer(E e)</td></tr><tr><td style="text-align:left">取队首元素并删除</td><td style="text-align:left">E remove()</td><td style="text-align:left">E poll()</td></tr><tr><td style="text-align:left">取队首元素但不删除</td><td style="text-align:left">E element()</td><td style="text-align:left">E peek()</td></tr></tbody></table><p>要避免把<code>null</code>添加到队列。</p><h2 id="priorityqueue">PriorityQueue<a class="header-anchor" href="#priorityqueue">⁍</a></h2><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>根据<code>Comparable</code>接口的实现，根据元素的排序顺序决定“优先级”。</p><p>对于没有实现<code>Comparable</code>接口的元素，可以提供一个<code>Comparator</code>对象来自定义排序方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Queue&lt;User&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> UserComparator());<br><span class="hljs-comment">// 添加3个元素到队列:</span><br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;A1&quot;</span>));<br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A3&quot;</span>));<br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>));<br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A112&quot;</span>));<br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>));<br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;A10&quot;</span>));<br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;A999&quot;</span>));<br>q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;A88&quot;</span>));<br>System.out.println(q.poll()); <span class="hljs-comment">// Boss/V1</span><br>System.out.println(q.poll()); <span class="hljs-comment">// Bob/A1</span><br>System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User u1, User u2)</span> </span>&#123;<br><span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br><span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br><span class="hljs-comment">// 相同的字母开头，截取后面的值</span><br><span class="hljs-keyword">int</span> v1 = u1.number.length();<br><span class="hljs-keyword">int</span> v2 = u2.number.length();<br>String n1 = u1.number.substring(<span class="hljs-number">1</span>, v1);<br>String n2 = u2.number.substring(<span class="hljs-number">1</span>, v2);<br><span class="hljs-comment">// 负值，n1排前面</span><br><span class="hljs-keyword">return</span> Integer.parseInt(n1) - Integer.parseInt(n2);<br>&#125;<br><span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br><span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String number;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String number)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.number = number;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;/&quot;</span> + number;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="deque">Deque<a class="header-anchor" href="#deque">⁍</a></h2><p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p><ul><li>既可以添加到队尾，也可以添加到队首；</li><li>既可以从队首获取，又可以从队尾获取。</li></ul><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Queue</th><th>Deque</th></tr></thead><tbody><tr><td style="text-align:left">添加元素到队尾</td><td style="text-align:left">add(E e) / offer(E e)</td><td>addLast(E e) / offerLast(E e)</td></tr><tr><td style="text-align:left">取队首元素并删除</td><td style="text-align:left">E remove() / E poll()</td><td>E removeFirst() / E pollFirst()</td></tr><tr><td style="text-align:left">取队首元素但不删除</td><td style="text-align:left">E element() / E peek()</td><td>E getFirst() / E peekFirst()</td></tr><tr><td style="text-align:left">添加元素到队首</td><td style="text-align:left">无</td><td>addFirst(E e) / offerFirst(E e)</td></tr><tr><td style="text-align:left">取队尾元素并删除</td><td style="text-align:left">无</td><td>E removeLast() / E pollLast()</td></tr><tr><td style="text-align:left">取队尾元素但不删除</td><td style="text-align:left">无</td><td>E getLast() / E peekLast()</td></tr></tbody></table><p><code>Deque</code>接口实际上扩展自<code>Queue</code>，但总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开</p><h2 id="stack">Stack<a class="header-anchor" href="#stack">⁍</a></h2><p>用<code>Deque</code>可以实现<code>Stack</code>的功能：</p><ul><li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li><li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li></ul><blockquote><p>有个遗留类名字就叫<code>Stack</code>，出于兼容性考虑，所以没办法创建<code>Stack</code>接口</p></blockquote><p><strong>计算中缀表达式</strong> 把带变量的中缀表达式编译为后缀表达式，再进行计算</p><p><a href="https://blog.csdn.net/weixin_46726346/article/details/108829412">JAVA用栈计算中缀表达式（详解）_爱前端的小菜的博客-CSDN博客_java计算中缀表达式</a></p><p><a href="https://www.liaoxuefeng.com/discuss/1279869501571105/1431678195073057">用的笨方法，不太通用 (liaoxuefeng.com)</a></p><h2 id="iterator">Iterator<a class="header-anchor" href="#iterator">⁍</a></h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265124784468736">使用Iterator - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p><ul><li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li><li>用<code>Iterator</code>对象迭代集合内部数据。</li></ul><h2 id="collections">Collections<a class="header-anchor" href="#collections">⁍</a></h2><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Collection.html">Collection (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><table><thead><tr><th style="text-align:left">变量和类型</th><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>add(E e)</code></td><td style="text-align:left">确保此集合包含指定的元素（可选操作）。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td style="text-align:left">将指定集合中的所有元素添加到此集合中（可选操作）。</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>clear()</code></td><td style="text-align:left">从此集合中删除所有元素（可选操作）。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>contains(Object o)</code></td><td style="text-align:left">如果此collection包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>containsAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">如果此集合包含指定集合中的所有元素，则返回 <code>true</code> 。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>equals(Object o)</code></td><td style="text-align:left">将指定对象与此集合进行比较以获得相等性。</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>hashCode()</code></td><td style="text-align:left">返回此集合的哈希码值。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>isEmpty()</code></td><td style="text-align:left">如果此集合不包含任何元素，则返回 <code>true</code> 。</td></tr><tr><td style="text-align:left"><code>Iterator&lt;E&gt;</code></td><td style="text-align:left"><code>iterator()</code></td><td style="text-align:left">返回此集合中元素的迭代器。</td></tr><tr><td style="text-align:left"><code>default Stream&lt;E&gt;</code></td><td style="text-align:left"><code>parallelStream()</code></td><td style="text-align:left">以此集合为源返回可能并行的 <code>Stream</code> 。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>remove(Object o)</code></td><td style="text-align:left">从此集合中移除指定元素的单个实例（如果存在）（可选操作）。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>removeAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">删除此集合的所有元素，这些元素也包含在指定的集合中（可选操作）。</td></tr><tr><td style="text-align:left"><code>default boolean</code></td><td style="text-align:left"><code>removeIf(Predicate&lt;? super E&gt; filter)</code></td><td style="text-align:left">删除此集合中满足给定谓词的所有元素。</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>retainAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">仅保留此集合中包含在指定集合中的元素（可选操作）。</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>size()</code></td><td style="text-align:left">返回此集合中的元素数。</td></tr><tr><td style="text-align:left"><code>default Spliterator&lt;E&gt;</code></td><td style="text-align:left"><code>spliterator()</code></td><td style="text-align:left">在此集合中的元素上创建<a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Spliterator.html"><code>Spliterator</code></a> 。</td></tr><tr><td style="text-align:left"><code>default Stream&lt;E&gt;</code></td><td style="text-align:left"><code>stream()</code></td><td style="text-align:left">返回以此集合为源的顺序 <code>Stream</code> 。</td></tr><tr><td style="text-align:left"><code>Object[]</code></td><td style="text-align:left"><code>toArray()</code></td><td style="text-align:left">返回包含此集合中所有元素的数组。</td></tr><tr><td style="text-align:left"><code>default &lt;T&gt; T[]</code></td><td style="text-align:left"><code>toArray(IntFunction&lt;T[]&gt; generator)</code></td><td style="text-align:left">返回包含此集合中所有元素的数组，使用提供的 <code>generator</code>函数分配返回的数组。</td></tr><tr><td style="text-align:left"><code>&lt;T&gt; T[]</code></td><td style="text-align:left"><code>toArray(T[] a)</code></td><td style="text-align:left">返回一个包含此collection中所有元素的数组; 返回数组的运行时类型是指定数组的运行时类型。</td></tr></tbody></table><p><code>Collections</code>类提供了一组工具方法来方便使用集合类：</p><ul><li>创建空集合；<ul><li>创建空List：<code>List&lt;T&gt; emptyList()</code></li><li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li><li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li></ul></li><li>创建单元素集合；<ul><li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li><li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li><li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li><li>（实际上，使用<code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合）</li></ul></li><li>创建不可变集合；<ul><li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul></li><li>排序／洗牌等操作。<ul><li><code>Collections.sort(list)</code></li><li><code>Collections.shuffle(list)</code></li></ul></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.runoob.com/java/java-collections.html">Java 集合框架 | 菜鸟教程 (runoob.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（七）| 泛型</title>
      <link href="/augu1sto/f3d20640b5a9/"/>
      <url>/augu1sto/f3d20640b5a9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945193293888">泛型 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="什么是泛型">什么是泛型<a class="header-anchor" href="#什么是泛型">⁍</a></h2><p>泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code></p><h3 id="向上转型">向上转型<a class="header-anchor" href="#向上转型">⁍</a></h3><p>类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>（<code>T</code>不能变成父类）</p><blockquote><p>要<em>特别注意</em>：不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p></blockquote><h2 id="使用泛型">使用泛型<a class="header-anchor" href="#使用泛型">⁍</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span><br>List&lt;Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><h3 id="泛型接口">泛型接口<a class="header-anchor" href="#泛型接口">⁍</a></h3><p>在接口中使用泛型</p><p><code>Comparable&lt;T&gt;</code>泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用的时候实现这个接口就可以比较对应的类型了</p><h3 id="编写泛型">编写泛型<a class="header-anchor" href="#编写泛型">⁍</a></h3><p>泛型类型<code>&lt;T&gt;</code>不能用于静态方法</p><p>对于静态方法，我们可以单独改写为**“泛型”方法**，只需要使用另一个类型即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; <span class="hljs-function">Pair&lt;K&gt; <span class="hljs-title">create</span><span class="hljs-params">(K first, K last)</span></span>&#123;&#125;<br><span class="hljs-comment">//写成K只是为了区分，事实上写为T也没问题</span><br></code></pre></td></tr></table></figure><h3 id="多个泛型类型">多个泛型类型<a class="header-anchor" href="#多个泛型类型">⁍</a></h3><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code></p><p>Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。</p><h2 id="擦拭法">擦拭法<a class="header-anchor" href="#擦拭法">⁍</a></h2><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li><p>不能是基本类型，例如：<code>int</code>；（只能是<code>Integer</code>）</p><ul><li><p>因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;<span class="hljs-keyword">int</span>&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</p><ul><li>并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code></li></ul></li><li><p>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</p><ul><li>同上</li></ul></li><li><p>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</p><ul><li>擦拭后实际上变成了<code>new Object();</code></li><li>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数: <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265104600263968">擦拭法 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></li></ul></li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>子类可以获取父类的具体的泛型类型<code>&lt;T&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>&#125;<br><br><span class="hljs-comment">//调用</span><br>IntPair ip = <span class="hljs-keyword">new</span> IntPair(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//可以直接写int参数</span><br></code></pre></td></tr></table></figure><h2 id="extends通配符">extends通配符<a class="header-anchor" href="#extends通配符">⁍</a></h2><p>使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。</p><p>这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为<strong>上界通配符（Upper Bounds Wildcards）</strong>，即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p><p><mark>只能读不能写</mark></p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><h2 id="super通配符">super通配符<a class="header-anchor" href="#super通配符">⁍</a></h2><p><code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p><p>使用<code>&lt;? super Integer&gt;</code>通配符表示：<mark>只能写不能读</mark></p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p><p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            T t = src.get(i);<span class="hljs-comment">// t是producer, src extends</span><br>            dest.add(t);<span class="hljs-comment">// t是consumer, dest extends</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a class="header-anchor" href="#">⁍</a></h3><h3 id="pecs原则">PECS原则<a class="header-anchor" href="#pecs原则">⁍</a></h3><blockquote><p>Producer Extends Consumer Super</p></blockquote><p>如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p><h3 id="无限定通配符">无限定通配符<a class="header-anchor" href="#无限定通配符">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sample</span><span class="hljs-params">(Pair&lt;?&gt; p)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>既不能读，也不能写，那只能做一些<code>null</code>判断</p><p>很少使用，可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类。</p><h2 id="泛型和反射">泛型和反射<a class="header-anchor" href="#泛型和反射">⁍</a></h2><p>我们可以声明带泛型的数组，但不能用<code>new</code>操作符创建带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt;[] ps = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// ok</span><br>Pair&lt;String&gt;[] ps = <span class="hljs-keyword">new</span> Pair&lt;String&gt;[<span class="hljs-number">2</span>]; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>必须通过强制转型实现带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><h3 id="安全使用泛型数组">安全使用泛型数组<a class="header-anchor" href="#安全使用泛型数组">⁍</a></h3><p>使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量<code>ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code>arr</code>，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作<code>arr</code>可能导致从<code>ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>ps[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;String&gt;(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// ClassCastException:</span><br>Pair&lt;String&gt; p = ps[<span class="hljs-number">1</span>];<br>String s = p.getFirst();<br></code></pre></td></tr></table></figure><p>要安全地使用泛型数组，必须扔掉<code>arr</code>的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p><p>必须借助<code>Class&lt;T&gt;</code>来创建泛型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] createArray(Class&lt;T&gt; cls) &#123;<br>    <span class="hljs-keyword">return</span> (T[]) Array.newInstance(cls, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以利用可变参数创建泛型数组<code>T[]</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayHelper</span> </span>&#123;<br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br><br>String[] ss = ArrayHelper.asArray(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>Integer[] ns = ArrayHelper.asArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="谨慎使用泛型可变参数">谨慎使用泛型可变参数<a class="header-anchor" href="#谨慎使用泛型可变参数">⁍</a></h3><blockquote><p>后记</p><p>泛型好难懂</p><p>感觉简而言之不要用x</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（六）| 注解</title>
      <link href="/augu1sto/27ec0eff2a98/"/>
      <url>/augu1sto/27ec0eff2a98/</url>
      
        <content type="html"><![CDATA[<h2 id="注解">注解<a class="header-anchor" href="#注解">⁍</a></h2><p>Java的注解可以分为三类：</p><ol><li>由编译器使用的注解，例如：</li></ol><ul><li><p><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</p></li><li><p><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</p><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p></li></ul><ol start="2"><li><p>由工具处理<code>.class</code>文件使用的注解，比如<strong>有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能</strong>。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p></li><li><p>（<mark>最常用</mark>）在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p></li></ol><h3 id="配置参数">配置参数<a class="header-anchor" href="#配置参数">⁍</a></h3><p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><ul><li>所有基本类型；</li><li>String；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组。</li></ul><p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p><p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p><p>如果只写注解，相当于全部使用默认值。</p><h2 id="定义注解">定义注解<a class="header-anchor" href="#定义注解">⁍</a></h2><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p><h3 id="元注解">元注解<a class="header-anchor" href="#元注解">⁍</a></h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h4 id="target">@Target<a class="header-anchor" href="#target">⁍</a></h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解<code>@Report</code>可用在方法上，我们<mark>必须添加一个<code>@Target(ElementType.METHOD)</code></mark>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;</span><br><span class="hljs-meta">    ElementType.METHOD,</span><br><span class="hljs-meta">    ElementType.FIELD</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p><h4 id="retention">@Retention<a class="header-anchor" href="#retention">⁍</a></h4><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul><p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，<mark>务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解</mark>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="repeatable">@Repeatable<a class="header-anchor" href="#repeatable">⁍</a></h4><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(Reports.class)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Reports &#123;<br>    Report[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Report(type=1, level=&quot;debug&quot;)</span><br><span class="hljs-meta">@Report(type=2, level=&quot;warning&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="inherited">@Inherited<a class="header-anchor" href="#inherited">⁍</a></h4><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用的时候，如果一个类用到了<code>@Report</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Report(type=1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>则它的子类默认也定义了该注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何定义annotation">如何定义Annotation<a class="header-anchor" href="#如何定义annotation">⁍</a></h3><p>我们总结一下定义<code>Annotation</code>的步骤：</p><p>第一步，用<code>@interface</code>定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function">String <span class="hljs-title">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;info&quot;</span>;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p><h2 id="处理注解">处理注解<a class="header-anchor" href="#处理注解">⁍</a></h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102026065728">处理注解 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>可以在运行期通过反射读取<code>RUNTIME</code>类型的注解，注意千万不要漏写<code>@Retention(RetentionPolicy.RUNTIME)</code>，否则运行期无法读取到该注解。</p><p>可以通过程序处理注解来实现相应的功能：</p><ul><li>对JavaBean的属性值按规则进行检查；</li><li>JUnit会自动运行<code>@Test</code>标记的测试方法。</li></ul><p><code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Range &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 255</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：（写在主函数里的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(Person person)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;<br>    <span class="hljs-comment">// 遍历所有Field:</span><br>    <span class="hljs-keyword">for</span> (Field field : person.getClass().getFields()) &#123;<br>        <span class="hljs-comment">// 获取Field定义的@Range:</span><br>        Range range = field.getAnnotation(Range.class);<br>        <span class="hljs-comment">// 如果@Range存在:</span><br>        <span class="hljs-keyword">if</span> (range != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 获取Field的值:</span><br>            Object value = field.get(person);<br>            <span class="hljs-comment">// 如果值是String:</span><br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>                String s = (String) value;<span class="hljs-comment">//x</span><br>                <span class="hljs-comment">// 判断值是否满足@Range的min/max:</span><br>                <span class="hljs-keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Invalid field: &quot;</span> + field.getName());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（五）| 反射</title>
      <link href="/augu1sto/6d0330a1471e/"/>
      <url>/augu1sto/6d0330a1471e/</url>
      
        <content type="html"><![CDATA[<p>Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><p><a href="https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/">Spring 中的反射与反射的原理 | Depp Wang’s Blog</a></p><h2 id="class类">Class类<a class="header-anchor" href="#class类">⁍</a></h2><p><code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p><p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。</p><p>注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Class</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例。</p><p>JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为<mark>反射（Reflection）</mark>。</p><h3 id="获取class实例三个方法">获取Class实例三个方法<a class="header-anchor" href="#获取class实例三个方法">⁍</a></h3><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls = String.class;<br></code></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;Hello&quot;</span>;<br>Class cls = s.getClass();<br></code></pre></td></tr></table></figure><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br></code></pre></td></tr></table></figure><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例-</p><blockquote><ul><li><p><code>Class</code>实例比较和<code>instanceof</code>的差别：</p><p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p></li></ul></blockquote><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printClassInfo</span><span class="hljs-params">(Class cls)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Class name: &quot;</span> + cls.getName());<br>    System.out.println(<span class="hljs-string">&quot;Simple name: &quot;</span> + cls.getSimpleName());<br>    <span class="hljs-keyword">if</span> (cls.getPackage() != <span class="hljs-keyword">null</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Package name: &quot;</span> + cls.getPackage().getName());<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;is interface: &quot;</span> + cls.isInterface());<br>    System.out.println(<span class="hljs-string">&quot;is enum: &quot;</span> + cls.isEnum());<br>    System.out.println(<span class="hljs-string">&quot;is array: &quot;</span> + cls.isArray());<br>    System.out.println(<span class="hljs-string">&quot;is primitive: &quot;</span> + cls.isPrimitive());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态加载">动态加载<a class="header-anchor" href="#动态加载">⁍</a></h3><p>JVM在执行Java程序的时候，第一次需要用到class时才加载到内存。</p><h2 id="访问字段">访问字段<a class="header-anchor" href="#访问字段">⁍</a></h2><p><mark>import java.lang.reflect.Field;</mark></p><p><code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个public的field（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个field（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有public的field（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有field（不包括父类）</li></ul><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h3 id="获取字段值">获取字段值<a class="header-anchor" href="#获取字段值">⁍</a></h3><p><code>Field.get(实例名)</code>：返回实例的值</p><p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p><p>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</p><h3 id="设置字段值">设置字段值<a class="header-anchor" href="#设置字段值">⁍</a></h3><p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的</p><ul><li>第一个<code>Object</code>参数是指定的实例，</li><li>第二个<code>Object</code>参数是待修改的值。</li></ul><p>必须捕捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>fname = c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>e.printStackTrace();<br>&#125;<br>fname.setAccessible(<span class="hljs-keyword">true</span>);<br><br><span class="hljs-keyword">try</span> &#123;<br>fname.set(p,<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="调用方法">调用方法<a class="header-anchor" href="#调用方法">⁍</a></h2><p><mark>import java.lang.reflect.Method;</mark></p><p><code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h3 id="调用方法-2">调用方法<a class="header-anchor" href="#调用方法-2">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// String对象:</span><br>        String s = <span class="hljs-string">&quot;Hello world&quot;</span>;<br>        <span class="hljs-comment">// 获取String substring(int)方法，参数为int:</span><br>        Method m = String.class.getMethod(<span class="hljs-string">&quot;substring&quot;</span>, <span class="hljs-keyword">int</span>.class);<br>        <span class="hljs-comment">// 在s对象上调用该方法并获取结果:</span><br>        String r = (String) m.invoke(s, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 打印调用结果:</span><br>        System.out.println(r);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h3 id="调用静态方法">调用静态方法<a class="header-anchor" href="#调用静态方法">⁍</a></h3><p>调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。</p><h3 id="调用非public方法">调用非public方法<a class="header-anchor" href="#调用非public方法">⁍</a></h3><p>通过<code>Method.setAccessible(true)</code>允许其调用</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h3 id="多态">多态<a class="header-anchor" href="#多态">⁍</a></h3><p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。</p><h2 id="调用构造方法">调用构造方法<a class="header-anchor" href="#调用构造方法">⁍</a></h2><p><mark>import java.lang.reflect.Constructor;</mark></p><p>Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例。</p><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>；</p><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取构造方法Integer(int):</span><br>        Constructor cons1 = Integer.class.getConstructor(<span class="hljs-keyword">int</span>.class);<br>        <span class="hljs-comment">// 调用构造方法:</span><br>        Integer n1 = (Integer) cons1.newInstance(<span class="hljs-number">123</span>);<br>        System.out.println(n1);<br><br>        <span class="hljs-comment">// 获取构造方法Integer(String)</span><br>        Constructor cons2 = Integer.class.getConstructor(String.class);<br>        Integer n2 = (Integer) cons2.newInstance(<span class="hljs-string">&quot;456&quot;</span>);<br>        System.out.println(n2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="获取继承关系">获取继承关系<a class="header-anchor" href="#获取继承关系">⁍</a></h2><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h2 id="动态代理">动态代理<a class="header-anchor" href="#动态代理">⁍</a></h2><p>Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p><blockquote><h3 id="静态创建interface举例">静态创建interface举例<a class="header-anchor" href="#静态创建interface举例">⁍</a></h3><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">morning</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morning</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Good morning, &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Hello hello = <span class="hljs-keyword">new</span> HelloWorld();<br>hello.morning(<span class="hljs-string">&quot;Bob&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><h3 id="动态创建interface">动态创建interface<a class="header-anchor" href="#动态创建interface">⁍</a></h3><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li><p>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</p></li><li><p>通过<code> Proxy.newProxyInstance()</code> 创建<code>java interface</code> 实例，它需要3个参数：</p><ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li><p>将返回的<code>Object</code>强制转型为接口。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//step1</span><br>        InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                System.out.println(method);<br>                <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;morning&quot;</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Good morning, &quot;</span> + args[<span class="hljs-number">0</span>]);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//step2&amp;3</span><br>        Hello hello = (Hello) Proxy.newProxyInstance(<br>            Hello.class.getClassLoader(), <span class="hljs-comment">// 传入ClassLoader</span><br>            <span class="hljs-keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="hljs-comment">// 传入要实现的接口</span><br>            handler); <span class="hljs-comment">// 传入处理调用方法的InvocationHandler</span><br>        hello.morning(<span class="hljs-string">&quot;Bob&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">morning</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|链表</title>
      <link href="/augu1sto/ca5d5f76ba80/"/>
      <url>/augu1sto/ca5d5f76ba80/</url>
      
        <content type="html"><![CDATA[<h2 id="豆知识">豆知识<a class="header-anchor" href="#豆知识">⁍</a></h2><h3 id="伪头！！">伪头！！<a class="header-anchor" href="#伪头！！">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode phead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>, head);<br></code></pre></td></tr></table></figure><h3 id="java链表基本结构">java链表基本结构<a class="header-anchor" href="#java链表基本结构">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-comment">//类名 ：Java类就是一种自定义的数据结构</span><br>    <span class="hljs-keyword">int</span> val;            <span class="hljs-comment">//数据 ：节点数据 </span><br>    ListNode next;      <span class="hljs-comment">//对象 ：引用下一个节点对象。在Java中没有指针的概念，Java中的引用和C语言的指针类似</span><br>    <br>    ListNode(<span class="hljs-keyword">int</span> val)&#123;  <span class="hljs-comment">//构造方法 ：构造方法和类名相同   </span><br>        <span class="hljs-keyword">this</span>.val=val;     <span class="hljs-comment">//把接收的参数赋值给当前类的val变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>范型写法：使用范型可以兼容不同的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;                <span class="hljs-comment">//类名 ：Java类就是一种自定义的数据结构</span><br>    E val;                        <span class="hljs-comment">//数据 ：节点数据 </span><br>    ListNode&lt;E&gt; next;             <span class="hljs-comment">//对象 ：引用下一个节点对象。在Java中没有指针的概念，Java中的引用和C语言的指针类似</span><br>    <br>    ListNode(E val)&#123;              <span class="hljs-comment">//构造方法 ：构造方法和类名相同   </span><br>        <span class="hljs-keyword">this</span>.val=val;             <span class="hljs-comment">//把接收的参数赋值给当前类的val变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>leetcode203中的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Definition for singly-linked list.</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-keyword">int</span> val) &#123; <br>        <span class="hljs-keyword">this</span>.val = val; <br>    &#125;<br>    ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <br>        <span class="hljs-keyword">this</span>.val = val; <br>        <span class="hljs-keyword">this</span>.next = next; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双链表">双链表<a class="header-anchor" href="#双链表">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> val;<br>  ListNode next;<br>  ListNode prev;<br>  ListNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="回收删除">回收删除<a class="header-anchor" href="#回收删除">⁍</a></h3><p>在对节点进行替换或删除的时候，被替换或被删节点的next引用需不需要设置为null？</p><p>答案是： <strong>不需要</strong>，因为一个对象被回收的前提是因为没有任何地方持有这个对象的引用（引用计数器为0）也就是说它不在被引用，那么那么它将被回收，至于它引用什么对象无关紧要，因为对于它所引用的对象来说依然是看引用计数器是否为0；<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h3 id="链表的递归遍历">链表的递归遍历<a class="header-anchor" href="#链表的递归遍历">⁍</a></h3><p><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5dt66m/">剑指 offer 06. 从尾到头打印链表</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;<br>        recur(head);<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[tmp.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++)<br>            res[i] = tmp.get(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        recur(head.next);<br>        tmp.add(head.val);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>这题可以直接用循环+栈做，本质一样</p></blockquote><h2 id="基础操作：203-移除链表元素">基础操作：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/description/">203. 移除链表元素</a><a class="header-anchor" href="#基础操作：203-移除链表元素">⁍</a></h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><blockquote><p>思路：设置虚拟节点dummyNode</p></blockquote><p>由于链表的头节点<code>head</code> 有可能需要被删除，因此创建哑节点<code>dummyNode</code>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>, head);<br>    ListNode pre = dummyNode;<br>    ListNode cur = head;<br><br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//终止条件</span><br>      <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>        pre.next = cur.next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        pre = cur;<br>      &#125;<br>      cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基础操作：707-设计链表">基础操作：707.<a href="https://leetcode-cn.com/problems/design-linked-list/description/">设计链表</a><a class="header-anchor" href="#基础操作：707-设计链表">⁍</a></h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回<code>-1</code>。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code> 的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果<code>index</code>小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">MyLinkedList linkedList = <span class="hljs-keyword">new</span> MyLinkedList();<br>linkedList.addAtHead(<span class="hljs-number">1</span>);<br>linkedList.addAtTail(<span class="hljs-number">3</span>);<br>linkedList.addAtIndex(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);   <span class="hljs-comment">//链表变为1-&gt; 2-&gt; 3</span><br>linkedList.get(<span class="hljs-number">1</span>);            <span class="hljs-comment">//返回2</span><br>linkedList.deleteAtIndex(<span class="hljs-number">1</span>);  <span class="hljs-comment">//现在链表是1-&gt; 3</span><br>linkedList.get(<span class="hljs-number">1</span>);            <span class="hljs-comment">//返回3</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><ul><li><p>哨兵节点：</p><p>哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。</p><p>我们将使用伪头来简化我们简化插入和删除。在接下来的两种方法中应用此方法。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203110004373.jpeg" alt="在这里插入图片描述"></p></li><li><p>双链表的双向搜索：我们可以从头部或尾部进行搜索。</p></li></ul><blockquote><p><strong>单链表</strong></p></blockquote><p>有关ListNode的定义见<a href="%22#%E8%B1%86%E7%9F%A5%E8%AF%86%22">leetcode203中的定义</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> ListNode phead; <span class="hljs-comment">//伪头节点</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>.phead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    ListNode cur = <span class="hljs-keyword">this</span>.phead;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= index; i++) &#123;<br>      cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cur.val;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// ListNode newHead = new ListNode(val, this.phead.next);</span><br>    <span class="hljs-comment">// this.phead.next = newHead;</span><br>    <span class="hljs-comment">// this.size++;</span><br>    addAtIndex(<span class="hljs-number">0</span>, val);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode tmp = <span class="hljs-keyword">this</span>.phead;<br>    <span class="hljs-keyword">while</span> (tmp.next != <span class="hljs-keyword">null</span>) &#123;<br>      tmp = tmp.next;<br>    &#125;<br>    tmp.next = <span class="hljs-keyword">new</span> ListNode(val);<br>    <span class="hljs-keyword">this</span>.size++;<br>    <span class="hljs-comment">// addAtIndex(this.size, val);</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-keyword">this</span>.size) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// [so weird] If index is negative,</span><br>    <span class="hljs-comment">// the node will be inserted at the head of the list.</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">this</span>.size++;<br><br>    ListNode pre = phead;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>      pre = pre.next;<br>    &#125;<br>    ListNode newNode = <span class="hljs-keyword">new</span> ListNode(val, pre.next);<br>    pre.next = newNode;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">this</span>.size--;<br><br>    ListNode pre = phead;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>      pre = pre.next;<br>    &#125;<br>    pre.next = pre.next.next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>双链表</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> val;<br>  ListNode next;<br>  ListNode prev;<br>  ListNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> size;<br>  <span class="hljs-comment">// sentinel nodes as pseudo-head and pseudo-tail</span><br>  ListNode head, tail;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>    size = <span class="hljs-number">0</span>;<br>    head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    tail = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    head.next = tail;<br>    tail.prev = head;<br>  &#125;<br><br>  <span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// if index is invalid</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// choose the fastest way: to move from the head</span><br>    <span class="hljs-comment">// or to move from the tail</span><br>    ListNode curr = head;<br>    <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; size - index)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index + <span class="hljs-number">1</span>; ++i) curr = curr.next;<br>    <span class="hljs-keyword">else</span> &#123;<br>      curr = tail;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - index; ++i) curr = curr.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> curr.val;<br>  &#125;<br><br>  <span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode pred = head, succ = head.next;<br><br>    ++size;<br>    ListNode toAdd = <span class="hljs-keyword">new</span> ListNode(val);<br>    toAdd.prev = pred;<br>    toAdd.next = succ;<br>    pred.next = toAdd;<br>    succ.prev = toAdd;<br>  &#125;<br><br>  <span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode succ = tail, pred = tail.prev;<br><br>    ++size;<br>    ListNode toAdd = <span class="hljs-keyword">new</span> ListNode(val);<br>    toAdd.prev = pred;<br>    toAdd.next = succ;<br>    pred.next = toAdd;<br>    succ.prev = toAdd;<br>  &#125;<br><br>  <span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// If index is greater than the length, </span><br>    <span class="hljs-comment">// the node will not be inserted.</span><br>    <span class="hljs-keyword">if</span> (index &gt; size) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// [so weird] If index is negative, </span><br>    <span class="hljs-comment">// the node will be inserted at the head of the list.</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// find predecessor and successor of the node to be added</span><br>    ListNode pred, succ;<br>    <span class="hljs-keyword">if</span> (index &lt; size - index) &#123;<br>      pred = head;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; ++i) pred = pred.next;<br>      succ = pred.next;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      succ = tail;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - index; ++i) succ = succ.prev;<br>      pred = succ.prev;<br>    &#125;<br><br>    <span class="hljs-comment">// insertion itself</span><br>    ++size;<br>    ListNode toAdd = <span class="hljs-keyword">new</span> ListNode(val);<br>    toAdd.prev = pred;<br>    toAdd.next = succ;<br>    pred.next = toAdd;<br>    succ.prev = toAdd;<br>  &#125;<br><br>  <span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// if the index is invalid, do nothing</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// find predecessor and successor of the node to be deleted</span><br>    ListNode pred, succ;<br>    <span class="hljs-keyword">if</span> (index &lt; size - index) &#123;<br>      pred = head;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; ++i) pred = pred.next;<br>      succ = pred.next.next;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      succ = tail;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - index - <span class="hljs-number">1</span>; ++i) succ = succ.prev;<br>      pred = succ.prev.prev;<br>    &#125;<br><br>    <span class="hljs-comment">// delete pred.next </span><br>    --size;<br>    pred.next = succ;<br>    succ.prev = pred;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="https://leetcode-cn.com/problems/add-two-numbers/description/">2. 两数相加</a><a class="header-anchor" href="#2-两数相加">⁍</a></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203110005706.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路/试错</strong></p></blockquote><p>一开始用int sum来存储数据，通过<code>sum+=val*i;i*=10</code>类似的方法来更新sum；然后再通过不断<code>%10</code>来把每一位加入链表</p><p>这样会有问题，当数据太大的时候，因为int类型长度有限，会发生溢出</p><p>Testcase</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[9]<br>[1,9,9,9,9,9,9,9,9,9]<br></code></pre></td></tr></table></figure><p>Answer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[8,0,4,5,6,0,0,1,4,1]<br></code></pre></td></tr></table></figure><p>Expected Answer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[0,0,0,0,0,0,0,0,0,0,1]<br></code></pre></td></tr></table></figure><p>而且要多写一次循环=。=</p><p>在加的过程中就建链表</p><p><mark>注意最后的进位要处理</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>    <span class="hljs-comment">//新链表</span><br>    ListNode newPHead = <span class="hljs-keyword">new</span> ListNode();<br>    ListNode pre = newPHead;<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; <span class="hljs-comment">//记进位</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//和</span><br><br><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">int</span> n1 = l1 != <span class="hljs-keyword">null</span> ? l1.val : <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">int</span> n2 = l2 != <span class="hljs-keyword">null</span> ? l2.val : <span class="hljs-number">0</span>;<br><br>      sum = n1 + n2 + c; <span class="hljs-comment">//加进位</span><br>      <span class="hljs-keyword">if</span> (sum &gt;= <span class="hljs-number">10</span>) &#123;<br>        c = <span class="hljs-number">1</span>; <span class="hljs-comment">//设进位是1</span><br>        sum %= <span class="hljs-number">10</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        c = <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-comment">//添加新节点</span><br>      ListNode newNode = <span class="hljs-keyword">new</span> ListNode(sum);<br>      pre.next = newNode;<br>      pre = newNode;<br>      <span class="hljs-comment">//后移两个节点</span><br>      <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>        l1 = l1.next;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>        l2 = l2.next;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//处理最后的进位</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>) &#123;<br>      ListNode newNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>      pre.next = newNode;<br>      pre = newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newPHead.next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-n-个结点"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a><a class="header-anchor" href="#19-删除链表的倒数第-n-个结点">⁍</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><blockquote><p><strong>思路：</strong> 快慢指针</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    ListNode phead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>, head); <span class="hljs-comment">//伪头</span><br>    ListNode slow = phead;<br>    ListNode fast = phead;<br>    <span class="hljs-comment">//移动fast节点，让它领先slow，因为1 &lt;= n &lt;= sz，所以不必考虑非法错误</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      fast = fast.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;<br>      fast = fast.next;<br>      slow = slow.next;<br>    &#125;<br>    slow.next = slow.next.next;<br>    <span class="hljs-keyword">return</span> phead.next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-合并k个升序链表"><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/description/">23. 合并K个升序链表</a><a class="header-anchor" href="#23-合并k个升序链表">⁍</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><blockquote><p><strong>思路一：</strong> 在<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">21.合并两个有序链表</a>的基础上改进，两两合并</p></blockquote><p>可以依次遍历，但更好的方法是 分治（类二分法）</p><ul><li>按[left,mid]，[mid+1,right]进行划分</li><li>left==right时，返回list[left]</li><li>left&gt;right时，返回null，递归终止</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-comment">//分治法，</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>      <span class="hljs-keyword">int</span> mid = (r + l) &gt;&gt; <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == r) &#123;<br>      <span class="hljs-keyword">return</span> lists[l];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;<br>    <span class="hljs-comment">//注意两个链表的节点数目范围从0开始</span><br><br>    ListNode pnewList = <span class="hljs-keyword">new</span> ListNode();<br>    ListNode cur = pnewList;<br>    <span class="hljs-keyword">while</span> (list1 != <span class="hljs-keyword">null</span> &amp;&amp; list2 != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">int</span> n1 = list1.val;<br>      <span class="hljs-keyword">int</span> n2 = list2.val;<br>      <span class="hljs-keyword">if</span> (n1 &lt; n2) &#123;<br>        cur.next = list1;<br>        list1 = list1.next; <span class="hljs-comment">//向后挪</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        cur.next = list2;<br>        list2 = list2.next;<br>      &#125;<br><br>      cur = cur.next;<br>    &#125;<br>    cur.next = list1 == <span class="hljs-keyword">null</span> ? list2 : list1;<br><br>    <span class="hljs-keyword">return</span> pnewList.next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <strong>思路二：使用优先队列合并</strong></li></ul><p>即每个链表没有被合并的元素的最前面一个，每次在这些元素里面选取 <code>val</code> 属性最小的元素合并到答案中。</p><p>用优先队列优化 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/">合并K个排序链表 - 合并K个升序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152">使用PriorityQueue - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Status</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        ListNode ptr;<br><br>        Status(<span class="hljs-keyword">int</span> val, ListNode ptr) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.ptr = ptr;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Status status2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.val - status2.val;<br>        &#125;<br>    &#125;<br><br>    PriorityQueue&lt;Status&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;Status&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (ListNode node: lists) &#123;<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> Status(node.val, node));<br>            &#125;<br>        &#125;<br>        ListNode head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode tail = head;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            Status f = queue.poll();<br>            tail.next = f.ptr;<br>            tail = tail.next;<br>            <span class="hljs-keyword">if</span> (f.ptr.next != <span class="hljs-keyword">null</span>) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> Status(f.ptr.next.val, f.ptr.next));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="https://leetcode-cn.com/problems/linked-list-cycle/description/">141. 环形链表</a><a class="header-anchor" href="#141-环形链表">⁍</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><blockquote><p><em>// pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</em></p><p><em>// pos 是给我们自定义测试案例的</em></p><p><strong>思路：</strong> 快慢指针</p></blockquote><p>慢指针步长1，快指针步长2，如果是环形链表，快指针一定能追上慢指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span><br>    <span class="hljs-comment">// pos 是给我们自定义测试案例的</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    ListNode slowp = head; <span class="hljs-comment">//慢指针</span><br>    ListNode fastp = head; <span class="hljs-comment">//快指针</span><br><br>    <span class="hljs-comment">//慢指针步长1，快指针步长2，如果是环形链表，快指针</span><br>    <span class="hljs-keyword">while</span> (fastp != <span class="hljs-keyword">null</span> &amp;&amp; fastp.next != <span class="hljs-keyword">null</span>) &#123;<br>      slowp = slowp.next;<br>      fastp = fastp.next.next;<br>      <span class="hljs-keyword">if</span> (slowp == fastp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表-ii"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a><a class="header-anchor" href="#142-环形链表-ii">⁍</a></h2><p>给定一个链表，<mark>返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code></mark>。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><blockquote><p><strong>思路一：用Set存节点</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>    Set&lt;ListNode&gt; nodes = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!nodes.add(head)) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>      &#125;<br><br>      head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路二：快慢指针</strong></p></blockquote><p>在141的基础上，通过计算来得到相应的节点</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202201052254879.png" alt="fig1"></p><p>慢指针和快指针相遇时：慢指针走了$a+b$，快指针走了$a+n(b+c)+b$，则</p><p>$$2(a+b)=a+n(b+c)+b$$</p><p>即</p><p>$$a=(n-1)(b+c)+c$$</p><p>新设一个指针newp，从head开始和慢指针一起移动，则最后一定会在入口处相遇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    ListNode slowp = head;<br>    ListNode fastp = head;<br>    <span class="hljs-keyword">while</span> (fastp != <span class="hljs-keyword">null</span> &amp;&amp; fastp.next != <span class="hljs-keyword">null</span>) &#123;<br>      slowp = slowp.next;<br>      fastp = fastp.next.next;<br>      <span class="hljs-keyword">if</span> (slowp == fastp) &#123;<br>        ListNode newp = head;<br>        <span class="hljs-keyword">while</span> (slowp != newp) &#123;<br>          slowp = slowp.next;<br>          newp = newp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newp;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>[java ListNode 链表 - 一文搞懂 - 博客园 (<a href="http://cnblogs.com">cnblogs.com</a>)](<a href="https://www.cnblogs.com/easyidea/p/13371863.html#:~:text=%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%80%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%94%B1%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8C%87%E9%92%88%E6%9E%84%E6%88%90%EF%BC%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%82">https://www.cnblogs.com/easyidea/p/13371863.html#:~:text=链表是一种数据结构：由数据和指针构成，链表的指针指向下一个节点。</a> java,ListNode 链表 就是用Java自定义实现的链表结构。) <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（三）| JAVA核心类</title>
      <link href="/augu1sto/a66cd27703a0/"/>
      <url>/augu1sto/a66cd27703a0/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串与编码">字符串与编码<a class="header-anchor" href="#字符串与编码">⁍</a></h2><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。</p><ul><li>不可变：Java字符串的一个重要特点就是字符串<em>不可变</em>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</li></ul><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">String (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><h3 id="字符串比较">字符串比较<a class="header-anchor" href="#字符串比较">⁍</a></h3><p>必须使用<code>equals()</code>方法而不能用<code>==</code>。要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s1.equals(s2)<br></code></pre></td></tr></table></figure><h3 id="搜索-提取子串">搜索/提取子串<a class="header-anchor" href="#搜索-提取子串">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 是否包含子串:</span><br><span class="hljs-string">&quot;Hello&quot;</span>.contains(<span class="hljs-string">&quot;ll&quot;</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-string">&quot;Hello&quot;</span>.indexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-string">&quot;Hello&quot;</span>.lastIndexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-string">&quot;Hello&quot;</span>.startsWith(<span class="hljs-string">&quot;He&quot;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-string">&quot;Hello&quot;</span>.endsWith(<span class="hljs-string">&quot;lo&quot;</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-string">&quot;Hello&quot;</span>.substring(<span class="hljs-number">2</span>); <span class="hljs-comment">// &quot;llo&quot;</span><br><span class="hljs-string">&quot;Hello&quot;</span>.substring(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//&quot;ll&quot;</span><br></code></pre></td></tr></table></figure><h3 id="去除首尾空白字符">去除首尾空白字符<a class="header-anchor" href="#去除首尾空白字符">⁍</a></h3><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>(其代码点小于或等于 <code>'U+0020'</code> （空格字符）的任何字符。)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="hljs-comment">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p><h3 id="判断字符串是否为空-空白">判断字符串是否为空/空白<a class="header-anchor" href="#判断字符串是否为空-空白">⁍</a></h3><ul><li>是否为空：<code>string.isEmpty()</code></li><li>是否为空白：<code>string.isBlank()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;&quot;</span>.isEmpty(); <span class="hljs-comment">// true，因为字符串长度为0</span><br><span class="hljs-string">&quot;  &quot;</span>.isEmpty(); <span class="hljs-comment">// false，因为字符串长度不为0</span><br><span class="hljs-string">&quot;  \n&quot;</span>.isBlank(); <span class="hljs-comment">// true，因为只包含空白字符</span><br><span class="hljs-string">&quot; Hello &quot;</span>.isBlank(); <span class="hljs-comment">// false，因为包含非空白字符</span><br></code></pre></td></tr></table></figure><h3 id="替换子串">替换子串<a class="header-anchor" href="#替换子串">⁍</a></h3><p><code>s.replace(A,B)</code>把所有A换成B</p><ul><li>正则表达式</li></ul><h3 id="分割字符串">分割字符串<a class="header-anchor" href="#分割字符串">⁍</a></h3><p><code>split()</code>方法，并且传入的也是正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">String s = <span class="hljs-string">&quot;A,B,C,D&quot;</span>;<br>String[] ss = s.split(<span class="hljs-string">&quot;\\,&quot;</span>); <span class="hljs-comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="拼接字符串">拼接字符串<a class="header-anchor" href="#拼接字符串">⁍</a></h3><p>静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br>String s = String.join(<span class="hljs-string">&quot;***&quot;</span>, arr); <span class="hljs-comment">// &quot;A***B***C&quot;</span><br></code></pre></td></tr></table></figure><h3 id="格式化字符串">格式化字符串<a class="header-anchor" href="#格式化字符串">⁍</a></h3><p><code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1</span><br>String s = <span class="hljs-string">&quot;Hi %s, your score is %d!&quot;</span>;<br>String news = s.formatted(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">80</span>);<br><span class="hljs-comment">//2</span><br>String news = String.format(<span class="hljs-string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">59.5</span>)<br><br></code></pre></td></tr></table></figure><p>如果不确定用啥占位符，那就始终用<code>%s</code>，因为<code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a>。</p><h3 id="类型转换">类型转换<a class="header-anchor" href="#类型转换">⁍</a></h3><ul><li>转为字符串</li></ul><p>要把<strong>任意</strong>基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String.valueOf(<span class="hljs-number">45.67</span>); <span class="hljs-comment">// &quot;45.67&quot;</span><br>String.valueOf(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// &quot;true&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>转为<code>int</code>：<code>Integer.parseInt(&quot;123&quot;)</code></p></li><li><p>转为<code>boolean</code>：<code>Boolean.parseBoolean(&quot;true&quot;)</code></p></li><li><p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.getInteger(<span class="hljs-string">&quot;java.version&quot;</span>); <span class="hljs-comment">// 版本号，11</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="转换为char">转换为char[]<a class="header-anchor" href="#转换为char">⁍</a></h3><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] cs = <span class="hljs-string">&quot;Hello&quot;</span>.toCharArray(); <span class="hljs-comment">// String -&gt; char[]</span><br>String s = <span class="hljs-keyword">new</span> String(cs); <span class="hljs-comment">// char[] -&gt; String</span><br>String s2 =Arrays.toString(cs) <span class="hljs-comment">// [] -&gt; String 需要import java.util.Arrays;</span><br></code></pre></td></tr></table></figure><p>修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p><p>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] scores;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] scores)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.scores = Arrays.copyOf(scores, scores.length);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//或者Main里面调用的时候</span><br>Score s = <span class="hljs-keyword">new</span> Score(Arrays.copyOf(scores, scores.length));<br></code></pre></td></tr></table></figure><h3 id="字符编码">字符编码<a class="header-anchor" href="#字符编码">⁍</a></h3><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] b1 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(); <span class="hljs-comment">// 按系统默认编码转换，不推荐</span><br><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>); <span class="hljs-comment">// 按UTF-8编码转换，有限考虑</span><br><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 按GBK编码转换</span><br><span class="hljs-keyword">byte</span>[] b3 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8编码转换</span><br></code></pre></td></tr></table></figure><p>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p><p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] b = ...<br>String s1 = <span class="hljs-keyword">new</span> String(b, <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 按GBK转换</span><br>String s2 = <span class="hljs-keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8转换</span><br></code></pre></td></tr></table></figure><p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</p><h2 id="stringbuilder">StringBuilder<a class="header-anchor" href="#stringbuilder">⁍</a></h2><p>可以直接用<code>+</code>拼接字符串。但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p><p>提供了<code>StringBuilder</code>，它是一个<strong>可变对象</strong>，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>    sb.append(i);<br>&#125;<br>String s = sb.toString();<br></code></pre></td></tr></table></figure><blockquote><p>对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p></blockquote><ul><li>方法 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html">StringBuilder (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></li><li><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，现在很少使用。</li><li>用<code>toString()</code>转换成字符串</li></ul><blockquote><h3 id="链式操作">链式操作<a class="header-anchor" href="#链式操作">⁍</a></h3><p>进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Adder adder = <span class="hljs-keyword">new</span> Adder();<br>        adder.add(<span class="hljs-number">3</span>)<br>             .add(<span class="hljs-number">5</span>)<br>             .inc()<br>             .add(<span class="hljs-number">10</span>);<br>        System.out.println(adder.value());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Adder <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        sum += n;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Adder <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>        sum ++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="stringjoiner">StringJoiner<a class="header-anchor" href="#stringjoiner">⁍</a></h2><p><mark>import java.util.StringJoiner;</mark></p><p>用分隔符拼接数组</p><p>可以指定开头结尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> sj = <span class="hljs-keyword">new</span> StringJoiner(<span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;Hello &quot;</span>, <span class="hljs-string">&quot;!&quot;</span>);<br><span class="hljs-keyword">for</span> (String name : names) &#123;<br>    sj.add(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>在不需要指定“开头”和“结尾”的时候，用静态方法<code>String.join()</code>更方便</p><h2 id="数据类型">数据类型<a class="header-anchor" href="#数据类型">⁍</a></h2><p>Java的数据类型分两种：</p><ul><li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li><li>引用类型：所有<code>class</code>和<code>interface</code>类型</li></ul><p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code></p><p>通过包装类，将一个基本类型视为引用类型</p><table><thead><tr><th style="text-align:left">基本类型</th><th style="text-align:left">对应的引用类型</th></tr></thead><tbody><tr><td style="text-align:left">boolean</td><td style="text-align:left">java.lang.Boolean</td></tr><tr><td style="text-align:left">byte</td><td style="text-align:left">java.lang.Byte</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">java.lang.Short</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">java.lang.Integer</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">java.lang.Long</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">java.lang.Float</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">java.lang.Double</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">java.lang.Character</td></tr></tbody></table><h3 id="自动装-拆箱">自动装/拆箱<a class="header-anchor" href="#自动装-拆箱">⁍</a></h3><p>直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，并且，自动拆箱执行时可能会报<code>NullPointerException</code></p><p><code>int</code>和<code>Integer</code>互相转换一般写为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;<br>Integer n = Integer.valueOf(i);<br><span class="hljs-keyword">int</span> x = n.intValue();<br></code></pre></td></tr></table></figure><h3 id="不变类">不变类<a class="header-anchor" href="#不变类">⁍</a></h3><p>引用类型特性：创建即不变，只能用<code>equals()</code>比较</p><blockquote><p>但因为Java标准库的<code>Integer</code>内部有缓存优化，编译器把<code>Integer x = 127;</code>自动变为<code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为<code>true</code>。</p></blockquote><h4 id="创建integer对象">创建<code>Integer</code>对象<a class="header-anchor" href="#创建integer对象">⁍</a></h4><ul><li>方法1：<code>Integer n = new Integer(100);</code></li><li>方法2：<code>Integer n = Integer.valueOf(100);</code>//更好，静态工厂方法，它尽可能地返回缓存的实例以节省内存。把内部优化留给<code>Integer</code>的实现者去做</li></ul><h3 id="进制转换">进制转换<a class="header-anchor" href="#进制转换">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Integer.toString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// &quot;100&quot;,表示为10进制</span><br>        System.out.println(Integer.toString(<span class="hljs-number">100</span>, <span class="hljs-number">36</span>)); <span class="hljs-comment">// &quot;2s&quot;,表示为36进制</span><br>        System.out.println(Integer.toHexString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// &quot;64&quot;,表示为16进制</span><br>        System.out.println(Integer.toOctalString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// &quot;144&quot;,表示为8进制</span><br>        System.out.println(Integer.toBinaryString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// &quot;1100100&quot;,表示为2进制</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出都是<code>String</code></p><h3 id="静态变量">静态变量<a class="header-anchor" href="#静态变量">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span><br>Boolean t = Boolean.TRUE;<br>Boolean f = Boolean.FALSE;<br><span class="hljs-comment">// int可表示的最大/最小值:</span><br><span class="hljs-keyword">int</span> max = Integer.MAX_VALUE; <span class="hljs-comment">// 2147483647</span><br><span class="hljs-keyword">int</span> min = Integer.MIN_VALUE; <span class="hljs-comment">// -2147483648</span><br><span class="hljs-comment">// long类型占用的bit和byte数量:</span><br><span class="hljs-keyword">int</span> sizeOfLong = Long.SIZE; <span class="hljs-comment">// 64 (bits)</span><br><span class="hljs-keyword">int</span> bytesOfLong = Long.BYTES; <span class="hljs-comment">// 8 (bytes)</span><br></code></pre></td></tr></table></figure><h3 id="处理无符号整型">处理无符号整型<a class="header-anchor" href="#处理无符号整型">⁍</a></h3><p><mark>在Java中，并没有无符号整型（Unsigned）的基本数据类型。</mark></p><p>无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如：<code>Byte.toUnsignedInt(-1)</code>//输出255。byte是有符号整型，范围是<code>-128</code>~<code>+127</code>，但如果把<code>byte</code>看作无符号整型，它的范围就是<code>0</code>-<code>255</code>。</p><p>类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code>。</p><h2 id="javabean">JavaBean<a class="header-anchor" href="#javabean">⁍</a></h2><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读方法:</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">getXyz</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 写方法:</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setXyz</span><span class="hljs-params">(Type value)</span></span><br></code></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code></p><p>通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p><ul><li>对应的读方法是<code>String getName()</code></li><li>对应的写方法是<code>setName(String)</code></li></ul><p>只有<code>getter</code>的属性称为只读属性（read-only）</p><p>只有<code>setter</code>的属性称为只写属性（write-only）。</p><ul><li><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</li></ul><blockquote><p>通过IDE，可以快速生成<code>getter</code>和<code>setter</code>。IDEA中右键-生成。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112271824370.png" alt="image-20211227182415203"></p></blockquote><p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p><h3 id="枚举类enum">枚举类enum<a class="header-anchor" href="#枚举类enum">⁍</a></h3><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Weekday</span> </span>&#123;<br>    SUN, MON, TUE, WED, THU, FRI, SAT;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。</li><li>不可能引用到非枚举的值，因为无法通过编译。</li><li>不同类型的枚举不能互相比较或者赋值，因为类型不符。</li><li>是引用类型，但可以用<code>==</code>比较，因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例</li></ul><h3 id="enum类型">enum类型<a class="header-anchor" href="#enum类型">⁍</a></h3><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p><p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><h4 id="实例方法：">实例方法：<a class="header-anchor" href="#实例方法：">⁍</a></h4><ul><li><code>name()</code>：返回常量名</li><li><code>ordinal()</code>：返回定义的常量的顺序，从0开始计数</li><li><code>类.values()</code>：将枚举类转变为一个枚举类型的数组</li></ul><p>可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Weekday</span> </span>&#123;<br>    MON(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;星期一&quot;</span>), TUE(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;星期二&quot;</span>), WED(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;星期三&quot;</span>), THU(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;星期四&quot;</span>), FRI(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;星期五&quot;</span>), SAT(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;星期六&quot;</span>), SUN(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;星期日&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dayValue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String chinese;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Weekday</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dayValue, String chinese)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dayValue = dayValue;<br>        <span class="hljs-keyword">this</span>.chinese = chinese;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.chinese;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>覆写<code>toString()</code>的目的是在输出时更有可读性。</p><p><mark>注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</mark></p><p>枚举类可以应用在<code>switch</code>语句中。</p><h2 id="记录类">记录类<a class="header-anchor" href="#记录类">⁍</a></h2><p>从Java 14开始，引入了新的<code>Record</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>record</code>用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p><h3 id="构造方法">构造方法<a class="header-anchor" href="#构造方法">⁍</a></h3><p>可以编写Compact Constructor对参数进行验证(不写参数)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Point &#123; <span class="hljs-comment">//没有参数</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态方法">静态方法<a class="header-anchor" href="#静态方法">⁍</a></h3><p>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title">of</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title">of</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>JDK15等使用record关键字，需要编译器打开–enable-preview</p><p>IDEA 点击File -&gt; Project Structure -&gt; Project Settings -&gt; Project选项卡，选择Project language level中的15 (Preview)这一项，然后点击OK。</p></blockquote><h2 id="biginteger">BigInteger<a class="header-anchor" href="#biginteger">⁍</a></h2><p><mark>import java.math.BigInteger</mark></p><p><code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数</p><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法</p><p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。（如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。）</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><ul><li>如果<code>BigInteger</code>的值甚至超过了<code>float</code>的最大范围（3.4x1038），那么返回的float是<code>Infinity</code></li></ul><h3 id="常见方法（运算）">常见方法（运算）<a class="header-anchor" href="#常见方法（运算）">⁍</a></h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html">BigInteger (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><p>add, subtract, multiply, divide(<strong><a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html#divideAndRemainder(java.math.BigInteger)">divideAndRemainder</a></strong>(<a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html">BigInteger</a> val),)</p><table><thead><tr><th style="text-align:left">变量和类型</th><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BigInteger</code></td><td style="text-align:left"><code>add(BigInteger val)</code></td><td style="text-align:left">返回一个值为 <code>(this + val)</code>的BigInteger。</td></tr><tr><td style="text-align:left"><code>BigInteger</code></td><td style="text-align:left"><code>subtract(BigInteger val)</code></td><td style="text-align:left">返回值为 <code>(this - val)</code>的BigInteger。</td></tr><tr><td style="text-align:left"><code>BigInteger</code></td><td style="text-align:left"><code>multiply(BigInteger val)</code></td><td style="text-align:left">返回值为 <code>(this * val)</code>的BigInteger。</td></tr><tr><td style="text-align:left"><code>BigInteger</code></td><td style="text-align:left"><code>divide(BigInteger val)</code></td><td style="text-align:left">返回值为 <code>(this / val)</code>的BigInteger。</td></tr><tr><td style="text-align:left"><code>BigInteger[]</code></td><td style="text-align:left"><code>divideAndRemainder(BigInteger val)</code></td><td style="text-align:left">返回两个BigIntegers的数组，其中包含 <code>(this / val)</code>后跟 <code>(this % val)</code> 。</td></tr><tr><td style="text-align:left"><code>BigInteger</code></td><td style="text-align:left"><code>mod(BigInteger m)</code></td><td style="text-align:left">返回一个值为 <code>(this mod m</code>的BigInteger。</td></tr><tr><td style="text-align:left"><code>BigInteger</code></td><td style="text-align:left"><code>pow(int exponent)</code></td><td style="text-align:left">返回值为 <code>(thisexponent)</code>的BigInteger。</td></tr></tbody></table><h2 id="bigdecimal">BigDecimal<a class="header-anchor" href="#bigdecimal">⁍</a></h2><p><mark>import java.math.BigDecimal;</mark></p><p><code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigDecimal.html">BigDecimal (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p><ul><li><p>用<code>scale()</code>表示小数位数，</p></li><li><p><code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code></p></li><li><p>用<code>setScale()</code>方法设置精度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.RoundingMode;<br><span class="hljs-comment">//...</span><br>BigDecimal d2 = d1.setScale(<span class="hljs-number">4</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 四舍五入，123.4568</span><br>BigDecimal d3 = d1.setScale(<span class="hljs-number">4</span>, RoundingMode.DOWN); <span class="hljs-comment">// 直接截断，123.4567</span><br></code></pre></td></tr></table></figure></li><li><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal d3 = d1.divide(d2, <span class="hljs-number">10</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 保留10位小数并四舍五入</span><br>BigDecimal d4 = d1.divide(d2); <span class="hljs-comment">// 报错：ArithmeticException，因为除不尽</span><br></code></pre></td></tr></table></figure></li><li><p>必须使用<code>compareTo()</code>方法来比较大小，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><ul><li><mark>不要使用equals()！</mark>  在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等</li></ul></li></ul><h2 id="常用工具类">常用工具类<a class="header-anchor" href="#常用工具类">⁍</a></h2><h3 id="math">Math<a class="header-anchor" href="#math">⁍</a></h3><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>计算ex次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.exp(<span class="hljs-number">2</span>); <span class="hljs-comment">// 7.389...</span><br></code></pre></td></tr></table></figure><p>计算以e为底的对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.log(<span class="hljs-number">4</span>); <span class="hljs-comment">// 1.386...</span><br></code></pre></td></tr></table></figure><p>计算以10为底的对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.log10(<span class="hljs-number">100</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>三角函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.sin(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 0.00159...</span><br>Math.cos(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// -0.9999...</span><br>Math.tan(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// -0.0015...</span><br>Math.asin(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 1.57079...</span><br>Math.acos(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 0.0</span><br></code></pre></td></tr></table></figure><p>Math还提供了几个数学常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> pi = Math.PI; <span class="hljs-comment">// 3.14159...</span><br><span class="hljs-keyword">double</span> e = Math.E; <span class="hljs-comment">// 2.7182818...</span><br>Math.sin(Math.PI / <span class="hljs-number">6</span>); <span class="hljs-comment">// sin(π/6) = 0.5</span><br></code></pre></td></tr></table></figure><p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.random(); <span class="hljs-comment">// 0.53907... 每次都不一样</span><br></code></pre></td></tr></table></figure><p>生成一个区间在<code>[MIN, MAX)</code>的随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> x = Math.random(); <span class="hljs-comment">// x的范围是[0,1)</span><br><span class="hljs-keyword">double</span> y = x * (max - min) + min; <span class="hljs-comment">// y的范围是[10,50)</span><br></code></pre></td></tr></table></figure><h3 id="random">Random<a class="header-anchor" href="#random">⁍</a></h3><p><mark>import java.util.Random;</mark></p><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Random r = <span class="hljs-keyword">new</span> Random();<br>r.nextInt(); <span class="hljs-comment">// 2071575453,每次都不一样</span><br>r.nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 5,生成一个[0,10)之间的int</span><br>r.nextLong(); <span class="hljs-comment">// 8811649292570369305,每次都不一样</span><br>r.nextFloat(); <span class="hljs-comment">// 0.54335...生成一个[0,1)之间的float</span><br>r.nextDouble(); <span class="hljs-comment">// 0.3716...生成一个[0,1)之间的double</span><br></code></pre></td></tr></table></figure><p>在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列<code>Random r = new Random(12345);</code></p><h3 id="securerandom">SecureRandom<a class="header-anchor" href="#securerandom">⁍</a></h3><p><mark>import java.security.SecureRandom;</mark></p><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SecureRandom sr = new SecureRandom();<br>System.out.println(sr.nextInt(100));<br></code></pre></td></tr></table></figure><p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。JDK的<code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】GIScience21-LSTM-TrajGAN·A Deep Learning Approach to Trajectory Privacy Protection</title>
      <link href="/augu1sto/30e8bf2b6dab/"/>
      <url>/augu1sto/30e8bf2b6dab/</url>
      
        <content type="html"><![CDATA[<h2 id="论文基本信息">论文基本信息<a class="header-anchor" href="#论文基本信息">⁍</a></h2><ul><li>作者：Jinmeng Rao等（威斯康星）</li><li>年份：2021</li><li>会议/期刊：GIScience</li><li>相关下载：<ul><li><a href="https://drops.dagstuhl.de/opus/volltexte/2020/13047/pdf/LIPIcs-GIScience-2021-I-12.pdf">LSTM-TrajGAN: A Deep Learning Approach to Trajectory Privacy Protection (dagstuhl.de)</a></li></ul></li><li>阅读参考：无<ul><li>本人之前课程报告的slides 👉 <a href="https://pan.baidu.com/s/1vwUYn7c9l43Y5nW3MzL0jA">提取码：zrs9</a></li></ul></li><li>开源信息： <a href="https://github.com/GeoDS/LSTM-TrajGAN">github</a> (实验评估只有TUL)</li><li>简介：一种端到端的深度学习方法来生成保护隐私的轨迹数据，同时可以保留语义信息（POI）。主要采用LSTM+GAN网络并设计了一个新的TrajLoss度量函数<ul><li>模型名称：LSTM-TrajGAN</li><li>数据集： NYC Foursquare weekly trajectory dataset（originally come from <a href="https://sites.google.com/site/yangdingqi/home/foursquare-dataset">the Foursquare NYC check-in dataset</a>）</li></ul></li></ul><hr><blockquote><p>是之前做课程报告的时候看的论文，做的笔记可能比较啰嗦。。</p></blockquote><hr><h2 id="abstract">Abstract<a class="header-anchor" href="#abstract">⁍</a></h2><ul><li><p>问题背景：</p><ul><li>基于位置的服务的普及促进了个人水平轨迹数据的爆炸性增长，并引起了公众对隐私问题的关注。</li></ul></li><li><p>方法：</p><ul><li>在这项研究中，我们提出了一种新颖的LSTM-TrajGAN方法，这是一种端到端的深度学习模型，用于生成保存隐私的合成轨迹数据以进行数据共享和发布。</li><li>我们设计了一种损失度量函数TrajLoss来测量轨迹相似性损失，以进行模型训练和优化。</li></ul></li><li><p>实验与评估：</p><ul><li>在真实世界语义轨迹数据集上的轨迹用户链接任务上对模型进行评估。</li><li>与其他常见的地理掩蔽方法相比，我们的模型可以更好地防止用户被重新识别，并且还保留了真实轨迹数据的基本空间，时间和主题特征。</li><li>该模型更好地平衡了轨迹隐私保护的有效性和用于时空分析的实用程序，从而为基于GeoAI的隐私保护提供了新的见解。</li></ul></li></ul><h2 id="1-introduction">1. Introduction<a class="header-anchor" href="#1-introduction">⁍</a></h2><h3 id="问题背景">问题背景<a class="header-anchor" href="#问题背景">⁍</a></h3><h4 id="基于位置服务（lbs-location-based-services）带来的隐私问题">基于位置服务（LBS, Location-Based Services）带来的隐私问题<a class="header-anchor" href="#基于位置服务（lbs-location-based-services）带来的隐私问题">⁍</a></h4><ul><li>越来越多的基于位置的服务（LBS）已通过移动电话，可穿戴式传感器，GPS设备和带有地理标签的社交媒体<strong>生成了大规模的个人级轨迹数据</strong>（即具有属性的位置序列）[19]。</li><li>**作用：**这样的轨迹大数据为研究人类流动模式和人与环境之间的相互作用[11]，灾害应对[12、27]和公共卫生问题[17、25]提供了新的机会。 它还提出了有关保护地缘和更大范围的行为，社会，道德，法律和政策影响的挑战[14]。</li><li><strong>轨迹隐私：</strong> 一般来说，轨迹隐私是指个人的权利，以防止泄露个人轨迹身份和相关的个人敏感位置[15、2、5]。</li></ul><h4 id="问题挑战？">问题挑战？<a class="header-anchor" href="#问题挑战？">⁍</a></h4><p>由于数据泄露问题和公众对位置隐私保护意识的增强，已经提出了许多方法来防止识别用户的轨迹。</p><ol><li><p>从轨迹数据中删除标识符（例如，用户名或ID号）。</p><p>【问题】这种“去识别的de-identified”轨迹仍然可能造成严重的隐私威胁，因为轨迹的空间，时间和主题特征仍然可以用作将轨迹链接到其创建者的强有力的准标识符</p></li><li><p>将轨迹点聚合到地理或行政单位中，这样就不会显示其原始位置。</p><p>【问题】最近的研究表明聚合可能无法保留用户隐私并降低空间分辨率和空间分析的有效性[3，28，5]</p><p>De Montjoye等[3]通过空间和时间聚合降低人类移动性轨迹数据集的分辨率，以防止个人被识别，但是经过粗化的数据集仅提供很少的匿名性。</p></li></ol><p>==&gt;为了更有效地实现轨迹隐私保护,需要更全面地处理轨迹数据的时空特征。</p><h3 id="现有研究">现有研究<a class="header-anchor" href="#现有研究">⁍</a></h3><p>当前的轨迹隐私保护研究主要集中在两个研究领域。</p><ol><li><p>差分隐私(?)</p><p>对来自不同用户的轨迹进行分组和混合，以便将单个轨迹数据的标识转换为k-匿名问题</p><ul><li>空间伪装spatial cloaking方法将 k 用户之间的轨迹点，用 k 匿名隐藏的空间区域混合在一起，使这些轨迹 k 匿名化</li></ul></li><li><p>混合区mix-zone方法使用化名使混合区中的轨迹点匿名化，并打破了通过混合区的同一轨迹的前段和后段之间的联系</p></li><li><p>基于泛化的方法generalization-based approach首先将k个轨迹的点划分为不同的k个匿名区域，然后通过从每个k个匿名区域中均匀选择点并将它们链接在一起来重建k个新轨迹</p></li><li><p>地理掩蔽geomasking</p><p>利用空间维度上的扰动来模糊原始轨迹数据的位置，以便可以隐藏或修改原始位置，而不会严重影响空间模式</p><ul><li>Armstrong等[1]探索了几种类型的地罩的隐私保护能力和空间分析有效性。 关等。</li><li>[15]评估了三种不同的随机扰动地罩对肺癌死亡的空间分析效果。</li><li>Seidl等[26]在GPS轨迹数据上应用了网格掩蔽和随机扰动，并评估了隐私保护性能。</li><li>高等[5]研究了随机扰动，高斯扰动和Twitter数据聚合的有效性，并探讨了每种方法的隐私，分析和不确定性级别。</li></ul></li></ol><p><strong>限制</strong></p><ul><li>**轨迹隐私保护的有效性与时空分析的实用性之间的权衡：**尽管存在多样性，但这些方法的目标主要是混淆轨迹位置并增加更多不确定性（噪声）以保护隐私。但是，轨迹隐私保护的有效性与时空分析的实用性之间的权衡仍然难以控制</li><li>当前的研究主要集中在轨迹数据的空间维度上，而很少考虑其他语义（例如，时间和主题属性）。实际上，这些特性已被证明对于轨迹用户识别至关重要[21]</li><li>自动化：当前的方法严重依赖于手动设计的程序。 一旦公开了该程序，就可能有机会恢复原始轨迹数据[28]（例如，使用逆向工程）。 <strong>“黑匣子”机器学习模型可能有助于解决此问题。</strong></li></ul><blockquote><p>‘黑匣子机器学习模型’？</p></blockquote><h3 id="方法提出">方法提出<a class="header-anchor" href="#方法提出">⁍</a></h3><p>本研究旨在<strong>探索先进的深度学习方法对轨迹隐私保护的有效性</strong>。</p><p>我们提出了一种新颖的LSTM-TrajGAN模型，该模型将长短期记忆（LSTM）递归神经网络和生成对抗网络（GAN）结构结合在一起，以生成保留隐私的合成轨迹，作为真实轨迹的替代方案，用于轨迹数据共享和发布 。</p><h4 id="两个研究问题（rq）">两个研究问题（RQ）<a class="header-anchor" href="#两个研究问题（rq）">⁍</a></h4><p><strong>RQ1:</strong> 提议的LSTM-TrajGAN模型在保护轨迹创建者免于重新识别方面有多有效？ （即，隐私保护有效性）</p><p>**RQ2：**与真实轨迹相比，合成轨迹能否保留语义特征（时空主题特征）？ （即实用性）</p><h3 id="主要贡献">主要贡献<a class="header-anchor" href="#主要贡献">⁍</a></h3><p>（1）我们提出了一种端到端的深度学习方法来生成保护隐私的轨迹数据。 该过程既简单又高度安全（GeoAI“黑匣子”）；</p><p>（2）介绍了一种用于语义轨迹编码的轨迹编码模型。</p><p>（3）我们设计了一个新的TrajLoss度量函数，以测量训练深度学习模型的轨迹相似性损失；</p><p>（4）我们使用真实的LBS数据评估了该模型的隐私保护有效性和实用性，并探讨了两者之间的取舍。</p><h2 id="2-method">2. Method<a class="header-anchor" href="#2-method">⁍</a></h2><p>受TrajGAN [18]的版本的启发，我们提出了一种新的方法，该方法包括三个主要部分：</p><p>（1）轨迹编码模型，该模型编码GPS位置坐标，时间属性以及其他属性，例如兴趣点（POI） 类别;</p><blockquote><p>POI兴趣点（Point Of Interest）是地理信息系统范畴中的一个概念，指可以抽象为点的地理对象，尤其是一些与人们生活密切相关的地理实体，如学校、银行、餐馆、加油站、医院、超市、公交站等。兴趣点的主要用途是对事物或事件的地址进行描述，能在很大程度上增强对事物或事件位置的描述能力和查询能力。</p><p>POI通常包含地理对象的名称，位置，类别等信息，随着大数据时代的来临，POI兴趣点被广泛应用于各行各业，包括科研、教育、交通、能源、互联网、旅游、城市、经济、公共应急管理、园区管理、房产、通讯、土建、规划及其相关行业等等。</p><p>POI的采集是一个非常耗时费力的工作，因此，POI的数量在一定程度代表着其本身的价值。</p><p><a href="http://gaohr.win/site/blogs/2019/2019-12-10-baidu-map-poi-cn.html">http://gaohr.win/site/blogs/2019/2019-12-10-baidu-map-poi-cn.html</a></p></blockquote><p>（2）轨迹生成器，其以随机噪声和原始轨迹为输入，以生成合成轨迹为输出；</p><p>（3）轨迹鉴别器，将轨迹作为输入并将其确定为“真实”或“合成”。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241854770.png" alt="image-20211224185436708"></p><p>总体工作流程如图1所示。目标是<strong>训练一个“智能”轨迹生成器</strong>，该生成器生成“现实”合成轨迹来替换原始轨迹，从而在轨迹分析任务（例如轨迹用户链接（TUL））和轨迹数据挖掘（例如，工作/家庭位置聚类）中保留差异隐私。  同时，它确保了多个时空摘要分析任务的质量。 这样的框架可以充当轨迹数据获取，处理和发布管道中的轨迹隐私保护层，这些渠道发布合成的替代方案，而不是可能公开个人隐私的真实轨迹数据。</p><h3 id="2-1-trajectory-encoding">2.1 Trajectory Encoding<a class="header-anchor" href="#2-1-trajectory-encoding">⁍</a></h3><p>引入一个轨迹编码模型，该模型将原始轨迹数据转换为一种特定的格式，作为LSTM-TrajGAN模型的输入</p><p>进行编码的主要原因是轨迹数据通常包含各种类型的属性，例如间隔数据（例如GPS坐标，日期和时间），标称数据（例如POI类别），序数数据（例如POI等级） ，并且需要将这些数据转换为有效的数字表示形式，以训练深度学习模型。</p><p>包括两个部分：轨迹点编码和轨迹填充</p><h4 id="轨迹点编码trajectory-point-encoding">轨迹点编码Trajectory Point Encoding<a class="header-anchor" href="#轨迹点编码trajectory-point-encoding">⁍</a></h4><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241855714.png" alt="image-20211224185502635"></p><ul><li><p>语义轨迹点包含以下属性：位置，时间，用户ID，轨迹ID和其他可选属性（例如POI类别）。</p></li><li><p>对于location属性，我们使用数据集中所有轨迹的质心标准化所有纬度和经度，以获得纬度和经度与质心的偏差。 这样，模型可以更好地了解不同轨迹点之间的空间偏差模式。（？） 这些偏差值将被用作构建空间嵌入的轨迹点的数字表示</p></li><li><p>对于时间属性和分类属性，我们使用One-Hot编码(单热点编码器)（即在机器学习中使用虚拟变量的表示过程）根据属性的词汇量将属性编码为高维二进制向量。</p><ul><li>“ Day”属性被编码为7维二进制矢量，而“ Monday”则表示为[1、0、0、0、0、0、0]。 同样，“小时”属性被编码为24维二进制矢量，而“类别”属性被编码为10维二进制矢量。</li><li>不对用户ID和轨迹ID进行编码，因为它们仅用于指示该点所属的用户和轨迹。</li></ul></li></ul><h4 id="轨迹填充trajectory-padding">轨迹填充Trajectory Padding<a class="header-anchor" href="#轨迹填充trajectory-padding">⁍</a></h4><p>在轨迹点编码过程之后，轨迹的所有空间，时间和主题属性都存储在多维矩阵中，多维矩阵的第一维表示每个轨迹的索引。</p><p>由于每个轨迹数据的长度（即轨迹点的数量）是变量，因此我们应用轨迹填充技术来确保所有轨迹的长度与最长轨迹的长度相同。</p><p><mark>使用零预填充将空轨迹点（即属性均设置为零的点）填充到每个轨迹，直到所有轨迹达到与数据集中最长轨迹相同的长度为止。</mark></p><p>主要原因是可以将具有相同大小的数据用于批处理和训练深度学习模型，这将加快训练过程。 在模型训练和推理过程中，这些填充的轨迹点将被屏蔽（即剪切），它们实际上不会影响神经网络权重更新和派生的结果。</p><h3 id="2-2-lstm-trajgan-model">2.2 LSTM-TrajGAN Model<a class="header-anchor" href="#2-2-lstm-trajgan-model">⁍</a></h3><p><img src="http://www.jinmengrao.com/trajgan/img/LSTM_TrajGAN.png" alt="img"></p><ul><li><p><strong>Trajectory Generator</strong> 轨迹生成器捕获实际轨迹数据的数据分布和模式，并基于其相应的原始轨迹数据和随机噪声生成合成轨迹数据。</p></li><li><p><strong>Trajectory Discriminator</strong> 轨迹鉴别器区分轨迹样本是来自训练集(即真实轨迹数据)还是来自轨迹生成器(即合成轨迹数据)。</p></li><li><p><strong>Trajectory Generator</strong> 轨迹发生器的目标是生成“高质量”的合成轨迹，以“愚弄”轨迹鉴别器，从而导致两个人之间的极小极大博弈。</p></li><li><p>所生成的综合轨迹旨在能够进行时空概要分析，同时具有一定程度的不确定性和随机性，以保护轨迹分析任务中涉及隐私问题的用户隐私。这一思想反映在 LSTM-TrajGAN 模型的设计和优化。</p></li></ul><h4 id="轨迹生成器trajectory-generator">轨迹生成器Trajectory Generator<a class="header-anchor" href="#轨迹生成器trajectory-generator">⁍</a></h4><p>五层：</p><ol><li><p>input</p><p>编码后的真实轨迹+随机噪声</p></li><li><p>Embedding</p><p>多层感知机MLP</p><ul><li><strong>空间维度</strong>（即成对的经纬度偏差），我们使用 MLP 将它们嵌入到64维向量中</li><li><strong>时间维度</strong>（如，天和小时）和<strong>分类属性</strong>（如，POI 类别）：使用MLP分别嵌入它们，并根据其词汇量获得定长向量</li><li><strong>几个公式</strong></li></ul></li><li><p>Feature Fusion</p><ul><li>嵌入过程之后，我们将所有矢量和随机噪声进一步连接起来，然后使用dense layer密集层将它们融合为100维矢量。</li><li>通过利用特征融合，我们利用了每个轨迹点的所有空间，时间和类别特征，并将它们融合在一起以支持时空轨迹建模和生成</li></ul></li><li><p>LSTM Modeling</p><ul><li><p>多对多LSTM结构（many-to-many LSTM structure）</p><ul><li>该结构将<strong>具有特定时间步长的序列</strong>作为输入，并生成具有与时间步长相同的序列。 事实证明，诸如LSTM的递归模型在时空序列建模和预测中是有效的</li></ul></li><li><p>已知融合特征的维数，我们在LSTM模型中分配100个单元，将融合特征输入到模型中</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241855102.png" alt="image-20211224185526994"></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241855475.png" alt="image-20211224185554422"></p><ul><li>F: 代表轨迹中所有轨迹点的融合特征</li><li>H：LSTM模型的输出，具有与输入相同的时间步长</li><li>W<sub>lstm</sub> ： LSTM模型的权重矩阵</li></ul></li></ul></li><li><p>Regression/Classification</p><ul><li>最后，我们从LSTM建模层的输出H解码合成轨迹数据。 H中的每个特征向量hi是一个100维向量，其中包含合成轨迹点的空间，时间和分类特征。<ul><li>（<strong>空间维度</strong>）为了解码纬度和经度偏差，我们使用具有两个单元的dense layer密集层并使用tanh双曲正切函数。此外，我们进一步扩展了输出范围，以确保其范围涵盖所有可能的偏差值</li><li>（<strong>时间维度/分类属性</strong>）为了解码日期，小时和类别属性，我们使用了与词汇量大小一样多的单元的dense layer密集层，并使用softmax归一化指数函数来恢复这些属性的one-Hot表示：</li><li><strong>几个公式</strong></li></ul></li></ul></li></ol><h4 id="轨迹鉴别器">轨迹鉴别器<a class="header-anchor" href="#轨迹鉴别器">⁍</a></h4><p>轨迹鉴别器的结构与轨迹生成器非常相似。 它们之间的主要区别是：</p><p>（1）鉴别器仅将轨迹数据作为输入（不需要随机噪声）；</p><p>（2）我们使用多对一LSTM模型，该模型以具有时间步长的特征作为输入，并以一个标量作为输出：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241856242.png" alt="image-20211224185608191"></p><ul><li>F: 代表轨迹中所有轨迹点的融合特征</li><li>h：LSTM模型的输出标量</li><li>W<sub>lstmd</sub> ： LSTM模型的权重矩阵</li></ul><p>（3）我们使用具有Sigmoid激活函数的一个单元dense layer密集层在标量输出上进行二分类（真实或合成轨迹）：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241856161.png" alt="image-20211224185624111"></p><ul><li>D<sup>bc</sup>: 用于进行二分类的具有Sigmoid函数的1单元dense layer</li><li>W<sup>bc</sup>: 权重矩阵；</li><li>O<sub>d</sub>: 鉴别器的最终输出。</li></ul><h3 id="2-3-轨迹相似度损失的测量-trajloss-for-measuring-trajectory-similarity-losses">2.3 轨迹相似度损失的测量 TrajLoss for Measuring Trajectory Similarity Losses<a class="header-anchor" href="#2-3-轨迹相似度损失的测量-trajloss-for-measuring-trajectory-similarity-losses">⁍</a></h3><p>最初的GAN旨在优化以下目标函数：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241857935.png" alt="image-20211224185735887"></p><ul><li>p<sub>data</sub>(x): 真实数据样本的分布</li><li>p<sub>z</sub>(z)： 噪声变量的先验</li><li>D(x)：x服从（来自？）p<sub>data</sub>(x)的概率</li><li>G(z)：p<sub>z</sub>(z)到p<sub>data</sub>(x)的映射</li><li>生成器的目标是最小化后面一项；鉴别器的目标是最大化这两项的和；总体来说就是双方minmax的博弈（？）</li></ul><p>根据目标函数O（D，G），鉴别器的损失函数可以视为二进制交叉熵（BCE）损失函数（LBCE），也将用于训练生成器。与原始GAN不同，我们需要真实的轨迹数据作为输入。</p><p>我们设计了一个<strong>新的损耗度量函数TrajLoss</strong>，以进一步测量真实轨迹数据与合成轨迹数据在空间，时间和分类维度上的相似性损耗，并使用该损耗函数来<strong>训练生成器</strong>。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241857660.png" alt="image-20211224185743614"></p><ul><li>yr：真实标签</li><li>yp：鉴别器的预测结果</li><li>tr：真实轨迹</li><li>ts：合成轨迹</li><li>L<sub>BCE</sub>：鉴别器的原始二进制交叉熵损失</li><li>Ls，Lt和Lc分别是真实轨迹和合成轨迹之间的空间相似度损失，时间相似度损失和类别相似度损失；</li><li>α，β，γ和c是这些损失的权重，可以针对不同的情况进行不同的分配。</li></ul><p>在本文中，我们使用L2损失(即最小二乘误差)作为Ls，最近的研究[8]表明L2损耗在测量轨迹空间相似性方面是有效的。</p><p>我们选择Softmax交叉熵(SCE)作为Lt和Lc的损失函数，因为在本框架中它们都被视为多分类问题，因此可以使用SCE进行优化。</p><p>在模型训练过程中，轨迹损失会更新生成器的权值，以提高合成轨迹数据的质量。</p><h2 id="3-experiment">3 Experiment<a class="header-anchor" href="#3-experiment">⁍</a></h2><h3 id="3-1-轨迹用户链接（trajectory-user-linking，tul）"><strong>3.1 轨迹用户链接（Trajectory-User Linking，TUL）</strong><a class="header-anchor" href="#3-1-轨迹用户链接（trajectory-user-linking，tul）">⁍</a></h3><ul><li>针对<strong>RQ1</strong>，评估隐私保护有效性</li></ul><p>它从轨迹中识别用户并将轨迹链接到他们[4]。 在具有地理标签的社交媒体应用中，TUL是一项必不可少的任务，并且受到越来越多的隐私关注[4，30，21]。</p><ul><li>可以将评估视为<strong>对抗性实验</strong>：我们训练LSTM-TrajGAN模型，并使用生成的合成轨迹来抑制最新的TUL算法的准确性。</li><li>与其他两种常用的位置隐私保护方法进行比较：<strong>随机扰动</strong>和<strong>高斯地理掩蔽</strong>。</li></ul><h4 id="dataset">Dataset<a class="header-anchor" href="#dataset">⁍</a></h4><p>NYC Foursquare weekly trajectory dataset</p><ul><li>193 users, 3,079 trajectories and 66,962 trajectory points</li><li>2/3训练，1/3测试</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241858244.png" alt="image-20211224185802193"></p><h4 id="training-and-evaluation">Training and Evaluation<a class="header-anchor" href="#training-and-evaluation">⁍</a></h4><h5 id="轨迹合成">轨迹合成<a class="header-anchor" href="#轨迹合成">⁍</a></h5><p>我们使用几个默认的训练超参数在训练集上训练了2,000个周期的LSTM-TrajGAN模型（例如，我们使用学习率为0.001的adam优化器并将批次大小设置为256）。 在训练过程之后，来自测试集的轨迹数据以及随机噪声随后被用作发生器的输入以获得合成轨迹数据。</p><p><img src="http://www.jinmengrao.com/trajgan/img/TRAJGAN3.png" alt="img"></p><p>图4显示了来自测试数据的真实轨迹及其模型生成的相应合成轨迹的可视化示例。</p><h5 id="使用最先进的tul算法marc（多方面trajectory分类器-21-）对测试数据和合成数据执行tul任务">使用最先进的TUL算法MARC（多方面tRajectory分类器[21]）对测试数据和合成数据执行TUL任务<a class="header-anchor" href="#使用最先进的tul算法marc（多方面trajectory分类器-21-）对测试数据和合成数据执行tul任务">⁍</a></h5><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241858704.png" alt="image-20211224185812642"></p><p>使用五个常用指标评估TUL的准确性：</p><ul><li><p>ACC @ 1（Top-1准确性，表明模型具有将正确标签作为最可能的标签候选者的能力）</p></li><li><p>ACC @ 5（Top- 5精度，显示模型在前5个最可能的标签候选者中具有正确标签的能力，</p></li><li><p>（多分类模型的评价指标）</p><ul><li>Macro-P（所有类别之间的平均精度）</li><li>Macro-R（所有类别之间的平均召回率）</li><li>Macro-F1（Macro-P和Macro-R的谐波均值）。</li></ul></li><li><p>RP：随机扰动</p></li><li><p>Gaussuain：高斯地理掩蔽Geomasking</p></li></ul><p>结果（TUL精度越高，轨迹隐私保护的能力越差）</p><ul><li>由LSTM-TrajGAN生成的综合数据成功地将四个指标（ACC @ 1，Macro-P，Macro-R和Macro-F）中的得分从0.900抑制到0.400左右。</li><li>结果表明，我们的模型可以通过分析轨迹有效地防止用户被识别。 此外，随机扰动在保护有关TUL任务的轨迹隐私方面的效果有限，并且高斯地理遮罩的效果更好，但得分仍高于我们的模型。</li><li>结果还表明，与仅使用空间维相比，同时利用轨迹的空间和时间维可同时带来更好的隐私保护性能。</li></ul><h3 id="3-2-合成轨迹特征分析synthetic-trajectory-characteristics-analysis">3.2 合成轨迹特征分析Synthetic Trajectory Characteristics Analysis<a class="header-anchor" href="#3-2-合成轨迹特征分析synthetic-trajectory-characteristics-analysis">⁍</a></h3><ul><li>针对<strong>RQ2</strong>，评估合成的轨迹的可用性</li></ul><h4 id="空间特征spatial-characteristics">空间特征Spatial Characteristics<a class="header-anchor" href="#空间特征spatial-characteristics">⁍</a></h4><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241858899.png" alt="image-20211224185829840"></p><p>基于两个度量标准探索空间特征：Hausdorff距离和Jaccard指数。</p><ul><li>Hausdorff距离是用于度量公制空间中两个点集之间距离的度量，已被广泛用于度量两个轨迹之间的<strong>空间差异</strong>。</li><li>杰卡德系数（Jaccard Index），也称为联合相交，是一种有效的度量，用于测量两个样本集或区域重叠的程度，我们用它来指示两个轨迹之间活动空间的<strong>相似性</strong>[18]。</li></ul><p>我们计算每对原始轨迹和合成轨迹之间的Hausdorff距离。 同样，由于凸包通常可以代表LBS用户的活动空间，因此我们还计算了它们的凸包之间的Jaccard索引[16]。 表3汇总了这些指标。</p><p><strong>【结论】</strong></p><p>它表明<strong>随机扰动</strong>具有最小的平均Hausdorff距离（0.004）和最大的平均Jaccard指数（0.763），这是有道理的，因为它仅对轨迹的空间维度产生有限的影响。 尽管这种方法可以很好地保留空间相似性，但是却牺牲了位置保密性。</p><p>我们的模型在这两个指标上的表现<strong>优于高斯地理掩蔽</strong>，并且还更好地抑制了上述TUL指标，从而在空间相似性和位置隐私之间取得了更好的平衡。</p><h4 id="时序特征temporal-characteristics">时序特征Temporal Characteristics<a class="header-anchor" href="#时序特征temporal-characteristics">⁍</a></h4><p>我们还探讨了时间特征的基础上可视化的两个概要指标: 时间访问概率分布为每个 POI 类别，和 总体时间访问频率分布。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241858610.png" alt="image-20211224185846538"></p><p>我们计算原始轨迹中<strong>每小时每个 POI 类别的访问次数</strong>，并使用3种不同的方法计算合成轨迹，然后将它们转换成概率分布矩阵(图5) ，在其中可以分析和比较时间模式和时间相似性。</p><p><strong>【结论】</strong></p><p>结果表明，LSTM-TrajGAN的时间访问概率分布与原始数据具有很大的共性，体现出明显的时间相似性。</p><p>LSTM-TrajGAN的结果的某些部分（即类别C和E）具有接近零的访问概率，因为这些类别很少出现在训练数据中，因此模型无法学习到足够的信息来对其进行智能预测。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241859123.png" alt="image-20211224185905063"></p><p>此外，我们调查了总体时间和分类访问频率分布（图6a和图6b）。 与随机扰动（0.536）和高斯地质掩蔽（0.535）相比，我们模型的总体时间访问频率分布可以更好地拟合原始数据（皮尔逊系数：0.761）。 总体分类访问频率分布也很合适（0.889）。</p><p><strong>【结论】</strong></p><p>因此，我们得出结论，我们的模型通常很好地保留了时间和类别特征。</p><h2 id="discussion">Discussion<a class="header-anchor" href="#discussion">⁍</a></h2><p>本节讨论可能影响LSTM-TrajGAN模型的隐私保护有效性的因素，以及隐私保护有效性与实用程序之间的权衡。 最后，我们讨论了该方法的局限性。</p><h3 id="4-1-factors-aﬀecting-privacy-protection-eﬀectiveness">4.1 Factors Aﬀecting Privacy Protection Eﬀectiveness<a class="header-anchor" href="#4-1-factors-aﬀecting-privacy-protection-eﬀectiveness">⁍</a></h3><ul><li>训练和最优化的设置（参数）</li><li>空间嵌入方法<ul><li>MLP：嵌入每个人的位置以获得固定长度的向量，并将该向量用作LSTM模型的输入以生成人类轨迹。</li><li>Geohash：首先使用Geohash算法将区域划分为网格单元，然后将纬度和经度编码为字符串，最后将字符串转换为二进制固定长度向量作为字符串。 每个轨迹点的空间尺寸的表示形式。</li><li>本文中的MLP：从所有轨迹位置的质心得出纬度和经度的偏差，而不是直接嵌入坐标，然后使用MLP将这些偏差嵌入到64维向量中。<ul><li>目标是生成合成轨迹，这意味着我们需要从模型中的隐藏特征中解码出坐标，因此 使用二进制Geohash可能导致学习坐标的有效表示，设计适当的空间损失以及错误的反向传播方面的困难</li><li>与[8]中的笛卡尔坐标系所描述的受限预测区域不同，我们任务中的预测区域位于城市规模上，并且两个GPS坐标之间的差异仅在小数点后出现 。 对于模型来说，仅需细微的变化就可以学习和预测坐标，这将是一个巨大的挑战。 因此，我们对坐标进行了<strong>标准化</strong>，以使两个位置之间的差异对于模型的学习更为重要。</li></ul></li><li>空间嵌入维度对TULtask中的指标的影响（较高维的较好：表4）<ul><li>高维空间中的向量通常能够提取和嵌入更多信息。 但是，由于物理设备的限制，这还涉及在位置精度和计算工作量之间进行权衡。</li></ul></li></ul></li></ul><h3 id="4-2-隐私保护有效性与实用性之间的权衡">4.2 隐私保护有效性与实用性之间的权衡<a class="header-anchor" href="#4-2-隐私保护有效性与实用性之间的权衡">⁍</a></h3><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241859863.png" alt="image-20211224185923801"></p><p>值得注意的是，每种方法的位置都是根据我们的实验估算得出的。 我们认为，考虑这种关系将有助于针对特定情况选择和设计适当的轨迹隐私保护方法。</p><h3 id="4-3-局限性">4.3 局限性<a class="header-anchor" href="#4-3-局限性">⁍</a></h3><ul><li><strong>计算量更大</strong>：首先，与使现有轨迹模糊的传统地理掩蔽技术相比，我们生成新轨迹的深度学习模型导致计算量大得多，并且在部署到应用程序中之前还需要额外的训练过程。</li><li>其次，我们专注于TUL任务并分析了合成轨迹的时空特征，这反映了它们在保护隐私轨迹分析方面的潜力，但尚未研究更具体的评估。</li><li>第三，我们的模型仅生成具有与原始轨迹相同长度的合成轨迹。 最后，我们的模型目前关注的是城市规模的轨迹，基于偏差的位置表示<strong>可能不适用于全球规模的轨迹</strong>。</li></ul><p>这些限制将在我们的未来工作中进一步探讨。</p><h2 id="总结与未来工作">总结与未来工作<a class="header-anchor" href="#总结与未来工作">⁍</a></h2><p>这项研究提出了一种新颖的LSTM-TrajGAN方法，即结合LSTM递归神经网络和GAN结构以生成用于轨迹数据发布的隐私保护合成轨迹的深度学习模型。</p><p>在模型设计中利用对抗训练的思想，在Foursquare NYCweekly轨迹数据集上训练模型，并评估其在TUL任务中的隐私保护有效性。</p><p>关于我们在研究开始时提出的两个研究问题，结果表明（RQ1）我们的模型可以生成时空综合轨迹，从而在一定程度上阻止了轨迹创建者（即用户）的重新识别，并且 （RQ2）保留原始轨迹的某些空间，时间和主题特征。</p><p>此外，结果表明该模型具有支持进一步的空间或时间分析的潜力。 最后，我们探讨了影响隐私保护有效性的因素，并讨论了模型有效性和效用之间的一般取舍。</p><p>新损失函数TrajLoss的设计为推进GeoAI的空间显式人工智能技术的发展提供了新新的见解[13]。</p><p>我们未来的工作将集中在<strong>改进轨迹相似度损失度量</strong>功能，将我们的框架<strong>扩展到全球规模的轨迹数据集</strong>，生成自定义可变长度的合成轨迹数据，探索潜在的隐私攻击和防御策略以及评估隐私保护的有效性和实用性。 我们在其他轨迹数据挖掘和分析任务中的模型。</p>]]></content>
      
      
      <categories>
          
          <category> 轨迹合成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轨迹 </tag>
            
            <tag> 隐私保护 </tag>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【面试-线程相关】i++在两个线程分别执行100次，最大值和最小值分别多少</title>
      <link href="/augu1sto/8cb18cd4baea/"/>
      <url>/augu1sto/8cb18cd4baea/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天看微软空宣里提到的一道面试题，一下子没反应过来。。毕竟操作系统的知识我好像都上交了x要抽时间看看才行。</p></blockquote><h2 id="题目描述">题目描述<a class="header-anchor" href="#题目描述">⁍</a></h2><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112232230601.png" alt="image-20211223223031554"></p><h2 id="原理">原理<a class="header-anchor" href="#原理">⁍</a></h2><p>多个cpu对应多个寄存器。i++并不是原子性的，它的操作分为三步：</p><ul><li>从内存中取数放入寄存器</li><li>执行++运算</li><li>将数写回内存</li></ul><h2 id="过程分析">过程分析<a class="header-anchor" href="#过程分析">⁍</a></h2><p>接下来参考文章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，画图分析一下为2的极端情况</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112232256608.png" alt="image-20211223225605565"></p><h2 id="实操">实操<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><a class="header-anchor" href="#实操">⁍</a></h2><h2 id="相似题">相似题<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup><a class="header-anchor" href="#相似题">⁍</a></h2><p>j=100，两个线程j–-，均执行50次，可能值是多少？<mark>（0-98）</mark></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/will130/article/details/48714343">面试—i<ins>在两个线程分别执行100次，最大值和最小值分别多少_ 爱橙子的OK绷的专栏-CSDN博客_i</ins>在两个线程里分别执行100次</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://blog.csdn.net/qq_41594146/article/details/87433065">两个线程同时对int a=0进行a++一百次最后的结果可能为多少?_beyond丿灬的博客-CSDN博客</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> OS </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读|TrajGen】KDD21&#39;Generating Mobility Trajectories with Retained Data Utility</title>
      <link href="/augu1sto/514bb2d87420/"/>
      <url>/augu1sto/514bb2d87420/</url>
      
        <content type="html"><![CDATA[<h2 id="论文基本信息">论文基本信息<a class="header-anchor" href="#论文基本信息">⁍</a></h2><ul><li>作者：Chu Cao, Mo Li（南洋理工）</li><li>年份：2021</li><li>会议/期刊：KDD</li><li>相关下载：<ul><li><a href="https://dl.acm.org/doi/pdf/10.1145/3447548.3467158">原文PDF (acm.org)</a></li><li><a href="https://dl.acm.org/action/downloadSupplement?doi=10.1145%2F3447548.3467158&amp;file=KDD21-ads2731.mp4">会议视频 Download (acm.org)</a></li></ul></li><li>阅读参考：<ul><li><a href="https://zhuanlan.zhihu.com/p/390626904">阅读小记- Generating Mobility Trajectories with Retained Data Utility - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/388258494">KDD2021论文解读：路段粒度的轨迹生成 - 知乎 (zhihu.com)</a></li></ul></li><li>开源信息： <a href="https://github.com/caochuntu/KDD2021_guizu">github</a> (仓库尚在更新，未完全开源)</li><li>简介：提出了一种新的时空轨迹生成模型，该模型基于 GAN 与 Seq2Seq 来仿照真实轨迹生成相似的轨迹数据。<ul><li>模型名称：TrajGen</li><li>数据集： real-world taxi trajectory data in Singapore.</li></ul></li></ul><hr><h2 id="简介">简介<a class="header-anchor" href="#简介">⁍</a></h2><p>提出了一种新的轨迹生成模型，该模型基于 GAN 与 Seq2Seq 来仿照真实轨迹生成相似的轨迹数据。</p><ul><li>时空信息的解耦与合并<ul><li>空间分布的图像：GAN</li><li>时间信息学习：Seq2Seq</li><li>从GAN生成的图像中提取位置并输入Seq2Seq模型以推断出连接这些位置和轨迹的适当序列轨迹。一个完全连接的ANN将时间戳分配给每个轨迹中的顺序位置。</li></ul></li></ul><h2 id="问题定义">问题定义<a class="header-anchor" href="#问题定义">⁍</a></h2><p>输入：</p><ul><li><p>历史真实轨迹集合 ：</p><p>$${\tau_1,\tau_2,\tau_3,…,\tau_n}$$</p><ul><li>$\tau=(loc_1,loc_2,…)$</li><li>$loc_i=(lat_i,lon_i,t_i)$</li></ul></li><li><p>路网信息，表示路段集合V以及路段间的交点集合E。</p><p>$$G=(V,E)$$</p></li></ul><p>输出：</p><ul><li><p>生成的轨迹集合，其分布与原轨迹集合相似。</p><p>$${\hat\tau_1,\hat\tau_2,\hat\tau_3,…,\hat\tau_m}$$</p></li></ul><p>旅行模式：</p><ul><li><p>旅行模式反映了用户的旅行偏好，是一连串的地理上相邻的边</p><p>$${e_1\rightarrow e_2\rightarrow …\rightarrow e_n}$$</p></li></ul><h2 id="算法框架">算法框架<a class="header-anchor" href="#算法框架">⁍</a></h2><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112240043233.png" alt="image-20211224004336149"></p><p>输入：Mobility Trajectories + Mobility Map</p><p>1）生成空间点，学习空间位置的分布，生成一条轨迹的空间点集合；–&gt;DCGAN[]</p><p>2）赋予空间点顺序。对生成的空间点集合，赋予其顺序关系，使空间点集合转为空间点序列；–&gt; map matching[25],seq2seq[32]</p><p>3）赋予每个空间点相应的时间戳信息。–&gt;ANN</p><h3 id="空间分布学习——生成空间点">空间分布学习——生成空间点<a class="header-anchor" href="#空间分布学习——生成空间点">⁍</a></h3><ul><li><p>2D空间映射为图像（可逆）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112240017437.png" alt=""></p><ul><li><p>将城市整个城市地图$M$进行了网格化（像素化），从而将每个轨迹点映射到了一个网格（像素）中</p><ul><li>城市最小经度 $x_0=\min{longitude_M}$</li><li>城市最小纬度 $y_0 = \min{latitude_M}$</li><li>城市经度跨度 $W = \max{longtitude_M}-x_0$</li><li>城市纬度跨度 $H = \max{latitude_M}-y_0$</li><li>图片像素大小 $\mu$</li></ul></li><li><p>$\tau_i\rightarrow\bar{\tau_i}$:</p><p>$$(lat_i,lon_i,t_i)\rightarrow(\frac{lon_i-x_0}{\mu},\frac{lat_i-y_0}{\mu})$$</p></li><li><p>$\bar{\tau_i}\rightarrow img_i$:坐标像素和周围8个像素都为黑色，其他为白色（时空位置上<strong>都</strong>很接近的块可以<strong>合并</strong>为一个）</p></li></ul></li><li><p>用DCGAN来生成新的图片形式的轨迹，模拟原始轨迹的分布</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112240039640.png" alt="image-20211224003931562"></p></li><li><p>用Harris角落检测器[15]识别生成的图像的角落，并转换为经纬度形式的位置</p></li></ul><h3 id="赋予空间点顺序">赋予空间点顺序<a class="header-anchor" href="#赋予空间点顺序">⁍</a></h3><p>在上一步，该模型生成了一条轨迹对应的、无序的轨迹空间点集合。在本步骤，这些空间点被赋予顺序，使得在此顺序下，空间点序列与真实轨迹序列相近。</p><ul><li>训练模型（seq2seq）： travel pattern</li><li>输入：Mobility Map Embedding</li><li>目标输出：按原始顺序排布的位置路径（Ground Truth）</li></ul><h4 id="数据预处理">数据预处理<a class="header-anchor" href="#数据预处理">⁍</a></h4><p>通过基于距离的路网匹配算法，将轨迹点映射到最近的路段上</p><ul><li><p>如下图(a)，点1-5首先通过路网匹配算法，映射到了i,ii,iii,iv,v五条路段上。</p></li><li><p>路段ID进行排序，得到图(b)的Mobility Map Embedding序列（default序列）</p></li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241606780.png" alt="image-20211224160646681"></p><h4 id="训练">训练<a class="header-anchor" href="#训练">⁍</a></h4><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241105883.png" alt="image-20211224110529810"></p><ul><li><p>每条真实轨迹为Seq2Seq模型提供一个训练样本，即一对源序列和目标序列。</p></li><li><p>Seq2Seq模型将源序列编码为一个向量，并将向量解码为一个目标序列。通过这样一个编码器-解码器结构，Seq2Seq构建了将源序列映射到目标序列的条件概率。</p></li><li><p>利用GRU作为Seq2Seq模型的RNN单元，先用GRU编码器将Mobility Map Embedding序列编码为隐层表征，并用GRU解码器解码，与Ground Truth进行比较，以更新GRU模型参数。此处，各条路段初始状态下被表示为one-hot形式。</p><blockquote><p>一个Seq2Seq模型被训练来学习序列信息。Seq2Seq模型的所有参数都是随机初始化的，并使用Adam优化器进行更新。我们利用GRU作为Seq2Seq模型的RNN单元，因为它比LSTM具有更高的计算效率。在Seq2Seq模型的训练过程中，我们采用了填充技术，以确保所有的输入都是相同的长度，并利用注意力机制使Seq2Seq模型强调重要路段。（Appendix A.2 Implementation）</p></blockquote></li></ul><h4 id="生成">生成<a class="header-anchor" href="#生成">⁍</a></h4><p>给定无序的、生成的空间点集合</p><ul><li>首先经过预处理，得到Mobility Map Embedding序列。</li><li>利用已训练完成的GRU编码器和解码器，推测这些路段的真实顺序。</li><li>得到路段顺序之后，相应地匹配到这些路段上的空间点顺序也可以被得到。</li></ul><h3 id="时序信息学习——推测时间信息">时序信息学习——推测时间信息<a class="header-anchor" href="#时序信息学习——推测时间信息">⁍</a></h3><p>通过上述两步骤，一条生成轨迹可以被表示为空间点序列： ${(lat_1,lon_1),(lat_2,lon_2),…}$</p><p>本步骤对序列中的每个点赋予时间。</p><p>1）推测第一个点的时间 $t_0$。</p><p>这一步通过ANN来实现，其输入特征为轨迹长度，以及轨迹经过的第一条匹配路段，输出为时间$t_0$。由原始真实数据训练得到模型参数。</p><p>2）为任意第i个点赋予时间 $t_i=t_0+i\times\Delta t$</p><blockquote><p>$1/\Delta t$为为真实数据的采样频率 ==&gt; 数据集的采样频率要固定</p><p>time slot $\Delta t = 15s$</p></blockquote><h3 id="结果">结果<a class="header-anchor" href="#结果">⁍</a></h3><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241625280.png" alt="image-20211224162536198"></p><h2 id="实验">实验<a class="header-anchor" href="#实验">⁍</a></h2><ul><li>数据集：新加坡路网以及新加坡出租车轨迹数据执行实验。</li><li>Baseline：<ul><li>1）Random Perturbation（RP），将原始轨迹点替换为其2km范围内的随机任一点；</li><li>2）Gaussian Perturbation（GP），将原始轨迹点替换为高斯分布点；</li><li>3）TrajGen-v。与上述方法相同，但DCGAN和Seq2Seq训练数据来自不同数据源，此处论文作者的意图是验证DCGAN和RNN可以被独立训练；</li><li>Raw Data。提取了原始真实数据的一个子集，该方法的实验效果，表示了模型的效果上限。</li><li>Base Data。原始的真实数据。</li></ul></li></ul><h3 id="空间分布的相似性">空间分布的相似性<a class="header-anchor" href="#空间分布的相似性">⁍</a></h3><ul><li>Cosine相似度：把上图中的、带有轨迹点密度信息的网格矩阵向量化，并计算两向量之间的Cosine值。</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241655428.png" alt="image-20211224165535225"></p><blockquote><p>上图给出了原始数据（base data）与五种方法的轨迹数据空间分布对比，以热力图形式呈现，其中每个网格代表$1km^2$ 的小区域。由于RP和GP这两个baseline被设计得较为糟糕，原始的轨迹点位置信息被完全模糊化，因此效果非常差。</p></blockquote><ul><li><p>为了克服实验的偶然因素，轨迹集合生成、以及空间分布相似度计算过程，被重复执行500次。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241659797.png" alt="image-20211224165943704"></p></li></ul><blockquote><p>上图6给出了五种方法生成轨迹与真实轨迹Cosine值在500次重复实验中的分布情况(CDF:分布函数)。可以看出，即使重复实验多次，TrajGen生成轨迹的Cosine值稳定地大于0.9，效果排第二，仅次于从真实数据中选择子样本。</p></blockquote><h3 id="时序分布相似性">时序分布相似性<a class="header-anchor" href="#时序分布相似性">⁍</a></h3><ul><li><p>计算各种方法与base data的分布之间的Cosine相似性</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241706024.png" alt="image-20211224170623937"></p></li></ul><h3 id="统计特征">统计特征<a class="header-anchor" href="#统计特征">⁍</a></h3><p>举了四种例子证明TrajGen模型可以保留统计特征。</p><ol><li><p>到匹配路段的距离（fig.8）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241727721.png" alt="image-20211224172741628"></p></li><li><p>travel distance(fig.9)</p></li></ol><p>​$$d_{\tau_i}=\sigma_{k=1}<sup>{m-1}{D_{mm}(loc_k</sup>i,loc_{k+1}^i)},  D_{mm}(a,b)表示a,b两点间路段的距离$$</p><p>​<img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241727252.png" alt="image-20211224172759164"></p><ol start="3"><li><p>每个小时的travel覆盖的范围（km<sup>2</sup>）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241728953.png" alt="image-20211224172814857"></p></li><li><p>普通道路和快速道路的比例</p><blockquote><p>Based on the <code>#tag</code> information in OpenStreetMap [26]</p></blockquote><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241728942.png" alt="image-20211224172828850"></p></li></ol><h3 id="实用性">实用性<a class="header-anchor" href="#实用性">⁍</a></h3><h4 id="case-1：路网更新">case 1：路网更新<a class="header-anchor" href="#case-1：路网更新">⁍</a></h4><p>利用生成轨迹进行路网更新，测试生成轨迹是否能帮助发现未收录的路网。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241751680.png" alt="image-20211224175110542"></p><p>如上图所示，灰色路段为原路网，黑色路段是为测试路网更新效果而被删除的路段，红色是被轨迹检测出的路段。可以发现，即使输入路网数据删除了大量路段，TrajGen仍然可以从原始轨迹中感知这些路段的存在，并生成沿着路段移动的轨迹。这从侧面体现了，在该工作的设置下，DCGAN可以捕获输入图片在局部位置频繁出现的线路形状，并在生成阶段也在这些局部位置，相应地形成同样形状的线路。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241758532.png" alt="image-20211224175852440"></p><h4 id="case-2：起点-终点需求估计">case 2：起点-终点需求估计<a class="header-anchor" href="#case-2：起点-终点需求估计">⁍</a></h4><blockquote><p>OD估计是描述公民出行需求的经典应用。其目的是计算OD矩阵。矩阵的每个值都代表从一个地点（即原点）到另一个地点（即目的地）的旅行需求。</p><ul><li>对出租车的OD需求定义为每个时间间隔内从出发地到目的地的出租车请求总数。</li><li>一段轨迹可能包含多个旅程journey(OD对)：用在小区域内移动或停留在出租车上客站所产生的位置来区分。</li><li>用DBSCAN[17]算法来确定核心位置，切割多个旅程</li></ul></blockquote><ul><li><p>通过比较OD矩阵来评估TrajGen是否保留了OD需求的效用。</p></li><li><p>把OD矩阵reshape成向量</p></li><li><p>计算Cosine相似度</p></li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112241809206.png" alt="image-20211224180922111"></p><h2 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h2><ul><li>这个工作主要是将轨迹的空间和时间信息进行解耦，将空间位置信息以图像的形式进行伪造的生成（DCGAN），再推断出时序信息（Seq2Seq），并合并进去</li><li>文中将轨迹进行了可视化处理</li><li>为了证明生成的轨迹的可用性，设计了非常详实的实验，有许多可以借鉴的地方</li><li>没有实验证明生成的轨迹的隐私性（对比TrajGAN，设计了TUL的实验）</li></ul><hr><ul class="contains-task-list"><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> 相关工作</p></li><li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="" type="checkbox"> background部分有对GAN和seq2seq的介绍</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 轨迹合成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轨迹 </tag>
            
            <tag> 隐私保护 </tag>
            
            <tag> GAN </tag>
            
            <tag> Seq2Seq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手学深度学习】模型选择、欠拟合和过拟合</title>
      <link href="/augu1sto/0e1497f209b4/"/>
      <url>/augu1sto/0e1497f209b4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/underfit-overfit.html">4.4. 模型选择、欠拟合和过拟合 — 动手学深度学习 2.0.0-beta0 documentation (d2l.ai)</a></p><p>将模型在训练数据上拟合的比在潜在分布中更接近的现象称为<em>过拟合</em>（overfitting）， 用于对抗过拟合的技术称为<em>正则化</em>（regularization）。</p><h2 id="训练误差和泛化误差">训练误差和泛化误差<a class="header-anchor" href="#训练误差和泛化误差">⁍</a></h2><ul><li><em>训练误差</em>（training error）是指， 模型在训练数据集上计算得到的误差。</li><li><em>泛化误差</em>（generalization error）是指， 模型应用在同样从原始样本的分布中抽取的无限多的数据样本时，<strong>模型误差的期望</strong>。</li></ul><h3 id="独立同分布假设i-i-d">独立同分布假设I.I.D<a class="header-anchor" href="#独立同分布假设i-i-d">⁍</a></h3><p>在我们目前已探讨、并将在之后继续探讨的监督学习情景中， 我们假设训练数据和测试数据都是从相同的分布中独立提取的。 这通常被称为<em>独立同分布假设</em>（i.i.d. assumption）， 这意味着对数据进行采样的过程没有进行“记忆”。 换句话说，抽取的第2个样本和第3个样本的相关性， 并不比抽取的第2个样本和第200万个样本的相关性更强。</p><p>有时候我们即使轻微违背独立同分布假设，模型仍将继续运行得非常好。</p><p>有些违背独立同分布假设的行为肯定会带来麻烦。</p><h3 id="模型复杂性">模型复杂性<a class="header-anchor" href="#模型复杂性">⁍</a></h3><ul><li>简单的模型和大量的数据：训练误差与期望泛化误差接近</li><li>复杂的模型和更少的数据：训练误差下降👇泛化误差👆</li></ul><blockquote><p>通常对于神经网络，我们认为需要更多训练迭代的模型比较复杂， 而需要“早停”（early stopping）的模型（即较少训练迭代周期）就不那么复杂。</p></blockquote><p>几个倾向于影响模型泛化的因素：</p><ol><li><strong>可调整参数的数量。</strong> 当可调整参数的数量（有时称为<em>自由度</em>）很大时，模型往往更容易过拟合。</li><li><strong>参数采用的值。</strong> 当权重的取值范围较大时，模型可能更容易过拟合。</li><li><strong>训练样本的数量。</strong> 即使你的模型很简单，也很容易过拟合只包含一两个样本的数据集。而过拟合一个有数百万个样本的数据集则需要一个极其灵活的模型。</li></ol><h2 id="模型选择">模型选择<a class="header-anchor" href="#模型选择">⁍</a></h2><p>评估几个候选模型后选择最终的模型。</p><h3 id="验证集">验证集<a class="header-anchor" href="#验证集">⁍</a></h3><ul><li>不能依靠测试数据进行模型选择：防止测试数据过拟合</li><li>不能依靠训练数据进行模型选择：无法估计泛化误差</li></ul><h3 id="k折交叉验证">K折交叉验证<a class="header-anchor" href="#k折交叉验证">⁍</a></h3><ul><li><strong>场景：</strong> 当训练数据稀缺时，我们甚至可能无法提供足够的数据来构成一个合适的验证集。</li><li><strong>方案：</strong><ul><li>原始训练数据被分成K个不重叠的子集。</li><li>然后执行K次模型训练和验证，每次在K−1个子集上进行训练，并在剩余的一个子集（在该轮中没有用于训练的子集）上进行验证。 最后，通过对K次实验的结果取平均来估计训练和验证误差。</li></ul></li></ul><h2 id="欠拟合与过拟合">欠拟合与过拟合<a class="header-anchor" href="#欠拟合与过拟合">⁍</a></h2><p><em>欠拟合</em>（underfitting）：</p>]]></content>
      
      
      <categories>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战（一）| 入门与安装(踩坑实录)</title>
      <link href="/augu1sto/d1ff406f9f51/"/>
      <url>/augu1sto/d1ff406f9f51/</url>
      
        <content type="html"><![CDATA[<h2 id="electron简介">Electron简介<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><a class="header-anchor" href="#electron简介">⁍</a></h2><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201707396.png" alt=""></p><h3 id="图解">图解<a class="header-anchor" href="#图解">⁍</a></h3><p>electron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。</p><p>它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用：</p><ol><li>Main进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。</li><li>Renderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。</li><li>Main进程和Renderer进程通过<code>ipcMain</code>和<code>ipcRenderer</code>来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。</li></ol><h3 id="electron-vue">electron-vue<a class="header-anchor" href="#electron-vue">⁍</a></h3><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201709168.png" alt=""></p><p>vue只是在renderer进程里使用的框架，不涉及到main进程。</p><blockquote><p>因此react、angluar以及其他的前端开发框架同样适用。</p></blockquote><p>因此react、angluar以及其他的前端开发框架同样适用。</p><h2 id="electron-vue安装">electron-vue安装<a class="header-anchor" href="#electron-vue安装">⁍</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果你没有vue-cli的话需要全局安装</span><br>npm install -g vue-cli<br><span class="hljs-comment"># 然后使用vue-cli来安装electron-vue的模板</span><br>vue init simulatedgreg/electron-vue my-project<br><br><span class="hljs-comment"># 安装依赖</span><br><span class="hljs-built_in">cd</span> my-project<br>yarn <span class="hljs-comment"># or npm install</span><br><span class="hljs-comment"># 进入开发模式</span><br>yarn run dev <span class="hljs-comment"># or npm run dev</span><br></code></pre></td></tr></table></figure><p>如果你是windows用户，在安装期间遇到了关于<code>node-gyp</code>、C++库等方面的问题的话，请参考官方文档给出的<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/en/getting_started.html#a-note-for-windows-users">解决办法</a>。</p><ul><li>简单来说就是要安装python2以及VSC++相关组件，如果已经安装就不用管了</li></ul><blockquote><p>因为之前我用npm安装过一次electron-vue，后来犹豫采用什么技术栈的时候又卸载了，但电脑整体环境中有些坑可能没办法记录，请大家善用搜索</p></blockquote><h3 id="yarn安装过程中的坑">yarn安装过程中的坑<a class="header-anchor" href="#yarn安装过程中的坑">⁍</a></h3><h4 id="node-sass问题">node-sass问题<a class="header-anchor" href="#node-sass问题">⁍</a></h4><p>主要应该就是node-sass的问题，尝试了网上许多种方法之后，最终还是决定给node.js降级</p><blockquote><p>错误信息忘记截图了，大概有什么 VS2017/MSBUILD之类的</p></blockquote><ol><li><p>查看node-sass对应的nodejs版本<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>项目目录下的<code>package.json</code>文件中有写<code>node-sass</code>的版本为’^4.9.2’</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201719515.png" alt="image-20211220171954469"></p><p>在<a href="https://www.npmjs.com/package/node-sass">node-sass (npmjs.com)</a>中查询对应的nodejs版本，为10</p></li><li><p>在nodejs 10.20.0环境下安装，继续报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fs-extra@10.0.0: The engine <span class="hljs-string">&quot;node&quot;</span> is incompatible with this module. Expected version <span class="hljs-string">&quot;&gt;=12&quot;</span>. Got <span class="hljs-string">&quot;10.20.0&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>╮(╯-╰)╭，还能怎样。。安装node js 12.22.8，最后终于成功了</p></li></ol><blockquote><p>有关nodeJS多版本管理切换方法见 <a href="/augu1sto/9f77e6e5eea4/" title="【Windows】利用NVM实现多版本nodejs的管理与切换">【Windows】利用NVM实现多版本nodejs的管理与切换</a></p></blockquote><h4 id="yarn-run-dev报错">yarn run dev报错<a class="header-anchor" href="#yarn-run-dev报错">⁍</a></h4><ol><li><p>Cannot GET /__webpack_hmr</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201740133.png" alt="image-20211220174050081"></p><p>参考<a href="https://blog.csdn.net/h2763246823/article/details/119901213">Electron-vue出现GET http://localhost:9080/__webpack_hmr net::ERR_ABORTED解决方案_h2763246823的博客-CSDN博客</a>可以通过修改源码的方式来解决</p><p>打开注释</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201812598.png" alt="image-20211220181207543"></p><ul><li>更新webpack？</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201812760.png" alt="image-20211220181259610"></p><p>解决</p></li><li><p><code>yarn run build</code>报错</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202251827372.png" alt="image-20220225182734296"></p><p>注释掉 .electron-vue/build.js中相关代码就行了<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202251829772.png" alt="image-20220225182906710"></p><p>再报错</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202251832986.png" alt="image-20220225183218918"></p><p>怀疑是网络问题，开代理，解决</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202251834459.png" alt="image-20220225183425376"></p><p>在build底下生成了安装exe，点击安装就生成了图标</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202251835444.png" alt="image-20220225183534289"></p></li><li><p>Unable to install <code>vue-devtools</code></p><p>vue-devtools是用来调试vue的插件</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201813834.png" alt="image-20211220181352788"></p><p>开代理后</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201815216.png" alt="image-20211220181511171"></p><p>【解决】</p><p><a href="https://orchidflower.oschina.io/2017/03/29/Using-Vue-Devtools-in-Electron/">Electron开发使用Vue Devtools - 执子之手 (oschina.io)</a></p><p>根据<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，需要下载5.1.1版本，但谷歌商店的插件已经更新到5.3.4了，故从官网下载<a href="https://github.com/vuejs/devtools/archive/refs/tags/v5.1.1.zip"> zip (github.com)</a>对应版本的压缩包</p><ul><li><p>进入devtools-5.1.1文件夹</p></li><li><p>执行<code>yarn install</code></p></li><li><p>修改<code>.\shells\chrome\manifest.json</code>文件，将<code>&quot;persistent&quot;: false</code>改为<code>&quot;persistent&quot;: true</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112211016156.png" alt="image-20211221101642101"></p></li><li><p>执行<code>yarn run build</code></p></li><li><p><code>[my-project]/src/main/index.dev.js</code>文件中如图所示位置添加如下代码<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>&#123;BrowserWindow&#125;=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;electron&quot;</span>)<br><span class="hljs-comment">// ....</span><br>BrowserWindow.addDevToolsExtension(<span class="hljs-string">&#x27;[your path]/devtools-5.1.1/shells/chrome/&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112211130365.png" alt="image-20211221113046290"></p></li><li><p>再<code>yarn run dev</code>就可以了</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112211122620.png" alt="image-20211221112238505"></p></li></ul></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://molunerfinn.com/electron-vue-1/#Electron%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D">Electron-vue开发实战0——Electron-vue入门 | MARKSZのBlog (molunerfinn.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://blog.csdn.net/Yy02123/article/details/121996370">Node Sass does not yet support your current environment.已解决_Yy02123的博客-CSDN博客</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://www.zhihu.com/question/458015510">Identifier ‘tasks’ has already been declared？ - 知乎 (zhihu.com)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://blog.csdn.net/qiuqiang748/article/details/106945982">electron-vue项目添加vue-devtools调试插件_qiuqiang748的博客-CSDN博客_electron-vue调试</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://blog.csdn.net/feinifi/article/details/109120462">electron+vue项目安装vue-devtools插件_feinifi的博客-CSDN博客_electron vue 插件</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> vue </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Windows】利用NVM实现多版本nodejs的管理与切换</title>
      <link href="/augu1sto/9f77e6e5eea4/"/>
      <url>/augu1sto/9f77e6e5eea4/</url>
      
        <content type="html"><![CDATA[<h2 id="卸载nodejs">卸载nodejs<a class="header-anchor" href="#卸载nodejs">⁍</a></h2><p>直接<code>控制面板</code>——<code>程序</code>——<code>程序与功能</code>——<code>卸载或更改程序</code>，找到<code>Node.js</code>右击卸载即可</p><blockquote><p>如果找不到，可以参考<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，在cmd里输入<code>where node</code>，找到相应的文件夹删除即可</p><p>考虑到卸载完这个文件夹也会残留，建议一并删除</p></blockquote><h2 id="安装nvm工具">安装nvm工具<a class="header-anchor" href="#安装nvm工具">⁍</a></h2><ul><li>从<a href="https://github.com/coreybutler/nvm-windows/releases">github官网</a>下载安装包（这里已经将1.1.9安装版上传到百度云：<a href="https://pan.baidu.com/s/15ul6_93f1P-hlnDqzT2pLA">提取码：3ws8 </a>）</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201453843.png" alt="image-20211220145337721"></p><ul><li><p>根据提示选择nvm和nodejs的安装位置，最后点Install就可以了</p></li><li><p>在新的命令行窗口中输入<code>nmv v</code>检验是否安装成功</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201505365.png" alt="image-20211220150509318"></p><blockquote><p>问题：在文件夹右击<code>在Windows终端中打开</code>，输入命令，找不到<code>nvm</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201507195.png" alt="image-20211220150756149"></p><p>但是如果<code>WIN+R</code>-<code>cmd</code>或者从开始菜单打开<code>命令提示符</code>的话，是可以执行<code>nvm</code>命令的</p><p>nvm路径已经被自动添加到系统变量了，想不通为什么，待会重启试试</p></blockquote></li></ul><h2 id="使用nvm安装nodejs">使用nvm安装nodejs<a class="header-anchor" href="#使用nvm安装nodejs">⁍</a></h2><p>输入<code>nvm install [node_version]</code>，例如<code>nvm install 10.20.0 </code></p><blockquote><p>可用版本查询：</p><ul><li><p>命令<code>nvm ls available</code></p></li><li><p><a href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js (nodejs.org)</a></p></li></ul><p>nvm镜像配置</p><ul><li><p><code>nvm root</code>：查找nvm的安装路径</p></li><li><p>在<code>[nvm root]/settings.txt</code>底下添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">node_mirror: https://npm.taobao.org/mirrors/node/<br>npm_mirror: https://npm.taobao.org/mirrors/npm/<br></code></pre></td></tr></table></figure></li></ul></blockquote><p>会自动下载对应版本的npm</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201520553.png" alt="image-20211220152047502"></p><p>输入<code>nvm use 10.20.0</code>切换到nodejs v10.2.0</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201528972.png" alt="image-20211220152808927"></p><blockquote><p>出现<code>exit status 1: 乱码</code>，可用管理员身份打开cmd<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112201530725.png" alt="image-20211220153024685"></p></blockquote><h2 id="nvm常用命令">nvm常用命令<a class="header-anchor" href="#nvm常用命令">⁍</a></h2><p><code>nvm ls</code>：列出全部node.js版本</p><p><code>nvm use [nodeversion]</code>：切换对应node.js</p><p><code>nvm install [nodeversion]</code>：安装对应node.js</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.cnblogs.com/liyhbk/p/14913799.html">windows如何把已安装的nodejs高版本降级为低版本 - helloliyh - 博客园 (cnblogs.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://blog.csdn.net/weixin_45682449/article/details/120948835">问题——nvm use 出现exit status 1:乱码_GGYY.的博客-CSDN博客_nvm use 乱码</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-vue开发实战|总记录</title>
      <link href="/augu1sto/4f10b549e4ad/"/>
      <url>/augu1sto/4f10b549e4ad/</url>
      
        <content type="html"><![CDATA[<p>总之想开发桌面应用程序，技术选型选了一阵子还是打算用electron-vue<br>可能会加上java springboot，毕竟最后做项目肯定得用到</p><p>先记录一下可能要学习到的教程</p><blockquote><p>不过vue.js的安装确实烦。。</p></blockquote><h2 id="electron">electron<a class="header-anchor" href="#electron">⁍</a></h2><ul><li>《Electron跨平台开发实战》<ul><li><a href="https://github.com/electron-in-action">Electron in Action (github.com)</a></li></ul></li></ul><h2 id="electron-vue">electron-vue<a class="header-anchor" href="#electron-vue">⁍</a></h2><ul><li>框架github：<a href="https://github.com/SimulatedGREG/electron-vue">SimulatedGREG/electron-vue</a></li><li>官方文档：<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/">简介 · electron-vue (gitbooks.io)</a></li><li>Picgo-github：<a href="https://github.com/Molunerfinn/PicGo">Molunerfinn/PicGo</a></li><li>Picgo-开发实战：<a href="https://molunerfinn.com/tags/Electron-vue/">Electron-vue 开发实战 (molunerfinn.com)</a></li></ul><h2 id="java-spring-boot-electron相关">java spring boot + electron相关<a class="header-anchor" href="#java-spring-boot-electron相关">⁍</a></h2><ul><li><a href="https://www.cnblogs.com/GoodHelper/p/8527523.html">spring boot + vue + element-ui全栈开发入门——基于Electron桌面应用开发</a><ul><li>GitHub： <a href="https://github.com/carter659/electron-vue-example">carter659/electron-vue-example: electron-vue+spring boot全栈例子 </a></li></ul></li><li><a href="https://github.com/cuba-labs/java-electron-tutorial">cuba-labs/java-electron-tutorial</a></li><li><a href="https://github.com/lhing17/gsein-redis-client">lhing17/gsein-redis-client</a></li></ul><h2 id="vue-spring-boot开发实战">Vue+Spring Boot开发实战<a class="header-anchor" href="#vue-spring-boot开发实战">⁍</a></h2><p><a href="https://www.jianshu.com/p/065dcd19d241">Java Web 开发入门全套教程（Vue + Spring Boot） - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Electron-vue开发实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|字符串</title>
      <link href="/augu1sto/d0b5bb44a690/"/>
      <url>/augu1sto/d0b5bb44a690/</url>
      
        <content type="html"><![CDATA[<h2 id="豆知识">豆知识<a class="header-anchor" href="#豆知识">⁍</a></h2><h3 id="1-比较函数">1. 比较函数<a class="header-anchor" href="#1-比较函数">⁍</a></h3><ul><li>可以用 “==” 来比较两个字符串吗？</li></ul><p>取决于使用的语言是否支持运算符重载？</p><ul><li><p>如果答案是 yes （例如 C++、Python）。我们可以使用 == 来比较两个字符串；</p></li><li><p>如果答案是 no （例如 Java），我们可能无法使用 == 来比较两个字符串。当我们使用 == 时，它实际上会比较这两个对象是否是同一个对象。(可以用 <code>string.equals</code>和<code>string.compareTo</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &quot;static void main&quot; must be defined in a public class.</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// initialize</span><br>        String s1 = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;s1 is \&quot;&quot;</span> + s1 + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        String s2 = s1;<br>        System.out.println(<span class="hljs-string">&quot;s2 is another reference to s1.&quot;</span>);<br>        String s3 = <span class="hljs-keyword">new</span> String(s1);<br>        System.out.println(<span class="hljs-string">&quot;s3 is a copy of s1.&quot;</span>);<br>        <span class="hljs-comment">// compare using &#x27;==&#x27;</span><br>        System.out.println(<span class="hljs-string">&quot;Compared by &#x27;==&#x27;:&quot;</span>);<br>        <span class="hljs-comment">// true since string is immutable and s1 is binded to &quot;Hello World&quot;</span><br>        System.out.println(<span class="hljs-string">&quot;s1 and \&quot;Hello World\&quot;: &quot;</span> + (s1 == <span class="hljs-string">&quot;Hello World&quot;</span>));<br>        <span class="hljs-comment">// true since s1 and s2 is the reference of the same object</span><br>        System.out.println(<span class="hljs-string">&quot;s1 and s2: &quot;</span> + (s1 == s2));<br>        <span class="hljs-comment">// false since s3 is refered to another new object</span><br>        System.out.println(<span class="hljs-string">&quot;s1 and s3: &quot;</span> + (s1 == s3));<br>        <span class="hljs-comment">// compare using &#x27;equals&#x27;</span><br>        System.out.println(<span class="hljs-string">&quot;Compared by &#x27;equals&#x27;:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;s1 and \&quot;Hello World\&quot;: &quot;</span> + s1.equals(<span class="hljs-string">&quot;Hello World&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;s1 and s2: &quot;</span> + s1.equals(s2));<br>        System.out.println(<span class="hljs-string">&quot;s1 and s3: &quot;</span> + s1.equals(s3));<br>        <span class="hljs-comment">// compare using &#x27;compareTo&#x27;</span><br>        System.out.println(<span class="hljs-string">&quot;Compared by &#x27;compareTo&#x27;:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;s1 and \&quot;Hello World\&quot;: &quot;</span> + (s1.compareTo(<span class="hljs-string">&quot;Hello World&quot;</span>) == <span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;s1 and s2: &quot;</span> + (s1.compareTo(s2) == <span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;s1 and s3: &quot;</span> + (s1.compareTo(s3) == <span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>output</strong></p><p>s1 is “Hello World”<br>s2 is another reference to s1.<br>s3 is a copy of s1.<br>Compared by ‘==’:<br>s1 and “Hello World”: true<br>s1 and s2: true<br>s1 and s3: false<br>Compared by ‘equals’:<br>s1 and “Hello World”: true<br>s1 and s2: true<br>s1 and s3: true<br>Compared by ‘compareTo’:<br>s1 and “Hello World”: true<br>s1 and s2: true<br>s1 and s3: true</p></blockquote></li></ul><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/c9lnm/">https://leetcode-cn.com/leetbook/read/array-and-string/c9lnm/</a><br>来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="最长公共前缀"><a href="https://leetcode-cn.com/leetbook/read/array-and-string/ceda1/">最长公共前缀</a><a class="header-anchor" href="#最长公共前缀">⁍</a></h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p><strong>思路：</strong></p><ol><li><p>python 高阶(?)用法</p><ol><li>使用zip将每个str的第i个字符结合形成元组，即<code>(strs[0][0],strs[1][0],strs[2][0],...)</code></li><li>用set排除每个元组中重复的元素，如果只剩一个元素，证明是公共的字母</li></ol></li><li><p>循环直到不是 只剩一个元素 的情况，说明公共前缀已经结束，退出循环</p><p>作者：Muzi-Li<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/ceda1/?discussion=TZS629">https://leetcode-cn.com/leetbook/read/array-and-string/ceda1/?discussion=TZS629</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        ret = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">#使用zip</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*strs):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(i)) == <span class="hljs-number">1</span>:<br>             ret += i[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> ret<br><br></code></pre></td></tr></table></figure></li><li><p>其他的（待更新）</p></li></ol><h2 id="5-最长回文子串"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/">5. 最长回文子串</a><a class="header-anchor" href="#5-最长回文子串">⁍</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><blockquote><p><strong>思路：</strong></p></blockquote><p>中心扩展，分奇偶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        res = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            s1 = self.findPalindrome(s , i, i)<br>            s2 = self.findPalindrome(s, i, i+<span class="hljs-number">1</span>)<br>            res = res <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res)&gt;<span class="hljs-built_in">len</span>(s1) <span class="hljs-keyword">else</span> s1<br>            res = res <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res)&gt;<span class="hljs-built_in">len</span>(s2) <span class="hljs-keyword">else</span> s2<br>        <span class="hljs-keyword">return</span> res<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findPalindrome</span>(<span class="hljs-params">self, s, l, r</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            寻找以l为中心扩散的最长回文子串；</span><br><span class="hljs-string">            偶串的情况：r=l+1</span><br><span class="hljs-string">            奇串的情况：r=l</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> l&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r&lt;<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[l]==s[r]:<br>            l-=<span class="hljs-number">1</span><br>            r+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> s[l+<span class="hljs-number">1</span>:r]<br></code></pre></td></tr></table></figure><p>↓相似题：</p><h2 id="647-回文子串"><a href="https://leetcode-cn.com/problems/palindromic-substrings/description/">647. 回文子串</a><a class="header-anchor" href="#647-回文子串">⁍</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.res = <span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countSubstrings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>            self.countFromIJ(s,i-<span class="hljs-number">1</span>,i-<span class="hljs-number">1</span>)<br>            self.countFromIJ(s,i-<span class="hljs-number">1</span>,i)<br>        self.res += <span class="hljs-number">1</span> <span class="hljs-comment"># 加上s[-1]</span><br>        <span class="hljs-keyword">return</span> self.res<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countFromIJ</span>(<span class="hljs-params">self, s, left, right</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            从left,right中心扩散</span><br><span class="hljs-string">            当s的长度为偶数时，right事实上=left+1</span><br><span class="hljs-string">            ..........奇数时，right=left</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> left&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right&lt;=<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[left]==s[right]:<br>            self.res+=<span class="hljs-number">1</span><br>            left-=<span class="hljs-number">1</span><br>            right+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>回文子串的另一种方法 <a href="https://leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-leetcode-solution/">Manacher算法</a></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|动态规划</title>
      <link href="/augu1sto/536722f65a35/"/>
      <url>/augu1sto/536722f65a35/</url>
      
        <content type="html"><![CDATA[<h2 id="总体认识">总体认识<a class="header-anchor" href="#总体认识">⁍</a></h2><p>动态规划包含了「分治思想」、「空间换时间」、「最优解」等多种基石算法思想</p><ul><li>动态规划问题特点，动态规划和分治算法的联系与区别；</li><li>借助例题介绍重叠子问题和最优子结构分别是什么，以及动态规划是如何解决它们的；</li><li>动态规划的解题框架总结；</li><li>动态规划的练习例题，从易到难排序；</li></ul><p><mark>普遍来看，<strong>求最值</strong> 的问题一般都具有「重叠子问题」和「最优子结构」特点，因此此类问题往往适合用动态规划解决。</mark></p><h3 id="动态规划特点">动态规划特点<a class="header-anchor" href="#动态规划特点">⁍</a></h3><p><strong>「分治」<strong>是算法中的一种基本思想，其通过</strong>将原问题分解为子问题</strong>，不断<strong>递归</strong>地将子问题分解为更小的子问题，并通过<strong>组合</strong>子问题的解来得到原问题的解。</p><p>类似于分治算法，**「动态规划」<strong>也通过组合子问题的解得到原问题的解。不同的是，适合用动态规划解决的问题具有</strong>「重叠子问题」和「最优子结构」**两大特性。</p><h4 id="1-重叠子问题">1. 重叠子问题<a class="header-anchor" href="#1-重叠子问题">⁍</a></h4><p>各个子问题中包含重复的更小子问题。</p><ul><li><p>第一次求解某子问题时，保存子问题的解</p></li><li><p>后续遇到重叠子问题时，则直接通过<strong>查表</strong>获取解</p></li></ul><h5 id="示例：斐波那契数列">示例：斐波那契数列<a class="header-anchor" href="#示例：斐波那契数列">⁍</a></h5><blockquote><p>斐波那契数形成的数列为 [0,1,1,2,3,5,8,13,⋯]</p><p>F0=0</p><p>F1=1</p><p>Fn=Fn-1+Fn-2</p><p>求第N个斐波那契数（从第0个开始）</p></blockquote><ul><li>暴力递归：<code>fibonacci()</code> 函数的调用次数$O(2^n)$</li><li>记忆化递归：用数组保存子问题的解：<code>fibonacci()</code> 函数的调用次数$O(n)$</li><li>动态规划：循环迭代<ul><li>数组保存dp[i]：空间复杂度$O(N)$</li><li>使用两个变量 a,b交替前进计算：空间复杂度$O(1)$</li></ul></li></ul><p>不包含「最优子结构」，并不需要从子问题组合中<strong>选择最优组合</strong>。</p><h4 id="2-最优子结构">2. 最优子结构<a class="header-anchor" href="#2-最优子结构">⁍</a></h4><p>如果</p><ol><li><strong>一个问题的最优解可以由其子问题的最优解组合构成</strong>，并且</li><li>这些子问题可以独立求解，</li></ol><p>那么称此问题具有最优子结构。</p><p>动态规划从基础问题的解开始，不断迭代组合、选择子问题的最优解，最终得到原问题最优解。</p><h5 id="最优子结构示例：蛋糕最高售价">最优子结构示例：蛋糕最高售价<a class="header-anchor" href="#最优子结构示例：蛋糕最高售价">⁍</a></h5><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112191942957.png" alt="image-20211219194207921"></p><p>设重量为$n$蛋糕的售价为$p(n)$ ，切分的最高总售价为$f(n)$</p><p>$f(n) = \max_{0 \leq i &lt; n} (f(i) + p(n - i))$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入蛋糕价格列表 priceList ，求重量为 n 蛋糕的最高售价</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCakePrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[] priceList)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> priceList[n];  <span class="hljs-comment">// 蛋糕重量 &lt;= 1 时直接返回</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];        <span class="hljs-comment">// 初始化 dp 列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;    <span class="hljs-comment">// 按顺序计算 f(1), f(2), ..., f(n)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)   <span class="hljs-comment">// 从 j 种组合种选择最高售价的组合作为 f(j)</span><br>            dp[j] = Math.max(dp[j], dp[i] + priceList[j - i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="动态规划解题框架">动态规划解题框架<a class="header-anchor" href="#动态规划解题框架">⁍</a></h3><p>若确定给定问题具有重叠子问题和最优子结构，那么就可以使用动态规划求解。总体上看，求解可分为四步：</p><ol><li><strong>状态定义：</strong> 构建问题最优解模型，包括问题<strong>最优解的定义</strong>、有哪些<strong>计算解的自变量</strong>；</li><li><strong>初始状态：</strong> 确定<strong>基础子问题的解</strong>（即已知解），原问题和子问题的解都是以基础子问题的解为起始点，在迭代计算中得到的；</li><li><strong>转移方程：</strong> 确定原问题的解与子问题的解之间的关系是什么，以及使用何种<strong>选择规则</strong>从子问题最优解组合中选出原问题最优解；</li><li><strong>返回值：</strong> 确定应返回的问题的解是什么，即动态规划<strong>在何处停止迭代</strong>；</li></ol><p>完成以上步骤后，便容易写出对应的解题代码。</p><h4 id="示例：斐波那契数列-2">示例：斐波那契数列<a class="header-anchor" href="#示例：斐波那契数列-2">⁍</a></h4><ul><li>状态定义：一维dp列表，设第i 个斐波那契数为dp[i]</li><li>初始状态：dp[0]=0, dp[1]=1</li><li>转移方程：dp[i]=dp[i-1]+dp[i-2]</li><li>返回值：需求取的第n个斐波那契数dp[n]</li></ul><h4 id="示例：蛋糕最高售价">示例：蛋糕最高售价<a class="header-anchor" href="#示例：蛋糕最高售价">⁍</a></h4><ul><li><p>状态定义：一维dp列表，设重量为i的蛋糕的售价为p(i)，重量为i的蛋糕切分后的最高售价为 dp[i]</p></li><li><p>初始状态：dp[0]=0, dp[1]=p[1]</p></li><li><p>转移方程：</p><p>$$f(n) = \max_{0 \leq i &lt; n} (f(i) + p(n - i))$$</p></li><li><p>返回值：需求取的重量为n的蛋糕最高售价$dp[n]$</p></li></ul><h3 id="动态规划五部曲">动态规划五部曲<a class="header-anchor" href="#动态规划五部曲">⁍</a></h3><p><strong>递推公式决定了dp数组要如何初始化</strong> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="背包问题">背包问题<a class="header-anchor" href="#背包问题">⁍</a></h2><p>总结图<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup></p><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="img"></p><p>常见的背包类型主要有以下几种<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：<br>1、0/1背包问题：每个元素最多选取一次<br>2、完全背包问题：每个元素可以重复选择<br>3、排列（组合）背包问题：背包中的物品要考虑顺序<br>4、分组背包问题：不止一个背包，需要遍历每个背包</p><p>而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：<br>1、最值问题：要求最大值/最小值<br>2、存在问题：是否存在…………，满足…………<br>3、组合问题：求所有满足……的排列组合</p><p>因此把背包类型和问题类型结合起来就会出现以下细分的题目类型：<br>1、0/1背包最值问题<br>2、0/1背包存在问题<br>3、0/1背包组合问题<br>4、完全背包最值问题<br>5、完全背包存在问题<br>6、完全背包组合问题<br>7、分组背包最值问题<br>8、分组背包存在问题<br>9、分组背包组合问题这九类问题我认为几乎可以涵盖力扣上所有的背包问题</p><h3 id="0-1背包问题">0-1背包问题<a class="header-anchor" href="#0-1背包问题">⁍</a></h3><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>举例：背包最大重量为4。</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><blockquote><p><strong>思路：</strong></p></blockquote><h4 id="二维dp数组">二维dp数组<a class="header-anchor" href="#二维dp数组">⁍</a></h4><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i][j] 表示从 <strong>下标为[0-i]的物品</strong> 里任意取，放进 <strong>容量为j</strong> 的背包，价值总和最大是多少</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203071451277.png" alt="image-20220307145059850"></p></li><li><p>确定递推公式</p><ul><li><p>j &lt; weight[i]: 放不了物品：</p><ul><li>dp[i][i]=dp[i-1][j]</li></ul></li><li><p>j &gt;= weight[j]: max(不放物品i，放物品i)</p><p>放物品i = value(物品i)+在剩余重量（j-物品i重量）里放其他物品</p><p>dp[i][j] = max(dp[i-1][j], v[i]+dp[i-1][j-weight[i]])</p></li></ul></li><li><p>dp数组如何初始化</p><p>dp[i][0] = 0</p><p>dp[0][j]:</p><ul><li>j &lt; weight[0]: 0</li><li>j &gt;= weight[i]: v[0]</li></ul></li><li><p>确定遍历顺序</p><p>都可以，例如先遍历物品，再遍历重量</p></li><li><p>举例推导dp数组</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-keyword">int</span> bagsize = <span class="hljs-number">4</span>;<br>    testweightbagproblem(weight, value, bagsize);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testweightbagproblem</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span>[] value, <span class="hljs-keyword">int</span> bagsize)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m = weight.length; <span class="hljs-comment">// 一共有多少物品，决定dp行数</span><br>    <span class="hljs-keyword">int</span> n = bagsize+<span class="hljs-number">1</span>; <span class="hljs-comment">// 背包重量，决定dp列数, 记得+1</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; weight[<span class="hljs-number">0</span>]) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j&lt;weight[i])&#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], value[i]+dp[i-<span class="hljs-number">1</span>][j-weight[i]]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    System.out.println(dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滚动数组——dp降维">滚动数组——dp降维<a class="header-anchor" href="#滚动数组——dp降维">⁍</a></h4><p>对于<code>Math.max(dp[i-1][j], value[i]+dp[i-1][j-weight[i]])</code></p><p>dp[i-1]这一层可以拷贝到dp[i]这层上滚动:</p><p><code>dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-keyword">int</span> bagsize = <span class="hljs-number">4</span>;<br>    testweightbagproblem(weight, value, bagsize);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testweightbagproblem</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span>[] value, <span class="hljs-keyword">int</span> bagsize)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m = weight.length; <span class="hljs-comment">// 一共有多少物品</span><br>    <span class="hljs-keyword">int</span> n = bagsize+<span class="hljs-number">1</span>; <span class="hljs-comment">// 背包重量，决定dp列数, 记得+1</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; weight[<span class="hljs-number">0</span>]) &#123;<br>            dp[j] = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[j] = value[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j&lt;weight[i])&#123;<br>                dp[j] = dp[j];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[j] = Math.max(dp[j], value[i]+dp[j-weight[i]]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    System.out.println(dp[n-<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分类解题模板">分类解题模板<a class="header-anchor" href="#分类解题模板">⁍</a></h4><p>背包问题大体的解题模板是两层循环，分别遍历物品nums和背包容量target，然后写转移方程，根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup></p><h5 id="首先是背包分类的模板：">首先是背包分类的模板：<a class="header-anchor" href="#首先是背包分类的模板：">⁍</a></h5><p>1、 <strong>0/1背包：</strong> 外循环nums,内循环target,target倒序且target&gt;=nums[i];<br>2、 <strong>完全背包（可重复）：</strong> 外循环nums,内循环target,target正序且target&gt;=nums[i];<br>3、 <strong>排序（组合）背包/属于完全背包：</strong> 外循环target,内循环nums,target正序且target&gt;=nums[i];<br>4、 <strong>分组背包：</strong> 这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><h5 id="然后是问题分类的模板：">然后是问题分类的模板：<a class="header-anchor" href="#然后是问题分类的模板：">⁍</a></h5><p>1、 <strong>最值问题:</strong>  dp[i] = max/min(dp[i], dp[i-nums]+1)或dp[i] = max/min(dp[i], dp[i-num]+nums);<br>2、 <strong>存在问题(bool)：</strong> dp[i]=dp[i]||dp[i-num];<br>3、 <strong>组合问题：</strong> dp[i]+=dp[i-num];</p><p>这样遇到问题将两个模板往上一套大部分问题就可以迎刃而解</p><hr><h2 id="53-最大子数组和"><a href="https://leetcode-cn.com/problems/maximum-subarray/description/">53. 最大子数组和</a><a class="header-anchor" href="#53-最大子数组和">⁍</a></h2><a href="/augu1sto/0d8a87a8eab4/" title="Leetcode|数组Arrays">Leetcode|数组Arrays</a><h2 id="55-跳跃游戏"><a href="https://leetcode-cn.com/problems/jump-game/description/">55. 跳跃游戏</a><a class="header-anchor" href="#55-跳跃游戏">⁍</a></h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><blockquote><p><strong>思路：</strong>（较慢）</p></blockquote><ul><li><p>状态定义：</p><ul><li>$n[i]$: nums[i]的值</li><li>$r[i]$: i结点能否到达</li></ul></li><li><p>初始状态：$r[0]=1$</p></li><li><p>转移方程：$$r[n]=r[i]\And\And n[i]&gt;=n-i, 0&lt;=i&lt;n$$</p></li><li><p>返回值：true/false</p></li></ul><h2 id="70-爬楼梯"><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a><a class="header-anchor" href="#70-爬楼梯">⁍</a></h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><blockquote><p><strong>思路：</strong> 相当于斐波那契数列</p></blockquote><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i]： 爬到第i层有多少种方法</p></li><li><p>确定递推公式</p><p>dp[i] = dp[i-1] + dp[i-2]</p><p>i-1层爬1个台阶，i-2层爬2个台阶</p></li><li><p>dp数组如何初始化</p><p>dp[1] = 1</p><p>dp[2] = 2</p></li><li><p>确定遍历顺序</p><p>从小到大</p></li><li><p>举例推导dp数组</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 跟斐波那契数列一样</span><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, sum = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            sum = a + b;<br>            a = b;<br>            b = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯"><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a><a class="header-anchor" href="#746-使用最小花费爬楼梯">⁍</a></h2><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><blockquote><p><strong>思路</strong></p></blockquote><p>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">// 爬到第0级的花销</span><br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>; <span class="hljs-comment">// 爬到第1级的花销</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.length; i++) &#123;<br>            sum = Math.min(a + cost[i - <span class="hljs-number">2</span>], b + cost[i - <span class="hljs-number">1</span>]);<br>            a = b;<br>            b = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a><a class="header-anchor" href="#62-不同路径">⁍</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><blockquote><p><strong>思路</strong></p></blockquote><p>dp[i][j] = dp[i-1][j] + dp[i][j-1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="63-不同路径-ii"><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a><a class="header-anchor" href="#63-不同路径-ii">⁍</a></h2><p>网格中有障碍物</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203070007305.jpeg" alt="img"></p><blockquote><p>如果有障碍物则置0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = obstacleGrid.length;<br>        <span class="hljs-keyword">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]^<span class="hljs-number">1</span>; <span class="hljs-comment">//0变1，1变0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 有障碍物，说明不可达</span><br>                obstacleGrid[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 置0</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                obstacleGrid[i][<span class="hljs-number">0</span>] = obstacleGrid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                obstacleGrid[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                obstacleGrid[<span class="hljs-number">0</span>][j] = obstacleGrid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    obstacleGrid[i][j] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    obstacleGrid[i][j] = obstacleGrid[i-<span class="hljs-number">1</span>][j] + obstacleGrid[i][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> obstacleGrid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="343-整数拆分"><a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a><a class="header-anchor" href="#343-整数拆分">⁍</a></h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><blockquote><p><strong>思路</strong></p></blockquote><p><strong>1. 数学方法</strong></p><p>可以用数学归纳法证明对任意一个整数最大的拆分形式为n = 2<em>p + 3</em>q，则乘积 m = 2^p * 3^q (n &gt;= 3, p, q为自然数)，并且q应该尽可能大（理由：如果q减少2，则p要增加3，而2^3 &lt; 3^2，因此应该尽可能增加q）。</p><p>–》动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];        <br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>] * <span class="hljs-number">2</span>, dp[i - <span class="hljs-number">3</span>] * <span class="hljs-number">3</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203071107837.png" alt="image-20220307110751766"></p><p>–&gt; 直接数学</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> quotient = n / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> remainder = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient) * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>2. 动态规划</strong></p><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p></li><li><p>确定递推公式</p><p>有两种渠道得到dp[i].</p><p>一个是j * (i - j) 直接相乘。</p><p>一个是j * dp[i - j]，相当于是拆分(i - j)</p><p>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</p><p>在遍历过程中不断更新dp[i]的最大值</p></li><li><p>dp的初始化</p><p>dp[2] = 1,// dp[3] = 2</p></li><li><p>确定遍历顺序</p><p>从前向后</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">int</span> curMax = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));<br>            &#125;<br>            dp[i] = curMax;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="96-不同的二叉搜索树"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a><a class="header-anchor" href="#96-不同的二叉搜索树">⁍</a></h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203071349439.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 3<br>输出：5<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 1<br>输出：1<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong></p></blockquote><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i]: 从 <code>1</code> 到 <code>i</code> 互不相同的 二叉搜索树</p></li><li><p>确定递推公式</p><p>在从<code>1</code>-<code>i-1</code>的二叉搜索树中加入<code>i</code>节点，根节点一共有<code>i</code>种可能：</p><ul><li>根节点是<code>i</code>：没有元素比它大，右子树为空；<code>1~i-1</code>都比它小，成为它的左子树。一共是<code>dp[i-1]</code>种</li><li>根节点是<code>i-1</code>：<code>i</code>比<code>i-1</code>大，右子树1个节点<code>dp[1]</code>；<code>1~i-2</code>都比它小，左子树<code>i-2</code>个节点，即<code>dp[i-2]</code>。一共是<code>dp[1]*dp[i-2]</code>种。</li><li>根节点是<code>i-2</code>：<code>i-1~i</code>比<code>i-2</code>大，右子树2个节点<code>dp[2]</code>；…左子树<code>i-3</code>个节点，即<code>dp[i-3]</code>。一共<code>dp[2]*dp[i-3]</code></li><li>…</li></ul><p>综合，取dp[0]=1；则</p><p>dp[i] = sum(dp[j]*dp[i-j-1])，j=0,…,i-1</p></li><li><p>dp数组如何初始化</p><p>dp[1] = 1</p></li><li><p>确定遍历顺序</p><p>从小到大</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                dp[i] += dp[j]*dp[i-j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="416-分割等和子集"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a><a class="header-anchor" href="#416-分割等和子集">⁍</a></h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><blockquote><p><strong>思路：</strong> 转化为0-1背包</p></blockquote><p>先计算sum，sum为单数则直接返回false</p><p>target = sum/2</p><p>先排序？</p><ol><li><p>dp数组</p><p>dp[j]表示最大（接近）为j时的和</p></li><li><p>递推公式</p><ul><li>nums[i]&gt;j: 加不进去</li><li>nums[i]&lt;=j:<ul><li>max()</li><li>dp[j]</li><li>nums[i]+dp[j-nums[i]]</li></ul></li></ul></li><li><p>初始状态</p><p>如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p></li><li><p>遍历顺序</p><p><strong>从大到小遍历</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: nums) &#123;<br>            sum+=num;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((sum &amp; <span class="hljs-number">1</span>) ==<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= nums[i] ; j--) &#123; <span class="hljs-comment">// 注意倒序遍历</span><br>                dp[j] = Math.max(dp[j], nums[i]+dp[j-nums[i]]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[target] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1049-最后一块石头的重量-ii"><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a><a class="header-anchor" href="#1049-最后一块石头的重量-ii">⁍</a></h2><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：stones = [2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：stones = [31,26,33,21,40]<br>输出：5<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：stones = [1,2]<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><blockquote><p><strong>思路</strong> 问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值</p></blockquote><p>要让差值小,两堆石头的重量都要接近sum/2;</p><p>将一堆stone放进最大容量为sum/2的背包,求放进去的石头的最大重量MaxWeight, 最终答案即为 <strong>sum-2*MaxWeight</strong></p><p>dp[i][j]含义:从前i块石头中选取，选取值之和小于等于目标值j的最大值为dp。（i、j分别对应从外到内两层循环。）（maxWeight）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] stones)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stone:stones) &#123;<br>            sum+=stone;<br>        &#125;<br>        <span class="hljs-keyword">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;=stones[i] ; j--) &#123;<br>                dp[j] = Math.max(dp[j], dp[j-stones[i]]+stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum-<span class="hljs-number">2</span>*dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="494-目标和"><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a><a class="header-anchor" href="#494-目标和">⁍</a></h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1], target = 1<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul><blockquote><p><strong>思路</strong> 0-1背包组合问题</p></blockquote><p>数组和sum,目标和s, 正数的和为x,负数的和为-y,则x+y=sum,x-y=s,那么x=(s+sum)/2=target</p><p>在本题中，s换名叫target，这里target就更正为tt</p><p>相当于在nums里选x个数，和为tt</p><p>初始化 dp[0]=1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num:nums) &#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-comment">// 先判断target是否存在</span><br>        <span class="hljs-keyword">if</span> (((sum + target)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span> || sum &lt;target || -sum&gt;target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tt = (target+sum)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[tt+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num:nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tt; i &gt;=num ; i--) &#123;<br>                dp[i] += dp[i-num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[tt];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="474-一和零"><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a><a class="header-anchor" href="#474-一和零">⁍</a></h2><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。<br>其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1<br>输出：2<br>解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 600</code></li><li><code>1 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅由 <code>'0'</code> 和 <code>'1'</code> 组成</li><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><blockquote><p><strong>思路：</strong> 0-1背包 最值问题</p></blockquote><p>三维–》二维</p><p>dp[i][j] 子集长度; 有i个0，j个1</p><p>dp[0][0]：0（空集）</p><p>返回的是子集的长度！不是字符串的长度！</p><p><code>dp[i][j] = Math.max(dp[i][j], dp[i-s.zero][j-s.one]+1);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String str:strs) &#123;<br>            MyString s = <span class="hljs-keyword">new</span> MyString(str);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;=s.zero ; i--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;=s.one ; j--) &#123;<br>                    dp[i][j] = Math.max(dp[i][j], dp[i-s.zero][j-s.one]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> zero; <span class="hljs-comment">// 0的数量</span><br>        <span class="hljs-keyword">int</span> one; <span class="hljs-comment">// 1的数量</span><br>        String val; <span class="hljs-comment">// 值</span><br>        <span class="hljs-keyword">int</span> length;<br>        MyString(String str)&#123;<br>            <span class="hljs-keyword">this</span>.val = str;<br>            <span class="hljs-keyword">this</span>.length = str.length();<br>            <span class="hljs-keyword">this</span>.one = <span class="hljs-keyword">this</span>.cntOne(<span class="hljs-keyword">this</span>.val);<br>            <span class="hljs-keyword">this</span>.zero = <span class="hljs-keyword">this</span>.length - <span class="hljs-keyword">this</span>.one;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cntOne</span><span class="hljs-params">(String str)</span></span>&#123;<br>            <span class="hljs-comment">// 不能转换为整数来count，因为可能整型溢出</span><br>            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (str.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    k++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> k;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a><a class="header-anchor" href="#322-零钱兑换">⁍</a></h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 = 5 + 5 + 1<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：coins = [2], amount = 3<br>输出：-1<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：coins = [1], amount = 0<br>输出：0<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><blockquote><p><strong>思路：</strong> 完全背包 最值问题</p></blockquote><p>dp[i] 代表组成金额i的最少硬币个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxVal = amount+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount+<span class="hljs-number">1</span>];<br>        Arrays.fill(dp, maxVal); <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin:coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = coin; i &lt;= amount; i++) &#123;<br>                dp[i] = Math.min(dp[i], dp[i-coin]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == maxVal ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="518-零钱兑换-ii"><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a><a class="header-anchor" href="#518-零钱兑换-ii">⁍</a></h2><p>计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><blockquote><p><strong>思路：</strong> 完全背包的组合问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = coin; i &lt;= amount ; i++) &#123;<br>                dp[i] += dp[i-coin];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="377-组合总和-ⅳ"><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a><a class="header-anchor" href="#377-组合总和-ⅳ">⁍</a></h2><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [9], target = 3<br>输出：0<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><blockquote><p><strong>思路</strong>  排列 背包组合问题</p></blockquote><p>dp[i] 和为i的组合个数</p><p>dp[i] += dp[i-num]</p><p>dp[0] = 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target+<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num:nums) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= num) &#123;<br>                    dp[i] += dp[i-num];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p>例如，假设数组nums 中含有正整数 a 和负整数−b，则有a×b+(−b)×a=0，对于任意一个元素之和等于target 的排列，在该排列的后面添加 b 个 a 和 a 个 -b之后，得到的新排列的元素之和仍然等于target，而且还可以在新排列的后面继续 b 个 a 和 a 个 −b。因此只要存在元素之和等于 target 的排列，就能构造出无限长度的排列。</p><p>如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数。</p><h2 id="279-完全平方数"><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a><a class="header-anchor" href="#279-完全平方数">⁍</a></h2><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 12<br>输出：3 <br>解释：12 = 4 + 4 + 4<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong> 完全背包 最值问题</p></blockquote><p>dp[i] 和为i的完全平方数的最少数量</p><p>dp[i] = min(dp[i], dp[i-num]+1)</p><p>dp[0] = 0</p><p>遍历条件 num^2 &lt;= i</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        Arrays.fill(dp,n+<span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= Math.sqrt(n) ; i++) &#123;<br>            <span class="hljs-keyword">int</span> num = i*i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = num; j &lt;= n; j++) &#123;<br>                dp[j] = Math.min(dp[j], dp[j-num]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1155-掷骰子的n种方法"><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子的N种方法</a><a class="header-anchor" href="#1155-掷骰子的n种方法">⁍</a></h2><p>这里有 <code>n</code> 个一样的骰子，每个骰子上都有 <code>k</code> 个面，分别标号为 <code>1</code> 到 <code>k</code> 。</p><p>给定三个整数 <code>n</code> , <code>k</code> 和 <code>target</code> ，返回可能的方式(从总共 <code>k^n</code> 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 <code>target</code> 。</p><p>答案可能很大，你需要对 <code>10^9 + 7</code> <strong>取模</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 1, k = 6, target = 3<br>输出：1<br>解释：你扔一个有6张脸的骰子。<br>得到3的和只有一种方法。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 2, k = 6, target = 7<br>输出：6<br>解释：你扔两个骰子，每个骰子有6个面。<br>得到7的和有6种方法1+6 2+5 3+4 4+3 5+2 6+1。<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong> 分组背包 组合问题外层循环背包组数 i</p><p>内层循环 值 和 target，内层 是0/1背包问题</p></blockquote><p>外层 筛子个数 i</p><p>第二层 每一面的值 num</p><p>第三层  总点数target j</p><p>dp[i][j] 前i个骰子总点数为j的不同组合个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][target+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; num &lt;= k; num++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;=num ; j--) &#123;<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][j-num];<br>                    dp[i][j] %= MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numRollsToTarget</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span>, target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        dp = [[<span class="hljs-number">0</span>]*(target+<span class="hljs-number">1</span>)]*(n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target,num-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][j-num]<br>                    dp[i][j] %= <span class="hljs-number">1000000007</span><br>            <br>        <span class="hljs-keyword">return</span> dp[n][target]<br></code></pre></td></tr></table></figure><blockquote><p>关于为什么取模 1e9 + 7：简单来说就是：</p><p>取模防止大数运算出现 overflow<br>为什么取 1e9 + 7 等 prime number 记为 P，可以减少实际答案 A mapping 到 A mod P 的碰撞率。 我们约定认为， 如果你 A mod P 如果是对的，那么你算出的 A 也是对的。还有就是，对于参赛选手来说，这个数好记，不容易出现手误之类的；更详细的 digging 看下面的链接：</p><p>作者：maverickbytes<br>链接：<a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/solution/zuo-ti-guo-cheng-ji-lu-dpjie-fa-by-maverickbytes/">https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/solution/zuo-ti-guo-cheng-ji-lu-dpjie-fa-by-maverickbytes/</a></p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">代码随想录 (programmercarl.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/">一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现） - 最后一块石头的重量 II - 力扣（LeetCode） (leetcode-cn.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|数据结构</title>
      <link href="/augu1sto/e4258a2f9770/"/>
      <url>/augu1sto/e4258a2f9770/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50e446/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p>[TOC]</p><h2 id="数组">数组<a class="header-anchor" href="#数组">⁍</a></h2><h3 id="数组-2">数组<a class="header-anchor" href="#数组-2">⁍</a></h3><h3 id="可变数组">可变数组<a class="header-anchor" href="#可变数组">⁍</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化可变数组</span><br>List&lt;Integer&gt; array = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-comment">// 向尾部添加元素</span><br>array.add(<span class="hljs-number">2</span>);<br>array.add(<span class="hljs-number">3</span>);<br>array.add(<span class="hljs-number">1</span>);<br>array.add(<span class="hljs-number">0</span>);<br>array.add(<span class="hljs-number">2</span>);<br><br></code></pre></td></tr></table></figure><h2 id="链表">链表<a class="header-anchor" href="#链表">⁍</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;       <span class="hljs-comment">// 节点值</span><br>    ListNode next; <span class="hljs-comment">// 后继节点引用</span><br>    ListNode(<span class="hljs-keyword">int</span> x) &#123; <span class="hljs-comment">// 初始化节点</span><br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化节点</span><br>ListNode n1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>); <span class="hljs-comment">// 节点 head</span><br>ListNode n2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>ListNode n3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1.next = n2;<br>n2.next = n3;<br><br><br></code></pre></td></tr></table></figure><h2 id="栈">栈<a class="header-anchor" href="#栈">⁍</a></h2><p>先入后出</p><p>注意：通常情况下，不推荐使用 Java 的 Vector 以及其子类 Stack ，而一般将 LinkedList 作为栈来使用。详细说明请见：<a href="https://blog.csdn.net/cartoon_/article/details/87992743">Stack，ArrayDeque，LinkedList 的区别</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br>LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>stack.addLast(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 元素 1 入栈</span><br>stack.addLast(<span class="hljs-number">2</span>);   <span class="hljs-comment">// 元素 2 入栈</span><br>stack.add(element); <span class="hljs-comment">// 入栈并返回true</span><br>stack.offer(element); <span class="hljs-comment">// 常用</span><br><br><br><span class="hljs-number">2</span>=stack.removeLast(); <span class="hljs-comment">// 出栈 -&gt; 元素 2</span><br><span class="hljs-number">1</span>=stack.removeLast(); <span class="hljs-comment">// 出栈 -&gt; 元素 1</span><br>element=stack.pollLast(); <span class="hljs-comment">//如果此列表为空，则返回null。</span><br>e = stack.poll(); <span class="hljs-comment">// 常用</span><br><span class="hljs-comment">//element=stack.pop();是去出第一个数 </span><br><br><span class="hljs-comment">//取栈顶</span><br>top=stack.getLast(); <span class="hljs-comment">//出错会抛出异常</span><br>top=stack.peekLast();<br><br></code></pre></td></tr></table></figure><p>（更常用）另一种写法：用Deque（都是从List第一个元素开始进行操作，和上面的是倒着的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; mono_stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;Integer&gt;();<br><br>e=mono_stack.pop();<span class="hljs-comment">//出栈</span><br>mono_stack.push(e);<span class="hljs-comment">//入栈</span><br>e=mono_stack.peek();<span class="hljs-comment">//取栈顶</span><br></code></pre></td></tr></table></figure><h2 id="队列">队列<a class="header-anchor" href="#队列">⁍</a></h2><p>先入先出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>queue.offer(<span class="hljs-number">1</span>); <span class="hljs-comment">// 元素 1 入队</span><br>queue.offer(<span class="hljs-number">2</span>); <span class="hljs-comment">// 元素 2 入队</span><br>queue.poll();   <span class="hljs-comment">// 出队 -&gt; 元素 1</span><br>queue.poll();   <span class="hljs-comment">// 出队 -&gt; 元素 2</span><br><br><br></code></pre></td></tr></table></figure><h2 id="树">树<a class="header-anchor" href="#树">⁍</a></h2><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;        <span class="hljs-comment">// 节点值</span><br>    TreeNode left;  <span class="hljs-comment">// 左子节点</span><br>    TreeNode right; <span class="hljs-comment">// 右子节点</span><br>    TreeNode(<span class="hljs-keyword">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化节点</span><br>TreeNode n1 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>); <span class="hljs-comment">// 根节点 root</span><br>TreeNode n2 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>);<br>TreeNode n3 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>);<br>TreeNode n4 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">1</span>);<br>TreeNode n5 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1.left = n2;<br>n1.right = n3;<br>n2.left = n4;<br>n2.right = n5;<br><br><br></code></pre></td></tr></table></figure><h2 id="图">图<a class="header-anchor" href="#图">⁍</a></h2><p>图是一种非线性数据结构，由「节点（顶点）vertex」和「边 edge」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。</p><h3 id="无向图">无向图<a class="header-anchor" href="#无向图">⁍</a></h3><ol><li><p><strong>邻接矩阵</strong></p><p>$edges[i][j]$ 代表节点 $i+1$ 和 节点 $j+1$ 之间是否有边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] vertices = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[][] edges = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>                 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>                 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>                 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>                 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>邻接表</strong></p><p>$edges$ 为一个二维容器，第一维 $i$ 代表顶点索引，第二维 $edges[i]$ 存储此顶点对应的边集和；例如$edges[0] = [1, 2, 3, 4]$代表 $vertices[0]$ 的边集合为$[1, 2, 3, 4]$ 。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112191619989.png" alt="image-20211219161907910"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] vertices = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>List&lt;List&lt;Integer&gt;&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>List&lt;Integer&gt; edge_1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br>List&lt;Integer&gt; edge_2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>));<br>List&lt;Integer&gt; edge_3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>));<br>List&lt;Integer&gt; edge_4 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>List&lt;Integer&gt; edge_5 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>edges.add(edge_1);<br>edges.add(edge_2);<br>edges.add(edge_3);<br>edges.add(edge_4);<br>edges.add(edge_5);<br><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>邻接矩阵 VS 邻接表 ：</p><p>邻接矩阵的大小只与节点数量有关，即 $N^2$，其中 $N$ 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。因此， <strong>邻接矩阵</strong> 适合存储稠密图（顶点较少、边较多）；<strong>邻接表</strong> 适合存储稀疏图（顶点较多、边较少）。</p></blockquote><h2 id="散列表">散列表<a class="header-anchor" href="#散列表">⁍</a></h2><p>非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化散列表</span><br>Map&lt;String, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br><span class="hljs-comment">// 添加 key -&gt; value 键值对</span><br>dic.put(<span class="hljs-string">&quot;小力&quot;</span>, <span class="hljs-number">10001</span>);<br>dic.put(<span class="hljs-string">&quot;小特&quot;</span>, <span class="hljs-number">10002</span>);<br>dic.put(<span class="hljs-string">&quot;小扣&quot;</span>, <span class="hljs-number">10003</span>);<br><br><span class="hljs-comment">// 从姓名查找学号</span><br>dic.get(<span class="hljs-string">&quot;小力&quot;</span>); <span class="hljs-comment">// -&gt; 10001</span><br>dic.get(<span class="hljs-string">&quot;小特&quot;</span>); <span class="hljs-comment">// -&gt; 10002</span><br>dic.get(<span class="hljs-string">&quot;小扣&quot;</span>); <span class="hljs-comment">// -&gt; 10003</span><br><br><span class="hljs-comment">// 常用判断是否存在键的同时更新键</span><br><span class="hljs-keyword">int</span> k = dic.getOrDefault(key,<span class="hljs-number">0</span>);<br>dic.put(key, k+<span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><h2 id="堆">堆<a class="header-anchor" href="#堆">⁍</a></h2><p>堆是一种基于「完全二叉树」的数据结构，可使用<strong>数组</strong>实现。</p><p>以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。</p><p>堆分为「大顶堆」和「小顶堆」，</p><p>大顶堆就是根节点最大小顶堆就是根节点最小</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203131713143.png" alt="Picture9.png"></p><blockquote><p><strong>完全二叉树定义：</strong> 设二叉树深度为 $k$</p><ul><li>除第 $k$ 层外的其它各层（第 $1$ 至 $k-1$ 层）的节点达到最大个数</li><li>处于第 $k$ 层的节点都连续集中在最左边，</li></ul><p>则称此二叉树为完全二叉树。</p></blockquote><p>通过使用「优先队列」的「压入 <code>push()</code>」和「弹出 <code>pop()</code>」操作，即可完成堆排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化小顶堆</span><br>Queue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br><br><span class="hljs-comment">// 元素入堆</span><br>heap.offer(<span class="hljs-number">1</span>);<br>heap.offer(<span class="hljs-number">4</span>);<br>heap.offer(<span class="hljs-number">2</span>);<br>heap.offer(<span class="hljs-number">6</span>);<br>heap.offer(<span class="hljs-number">8</span>);<br><br><span class="hljs-comment">// 元素出堆（从小到大）</span><br>heap.poll(); <span class="hljs-comment">// -&gt; 1</span><br>heap.poll(); <span class="hljs-comment">// -&gt; 2</span><br>heap.poll(); <span class="hljs-comment">// -&gt; 4</span><br>heap.poll(); <span class="hljs-comment">// -&gt; 6</span><br>heap.poll(); <span class="hljs-comment">// -&gt; 8</span><br><br><br></code></pre></td></tr></table></figure><p>大顶堆的实现</p><ul><li><p>自定义排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);<br><br></code></pre></td></tr></table></figure></li><li><p>小顶堆取负</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo美化|站宠？看板娘？live2d配置（附魔改插件和新模型）</title>
      <link href="/augu1sto/ee36c104ddd2/"/>
      <url>/augu1sto/ee36c104ddd2/</url>
      
        <content type="html"><![CDATA[<h2 id="效果">效果<a class="header-anchor" href="#效果">⁍</a></h2><p>见本站右下角</p><h2 id="实现目标">实现目标<a class="header-anchor" href="#实现目标">⁍</a></h2><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 采用<code>hexo-helper-live2d</code>插件实现，参考 <a href="https://huaji8.top/post/live2d-plugin-2.0/">hexo live2d插件 2.0 ! | 幻想帖 (huaji8.top)</a></li><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 配置添加对话/文字功能</li><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 修改为自己想要的live2d形象（<a href="https://github.com/Eikanya/Live2d-model">Eikanya/Live2d-model: Live2d model collection (github.com)</a>，<a href="https://mx.paul.ren/page/1/">梦象 (paul.ren)</a>）</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 和音乐播放器合在一起？（暂不考虑）</li></ul><h2 id="hexo-helper-live2d插件安装与配置"><code>hexo-helper-live2d</code>插件安装与配置<a class="header-anchor" href="#hexo-helper-live2d插件安装与配置">⁍</a></h2><p><a href="https://github.com/EYHN/hexo-helper-live2d">EYHN/hexo-helper-live2d: Add the Sseexxyyy live2d to your hexo! (github.com)</a></p><h3 id="安装插件">安装插件<a class="header-anchor" href="#安装插件">⁍</a></h3><p>在站点根目录下打开终端，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-helper-live2d<br></code></pre></td></tr></table></figure><h3 id="选择并安装模型">选择并安装模型<a class="header-anchor" href="#选择并安装模型">⁍</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save live2d-widget-model-wanko<br></code></pre></td></tr></table></figure><p>更多模型见<a href="https://huaji8.top/post/live2d-plugin-2.0/">hexo live2d插件 2.0 ! | 幻想帖 (huaji8.top)</a></p><h3 id="配置">配置<a class="header-anchor" href="#配置">⁍</a></h3><p>打开站点配置文件<code>_config.yml</code>，添加live2d项，如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># live2d</span><br><span class="hljs-comment"># https://github.com/EYHN/hexo-helper-live2d</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否启用看板娘</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)，自动生成</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-comment"># scriptFrom: jsdelivr    # jsdelivr CDN</span><br>  <span class="hljs-comment"># scriptFrom: unpkg    # unpkg CDN</span><br>  <span class="hljs-comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js    # 你的自定义 url</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中，具体见项目github描述</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-wanko</span> <span class="hljs-comment"># live2d模型的名字</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span><br>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">200</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">400</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">left</span> <span class="hljs-comment"># 左侧还是右侧</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 距底部距离</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 手机端是否可见</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">0.5</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacityDefault:</span> <span class="hljs-number">0.7</span><br>    <span class="hljs-attr">opacityOnHover:</span> <span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><p>然后<code>hexo cl&amp;&amp;hexo g&amp;&amp;hexo s</code>就可以在<code>localhost:4000</code>上预览效果啦</p><h2 id="添加文字框功能">添加文字框功能<a class="header-anchor" href="#添加文字框功能">⁍</a></h2><h3 id="浮现hitokoto文字">浮现hitokoto文字<a class="header-anchor" href="#浮现hitokoto文字">⁍</a></h3><blockquote><p><a href="https://developer.hitokoto.cn/sentence/#%E7%AE%80%E4%BB%8B">语句接口 | 一言开发者中心 (hitokoto.cn)</a>简而言之就是提供了一个api接口<a href="https://v1.hitokoto.cn/">https://v1.hitokoto.cn</a>，可以返回一句话</p></blockquote><p>参考<a href="https://github.com/EYHN/hexo-helper-live2d/issues/137">关于waifu-tips.js · Issue #137 · EYHN/hexo-helper-live2d (github.com)</a></p><p>其实再简单不过，就是在<code>_config.yml</code>中添加几行文字：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">dialog:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">hitokoto:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>就可以将hitokoto上的一句话显示在你的live2d形象上方</p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112151801757.png" alt="image-20211215180136670" style="zoom:50%;" /><blockquote><h4 id="一些蠢事带来的js脚本调试的尝试记录">一些蠢事带来的js脚本调试的尝试记录<a class="header-anchor" href="#一些蠢事带来的js脚本调试的尝试记录">⁍</a></h4><p>改完配置之后，设置迟迟没有生效，看了看几个主要的脚本似乎也没什么问题，于是本人初尝了以下js调试。（省略一些绕弯路的步骤）</p><ul><li><p><code>hexo s</code>之后，打开<code>localhost:4000</code></p></li><li><p>打开开发者模式-源代码，（省略一些搜索<code>dial..</code>的步骤），打开了<code>webpack://./src/utils/elementMgr.js</code>文件（也不一定是这个）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112151808722.png" alt="image-20211215180805667"></p></li><li><p>设置断点，刷新</p></li><li><p>鼠标放在<code>config</code>上，同志们。。我打错变量名了。。是<code>dialog</code>不是<code>dialogue</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112151810626.png" alt="image-20211215181008563"></p></li></ul><p>被自己蠢到，但也算尝试了一下调试的基础。。嗯。。</p></blockquote><h3 id="自定义文本">自定义文本<a class="header-anchor" href="#自定义文本">⁍</a></h3><h4 id="解决方案">解决方案<a class="header-anchor" href="#解决方案">⁍</a></h4><ul><li><p>修改配置文件<code>_config.yml</code></p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否启用看板娘</span><br>  <span class="hljs-attr">dialog:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># hitokoto: true</span><br>    <span class="hljs-attr">text:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">汪</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">汪汪</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">汪呜</span><br></code></pre></td></tr></table></figure><p>这里的<code>text</code>变量名随便起，只要跟后面的<code>config.dialog.text</code>对应即可</p></li><li><p><code>[Blogroot]\node_modules\live2d-widget\src\dialog\index.js</code>，添加函数</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomSelection</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(obj) ? obj[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * obj.length)] : obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params">text, timeout, priority</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!text || (sessionStorage.getItem(<span class="hljs-string">&quot;mytext&quot;</span>) &amp;&amp; sessionStorage.getItem(<span class="hljs-string">&quot;mytext&quot;</span>) &gt; priority)) <span class="hljs-keyword">return</span>;<br>  text = randomSelection(text);<br>  sessionStorage.setItem(<span class="hljs-string">&quot;mytext&quot;</span>, priority);<br>  alertText(text)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    sessionStorage.removeItem(<span class="hljs-string">&quot;mytext&quot;</span>);<br>  &#125;, timeout);<br>&#125;<br></code></pre></td></tr></table></figure><p>并添加对此函数的调用</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDialogElement</span>(<span class="hljs-params">root</span>) </span>&#123;<br><span class="hljs-comment">// ......</span><br><br>  <span class="hljs-keyword">if</span> (config.dialog.hitokoto)<br>    showHitokotoLoop()<br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">//从这里开始增加</span><br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      showMessage(randomSelection(config.dialog.text), <span class="hljs-number">4000</span>, <span class="hljs-number">9</span>);<br>  &#125;, <span class="hljs-number">10000</span>)<span class="hljs-comment">//增加了这一行</span><br>&#125;<br><br><span class="hljs-comment">//......</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  createDialogElement, displayDialog, hiddenDialog, alertText, showHitokotoLoop, showMessage, randomSelection<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>webpack打包</p><ul><li><p>在<code>live2d-widget</code>下安装<code>webpack</code>包： <code>npm install --save-dev webpack@3.10.0</code></p><ul><li><code>webpack</code>版本很重要，参考<code>.\live2d-widget\package.json</code></li></ul></li><li><p>命令行输入<code>./node_modules/.bin/webpack</code></p><blockquote><p>讲道理可以照<code>package.json</code>的提示输入，<code>npm run build:prod</code>之类的命令，但会报错（应该改改路径就可以了？）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112152136660.png" alt="image-20211215213625610"></p></blockquote></li></ul></li><li><p>成功啦</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112152141019.png" alt="image-20211215214104966"></p></li></ul><h4 id="过程：阅读源码并修改">过程：阅读源码并修改<a class="header-anchor" href="#过程：阅读源码并修改">⁍</a></h4><p><a href="https://github.com/EYHN/hexo-helper-live2d/issues/137">关于waifu-tips.js · Issue #137 · EYHN/hexo-helper-live2d (github.com)</a>这个issue中并没有提及如何自定义文本的问题，于是就先来读一读源码</p><p>有关对话框的源代码在<code>[Blogroot]\node_modules\live2d-widget\src\dialog\index.js</code>下</p><p><code>_config.yml</code>里的设置经过一系列传参到<code>index.js</code>中，变成了<code>config</code>对象</p><p>当你按下述设置时，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">dialog:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hitokoto:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>传到<code>index.js</code>中，使得<code>config.dialog.enable</code>和<code>config.dialog.hitokoto</code>都变为了<code>true</code></p><p>因此</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDialogElement</span>(<span class="hljs-params">root</span>) </span>&#123;<br><span class="hljs-comment">// ......</span><br><br>  <span class="hljs-keyword">if</span> (config.dialog.hitokoto) showHitokotoLoop()<br>&#125;<br></code></pre></td></tr></table></figure><p>就调用了<code>showHitokotoLoop()</code>函数，因此我们首先要做的是将<code>hitokoto: true</code>改为<code>false</code>，由于默认值就是<code>false</code>（见<code>.\live2d-widget\src\index.js</code>注释和<code>.\live2d-widget\src\config\defaultConfig.js</code>的默认设置），因此删掉这句话就可以了</p><p>我们知道函数<code>showHitokotoLoop()</code>调用了<code>alertText(text)</code>函数，将<code>data.hotokoto</code>当作<code>text</code>参数传入</p><p>因此如果要自定义文本，只需要将我们的文本作为<code>text</code>传入即可</p><p>于是开始魔改（x），见上一小节</p><p>参考了<a href="https://github.com/stevenjoezhang/live2d-widget/blob/master/waifu-tips.js">live2d-widget/waifu-tips.js at master · stevenjoezhang/live2d-widget · GitHub</a></p><p>事实上可以看看<code>butterfly</code>主题中对<code>subtitle</code>的处理，还可以增加调用其他api的方法，这里就不加了。</p><blockquote><p>原项目archived了，所以大家看着改改就好，重要的是方法</p></blockquote><h2 id="修改为自己想要的live2d图像">修改为自己想要的live2d图像<a class="header-anchor" href="#修改为自己想要的live2d图像">⁍</a></h2><h3 id="选择想要的live2d形象">选择想要的live2d形象<a class="header-anchor" href="#选择想要的live2d形象">⁍</a></h3><p>这里在<a href="https://github.com/Eikanya/Live2d-model">Eikanya/Live2d-model: Live2d model collection (github.com)</a>中进行选择</p><blockquote><p>众所周知，邦邦有邦邦人制作的神器 <a href="https://bestdori.com/tool/live2d">Live2D浏览器 | Bestdori! BanG Dream 少女乐团派对的最佳资源库</a>，可以查看相应活动的live2d形象</p><ul><li><p>方法一：可以在上面的github库中的邦邦文件夹的1~35分别代表的各个角色，比如户川香澄就是1，<code>[001_live_event_102_ssr](https://github.com/Eikanya/Live2d-model/tree/master/BanG Dream!/asneeded/live2d/chara/001/001_live_event_102_ssr)</code>就是第102次活动的ssr卡</p></li><li><p>方法二：该github库到炮姐联动之后就没有更新了，但是我们有bestdori!在 <a href="https://bestdori.com/tool/live2d">Live2D浏览器</a>中点击左上角<i class="fa fa-info" aria-hidden="true"></i>可以直接获得卡面路径</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112161051329.png" alt="image-20211216105117962"></p><p>然后去<a href="https://bestdori.com/tool/explorer/asset">数据包浏览器</a>里找到相应路径就可以下载了，是不是很简单，快去试试吧！</p></li></ul></blockquote><h3 id="配置动作">配置动作<a class="header-anchor" href="#配置动作">⁍</a></h3><p><a href="https://live2d.pavostudio.com/doc/zh-cn/live2d/model-config/">Json配置 - Live2DViewerEX文档 (pavostudio.com)</a></p><p>问题：不知道模型建立的时候的区域ID，没办法设置<code>hit_area</code>，js代码里也没有对于<code>tap</code>的单独设置，因此只能把动作全部加到<code>json</code>文件里</p><blockquote><p>moc文件用二进制形式打开，发现都是用<code>D_PSD_XXX</code>的形式命名的，就不知道哪个是头那个是身子。。</p></blockquote><p>打包的文件已经用npm发布</p><p>可以用命令<code>npm install live2d-widget-model-kasumi</code>安装</p><h2 id="后续">后续<a class="header-anchor" href="#后续">⁍</a></h2><p>这个插件功能还是弱了一点，因为本人对js也不是特别数，后面可能会对项目<a href="https://github.com/stevenjoezhang/live2d-widget">stevenjoezhang/live2d-widget: 把萌萌哒的看板娘抱回家 (ノ≧∇≦)ノ | Live2D widget for web platform (github.com)</a>魔改</p>]]></content>
      
      
      <categories>
          
          <category> Hexo建站与美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Qt|pyside|python GUI开发】Qt for Python安装</title>
      <link href="/augu1sto/af1ade3bed66/"/>
      <url>/augu1sto/af1ade3bed66/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考官网文档 <a href="https://doc.qt.io/qtforpython/quickstart.html">https://doc.qt.io/qtforpython/quickstart.html</a></p><p>Qt for python官方文档： <a href="https://doc.qt.io/qtforpython/contents.html">Qt for Python Documentation</a></p><p><a href="https://www.perfcode.com/p/pip-install-pyside6.html">使用pip安装PySide6 - 完美代码 (perfcode.com)</a></p></blockquote><p><mark>还是决定先用electron-vue</mark>技术栈，暂时不会更了</p><h2 id="环境要求">环境要求<a class="header-anchor" href="#环境要求">⁍</a></h2><ul><li>Python 3.6+</li><li>官网推荐使用虚拟环境，本文在anaconda下创建</li></ul><h2 id="安装">安装<a class="header-anchor" href="#安装">⁍</a></h2><ul><li><p>创建虚拟环境</p><p>在anaconda prompt中输入以下命令</p><ul><li><code>conda create -n myqt python=3.6.5</code></li><li><code>conda activate myqt</code></li></ul></li><li><p>安装<code>pyside6</code>（pip）</p><blockquote><p>为了防止下载速度过慢，建议配置镜像源</p></blockquote><ul><li><s>conda</s>(conda暂时好像下不了)</li><li>pip：<code>pip install pyside6</code></li></ul></li><li><p>测试是否安装成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> PySide6.QtCore<br><br><span class="hljs-comment"># Prints PySide6 version</span><br><span class="hljs-built_in">print</span>(PySide6.__version__)<br><br><span class="hljs-comment"># Prints the Qt version used to compile PySide6</span><br><span class="hljs-built_in">print</span>(PySide6.QtCore.__version__)<br></code></pre></td></tr></table></figure><p>我是6.2.2版本</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112141137247.png" alt="image-20211214113724163"></p></li></ul><h2 id="在pycharm里配置qt-desinger">在pycharm里配置qt desinger<a class="header-anchor" href="#在pycharm里配置qt-desinger">⁍</a></h2><p>PySide6的安装路径一般是<code>[python路径]\Lib\site-packages\PySide6</code>，由于我是装在conda的虚拟环境下的，路径则为虚拟环境下的路径，一般是<code>C:\Users\[用户名]\.conda\envs\[虚拟环境名]\Lib\site-packages\PySide6</code></p><p>此目录下可以找到 designer.exe，建议发送快捷方式到桌面或者固定到开始菜单以便迅速定位。</p><p>在PyCharm中点击<code>设置</code>-<code>工具</code>-<code>外部工具</code>，点<code>+</code>创建工具。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112141541700.png" alt="image-20211214154137595"></p><ul><li><p><code>程序</code>： designer.exe 的路径</p></li><li><p><code>工作目录</code>: 设置保存的 UI 文件位置，可以点右边的加号添加宏，图中所示的表示存储在project底下的ui文件夹底下</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python GUI开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Qt </tag>
            
            <tag> pyside </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（二）| 面向对象基础</title>
      <link href="/augu1sto/3043589ab29c/"/>
      <url>/augu1sto/3043589ab29c/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介<a class="header-anchor" href="#简介">⁍</a></h2><ul><li><p>类 <code>class</code></p></li><li><p>字段 <code>field</code></p></li><li><p>实例 <code>instance</code></p><ul><li><p>创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Person ming = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><p><code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例。</p></li></ul></li><li><p><mark>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中</mark></p></li></ul><h2 id="方法">方法<a class="header-anchor" href="#方法">⁍</a></h2><p>直接把<code>field</code>用<code>public</code>暴露给外部可能会破坏封装性。</p><p>为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问。</p><p>然后使用方法（<code>method</code>）来让外部代码可以间接修改<code>field</code>外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p><p>对<code>setName()</code>方法同样可以做检查，例如，不允许传入<code>null</code>和空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || name.isBlank()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;invalid name&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.name = name.strip(); <span class="hljs-comment">// 去掉首尾空格</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样，外部代码不能直接读取<code>private</code>字段，但可以通过<code>getName()</code>和<code>getAge()</code>间接获取<code>private</code>字段的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> calcAge(<span class="hljs-number">2019</span>); <span class="hljs-comment">// 调用private方法</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="this变量">this变量<a class="header-anchor" href="#this变量">⁍</a></h3><p>如果没有命名冲突，可以省略<code>this</code>。</p><h3 id="可变参数">可变参数<a class="header-anchor" href="#可变参数">⁍</a></h3><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String[] names;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNames</span><span class="hljs-params">(String... names)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.names = names;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么不用数组<code>Sting[]</code>类型：</p><ul><li>调用方需要自己先构造<code>String[]</code>，比较麻烦。而可变参数不用</li><li>可变参数可以保证无法传入<code>null</code>，因为传入0个参数时，接收到的实际值是一个空数组而不是<code>null</code></li></ul></blockquote><h3 id="参数绑定">参数绑定<a class="header-anchor" href="#参数绑定">⁍</a></h3><ul><li>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。</li><li>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Person();<br>        String bob = <span class="hljs-string">&quot;Bob&quot;</span>;<br>        p.setName(bob); <span class="hljs-comment">// 传入bob变量</span><br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Bob&quot;</span><br>        bob = <span class="hljs-string">&quot;Alice&quot;</span>; <span class="hljs-comment">// bob改名为Alice</span><br>        System.out.println(p.getName()); <span class="hljs-comment">// 依旧是&quot;Bob&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上述<strong>特例</strong>中，line7的时候给<code>String</code>类型赋值时，不是覆盖，会在内存中新开辟一个空间，bob的指向该变了。但是p.name还是指向原来的内存空间 还是Bob</p></blockquote><h2 id="构造方法">构造方法<a class="header-anchor" href="#构造方法">⁍</a></h2><p>通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建<code>Person</code>实例的时候，一次性传入<code>name</code>和<code>age</code>，完成初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">15</span>);<br>        System.out.println(p.getName());<br>        System.out.println(p.getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123; <span class="hljs-comment">//构造方法</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有<code>void</code>），调用构造方法，必须用<code>new</code>操作符。</p><p>既对字段进行初始化，又在构造方法中对字段进行初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Person &#123;<br>    private String name = &quot;Unamed&quot;;<br>    private int age = 10;<br><br>    public Person(String name, int age) &#123;<br>        this.name = name;<br>        this.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;Unamed&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ol><li>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为<code>10</code>，<code>double salary;</code>表示字段默认初始化为<code>0</code>，<code>String name;</code>表示引用类型字段默认初始化为<code>null</code>；</li><li>执行构造方法的代码进行初始化。</li></ol><p>因此，构造方法的代码由于后运行，所以，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>的字段值最终由构造方法的代码确定。</p><h3 id="多构造方法">多构造方法<a class="header-anchor" href="#多构造方法">⁍</a></h3><p>可以定义多个构造方法，在通过<code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">12</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(name, <span class="hljs-number">18</span>); <span class="hljs-comment">// 调用另一个构造方法Person(String, int)</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Unnamed&quot;</span>); <span class="hljs-comment">// 调用另一个构造方法Person(String)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法重载">方法重载<a class="header-anchor" href="#方法重载">⁍</a></h2><p>这种方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）。</p><p>注意：方法重载的返回值类型通常都是相同的。</p><h2 id="继承">继承<a class="header-anchor" href="#继承">⁍</a></h2><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p><p>Java使用<code>extends</code>关键字来实现继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;...&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 不要重复name和age字段/方法,</span><br>    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123; … &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span> </span>&#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，通过继承，<code>Student</code>只需要编写额外的功能，不再需要重复代码。</p><p><mark>子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</mark></p><blockquote><p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）。</p></blockquote><h3 id="protected">protected<a class="header-anchor" href="#protected">⁍</a></h3><p>子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。</p><p>但<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问</p><h3 id="super">super<a class="header-anchor" href="#super">⁍</a></h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。</p><p>实际上，有的时候使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p><p>但是，在某些时候，就必须使用<code>super</code>。</p><p>在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code></p><p><mark>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</mark></p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> score)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age); <span class="hljs-comment">// 调用父类的构造方法Person(String, int)</span><br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还顺带引出了另一个问题：即子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><h3 id="阻止继承">阻止继承<a class="header-anchor" href="#阻止继承">⁍</a></h3><p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p><p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p><p>例如，定义一个<code>Shape</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> sealed <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> <span class="hljs-title">permits</span> <span class="hljs-title">Rect</span>, <span class="hljs-title">Circle</span>, <span class="hljs-title">Triangle</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。如果写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>是没问题的，因为<code>Rect</code>出现在<code>Shape</code>的<code>permits</code>列表中。</p><blockquote><p>这种<code>sealed</code>类主要用于一些框架，防止继承被滥用。</p><p><code>sealed</code>类在Java 15中目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code>。</p></blockquote><h3 id="向上转型与向下转型">向上转型与向下转型<a class="header-anchor" href="#向上转型与向下转型">⁍</a></h3><h4 id="向上转型upcasting">向上转型upcasting<a class="header-anchor" href="#向上转型upcasting">⁍</a></h4><p><code>Student</code>是从<code>Person</code>继承下来的，即继承树是<code>Student &gt; Person &gt; Object</code>，则可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Student(); <br></code></pre></td></tr></table></figure><h4 id="向下转型downcasting">向下转型downcasting<a class="header-anchor" href="#向下转型downcasting">⁍</a></h4><p>把一个父类类型强制转型为子类类型</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Student();<br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Student) &#123;<br>    <span class="hljs-comment">// 只有判断成功才会向下转型:</span><br>    Student s = (Student) p; <span class="hljs-comment">// 一定会成功</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。</p><h2 id="多态">多态<a class="header-anchor" href="#多态">⁍</a></h2><h3 id="覆写override">覆写override<a class="header-anchor" href="#覆写override">⁍</a></h3><p>如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p><p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。</p><ul><li><p>在必要的情况下，我们可以覆写<code>Object</code>的个方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 显示更有意义的字符串:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person:name=&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-comment">// 比较是否相等:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">// 当且仅当o为Person类型:</span><br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            Person p = (Person) o;<br>            <span class="hljs-comment">// 并且name字段相同时，返回true:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算hash:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p></li></ul><h3 id="多态polymorphic">多态Polymorphic<a class="header-anchor" href="#多态polymorphic">⁍</a></h3><p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p><p>这个非常重要的特性在面向对象编程中称之为多态，即针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p><h3 id="final">final<a class="header-anchor" href="#final">⁍</a></h3><ul><li><p>final修饰的方法可以阻止被覆写；</p><p>final修饰的class可以阻止被继承；</p><p>final修饰的field必须在创建对象时初始化，随后不可修改。</p></li></ul><h2 id="面向抽象编程：抽象类">面向抽象编程：抽象类<a class="header-anchor" href="#面向抽象编程：抽象类">⁍</a></h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h2 id="接口">接口<a class="header-anchor" href="#接口">⁍</a></h2><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//不用加public？</span><br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p></li><li><p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span>, <span class="hljs-title">Hello</span> </span>&#123; <span class="hljs-comment">// 实现了两个interface</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code></p></li></ul><h3 id="相关术语">相关术语<a class="header-anchor" href="#相关术语">⁍</a></h3><p>注意区分术语：</p><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p><p>抽象类和接口的对比如下：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">abstract class</th><th style="text-align:left">interface</th></tr></thead><tbody><tr><td style="text-align:left">继承</td><td style="text-align:left">只能extends一个class</td><td style="text-align:left">可以implements多个interface</td></tr><tr><td style="text-align:left">字段</td><td style="text-align:left">可以定义实例字段</td><td style="text-align:left">不能定义实例字段</td></tr><tr><td style="text-align:left">抽象方法</td><td style="text-align:left">可以定义抽象方法</td><td style="text-align:left">可以定义抽象方法</td></tr><tr><td style="text-align:left">非抽象方法</td><td style="text-align:left">可以定义非抽象方法</td><td style="text-align:left">可以定义default方法</td></tr></tbody></table><h3 id="default方法">default方法<a class="header-anchor" href="#default方法">⁍</a></h3><p>在接口中，可以定义<code>default</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br>        p.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//default方法</span><br>        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;<span class="hljs-comment">//实现类可以不必覆写default方法。</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h2 id="静态字段和静态方法">静态字段和静态方法<a class="header-anchor" href="#静态字段和静态方法">⁍</a></h2><h3 id="静态字段">静态字段<a class="header-anchor" href="#静态字段">⁍</a></h3><p>用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p><p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。</p><p>==&gt; 无论修改哪个实例的静态字段，所有实例的静态字段都被修改了，原因是静态字段并不属于实例</p><p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。</p><p><mark>推荐用类名来访问静态字段</mark>。可以把静态字段理解为描述<code>class</code>本身的字段</p><h3 id="静态方法">静态方法<a class="header-anchor" href="#静态方法">⁍</a></h3><p>调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//静态方法</span><br>        Person.setNumber(<span class="hljs-number">99</span>);<br>        System.out.println(Person.number);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123; <span class="hljs-comment">//静态方法</span><br>        number = value;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p><p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p><p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</p><p>静态方法经常用于工具类。例如：</p><ul><li>Arrays.sort()</li><li>Math.random()</li></ul><p>静态方法也经常用于辅助方法。注意到Java程序的入口<code>main()</code>也是静态方法。</p><h3 id="接口的静态字段">接口的静态字段<a class="header-anchor" href="#接口的静态字段">⁍</a></h3><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。</p><p>但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型（编译器会自动把该字段变为<code>public static final</code>类型）</p><h2 id="包">包<a class="header-anchor" href="#包">⁍</a></h2><p><mark>注意要把包名写全，不能因为上一层目录一样就不写</mark></p><p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> package_name<br></code></pre></td></tr></table></figure><blockquote><p>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p></blockquote><ul><li>所有Java文件对应的目录层次要和包的层次一致。</li><li>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。</li><li>可以通过<code>import</code>导入类名，写的时候就可以忽略包名，直接写类名。<code>import package_name.*</code>表示导入所有类<ul><li>有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法<mark>很少用</mark></li></ul></li></ul><p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。<mark>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</mark></li></ul><p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p><h3 id="最佳实践-倒置域名">最佳实践-倒置域名<a class="header-anchor" href="#最佳实践-倒置域名">⁍</a></h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><p>子包就可以根据功能自行命名。</p><p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p><ul><li>String</li><li>System</li><li>Runtime</li><li>…</li></ul><p>要注意也不要和JDK常用类重名：</p><ul><li>java.util.List</li><li>java.text.Format</li><li>java.math.BigInteger</li><li>…</li></ul><h2 id="修饰符与作用域">修饰符与作用域<a class="header-anchor" href="#修饰符与作用域">⁍</a></h2><ul><li>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</li><li><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；</li><li>一个<code>.java</code>文件只能包含一个<code>public</code>类(文件名必须和<code>public</code>类的名字相同)，但可以包含多个非<code>public</code>类。</li></ul><h3 id="public">public<a class="header-anchor" href="#public">⁍</a></h3><ul><li>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</li><li>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限</li></ul><h3 id="private">private<a class="header-anchor" href="#private">⁍</a></h3><ul><li>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问<ul><li><code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法</li></ul></li><li>如果一个类内部还定义了嵌套类（<code>nested class</code>），那么，嵌套类拥有访问<code>private</code>的权限</li></ul><h3 id="protected-2">protected<a class="header-anchor" href="#protected-2">⁍</a></h3><ul><li><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</li></ul><h3 id="package-缺省">package(缺省)<a class="header-anchor" href="#package-缺省">⁍</a></h3><p>最后，包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p><h3 id="final-2">final<a class="header-anchor" href="#final-2">⁍</a></h3><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><ul><li><code>final</code>修饰<code>class</code>可以阻止被继承</li><li><code>final</code>修饰<code>method</code>可以阻止被子类覆写</li><li><code>final</code>修饰<code>field</code>可以阻止被重新赋值</li><li><code>final</code>修饰局部变量可以阻止被重新赋值</li></ul><h3 id="最佳实践">最佳实践<a class="header-anchor" href="#最佳实践">⁍</a></h3><ul><li><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p></li><li><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p></li></ul><h2 id="内部类">内部类<a class="header-anchor" href="#内部类">⁍</a></h2><p>Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种：</p><ul><li>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有<code>Outer.this</code>实例，并拥有Outer Class的<code>private</code>访问权限；</li><li>Static Nested Class是独立类，但拥有Outer Class的<code>private</code>访问权限。</li></ul><p>要实例化一个<code>Inner</code>，我们必须首先创建一个<code>Outer</code>的实例，然后，调用<code>Outer</code>实例的<code>new</code>来创建<code>Inner</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Outer outer = <span class="hljs-keyword">new</span> Outer();<br>Outer.Inner inner = outer.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="匿名类anonymous-class">匿名类Anonymous Class<a class="header-anchor" href="#匿名类anonymous-class">⁍</a></h3><p>在类内部定义，但不需要明确定义，直接写就行了。定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-comment">// 实现必要的抽象方法...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>除了接口外，匿名类也完全可以继承自普通类。</p><h3 id="静态内部类static-nested-class">静态内部类Static Nested Class<a class="header-anchor" href="#静态内部类static-nested-class">⁍</a></h3><p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。</p><h2 id="classpath和jar">classpath和jar<a class="header-anchor" href="#classpath和jar">⁍</a></h2><h3 id="classpath">classpath<a class="header-anchor" href="#classpath">⁍</a></h3><ul><li><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><ul><li>Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</li><li>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来</li></ul></li><li><p><code>classpath</code>的设定方法有两种：</p><ul><li>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</li><li>在启动JVM时设置<code>classpath</code>变量，推荐。</li><li><mark>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包</mark>(换句话说一般不用管)</li></ul><p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello<br></code></pre></td></tr></table></figure><p>或者使用<code>-cp</code>的简写;</p><p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录;</p></li><li><p>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库</p></li></ul><h3 id="jar包">jar包<a class="header-anchor" href="#jar包">⁍</a></h3><p>把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件</p><p>实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -cp ./hello.jar abc.xyz.Hello<br></code></pre></td></tr></table></figure><p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p><h4 id="创建jar包">创建jar包<a class="header-anchor" href="#创建jar包">⁍</a></h4><p>找到相应文件夹压缩成zip，改后缀为jar就可以了</p><p>jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>等包</p><h4 id="maven">maven<a class="header-anchor" href="#maven">⁍</a></h4><p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。</p><p>JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java -jar hello.jar<br></code></pre></td></tr></table></figure><p>jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p><p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如==<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">Maven</a>==，可以非常方便地创建jar包。</p><h2 id="模块">模块<a class="header-anchor" href="#模块">⁍</a></h2><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题</p><p>了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>…</li></ul><p>模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。</p><p>所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”</p><h3 id="编写模块等">编写模块等<a class="header-anchor" href="#编写模块等">⁍</a></h3><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938">模块 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p><code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;<br><span class="hljs-keyword">requires</span> java.base; <span class="hljs-comment">// 可不写，任何模块都会自动引入java.base</span><br><span class="hljs-keyword">requires</span> java.xml;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是把在源码中 用到的模块/包都写在这里，及依赖关系</p><p>编译后存放到<code>bin</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java<br></code></pre></td></tr></table></figure><p>把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .<br></code></pre></td></tr></table></figure><p>以直接使用命令<code>java -jar hello.jar</code>来运行它，创建模块的话继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jmod create --class-path hello.jar hello.jmod<br></code></pre></td></tr></table></figure><h3 id="打包jre">打包JRE<a class="header-anchor" href="#打包jre">⁍</a></h3><p>裁剪JRE：<code>jilink</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jlink --module-path [指定模块].jmod --add-modules [java.base,用到的模块...] --output jre/<br></code></pre></td></tr></table></figure><p>在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p><p>在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jre/bin/java --module hello.world<br>Hello, xml!<br></code></pre></td></tr></table></figure><p>打包分发，对方不需要下载安装JDK，直接执行以上命令就可以</p><h3 id="访问权限">访问权限<a class="header-anchor" href="#访问权限">⁍</a></h3><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;<br>    <span class="hljs-keyword">exports</span> com.itranswarp.sample;<br><br>    <span class="hljs-keyword">requires</span> java.base;<br> <span class="hljs-keyword">requires</span> java.xml;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，模块进一步隔离了代码的访问权限。</p><h3 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h3><ul><li>打包模块：编写<code>module-info,java</code>;编译放入<code>bin/</code>底下,<code>.java</code>变<code>.class</code>;打包bin目录下class,转为<code>jmod</code>模块</li><li>打包jre：<code>jilink</code>命令</li></ul><hr><h2 id="idea打包编译方式">IDEA打包编译方式<a class="header-anchor" href="#idea打包编译方式">⁍</a></h2><p>文件-项目结构，选择相应模块-路径，选择输出路径</p><p>构建——构建模块（等一段时间）</p><p><a href="https://jingyan.baidu.com/article/00a07f3873fd0e82d128dc65.html">IntelliJ IDEA如何手动编译项目-百度经验 (baidu.com)</a></p><p>然后<a href="https://blog.csdn.net/shankezh/article/details/104967884">【工具】IDEA打包jar包_shankezh的博客-CSDN博客_idea打包工具</a></p><p>构建-构建工件</p>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习（一）| JAVA快速入门</title>
      <link href="/augu1sto/c18facb1815c/"/>
      <url>/augu1sto/c18facb1815c/</url>
      
        <content type="html"><![CDATA[<p>学习参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255883729079552">https://www.liaoxuefeng.com/wiki/1252599548343744/1255883729079552</a></p><p>只记录不熟悉/需要注意的部分</p><h2 id="数据类型">数据类型<a class="header-anchor" href="#数据类型">⁍</a></h2><p>Java基本数据类型占用的字节数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───┐<br>  byte │   │<br>       └───┘<br>       ┌───┬───┐<br> short │   │   │<br>       └───┴───┘<br>       ┌───┬───┬───┬───┐<br>   int │   │   │   │   │<br>       └───┴───┴───┴───┘<br>       ┌───┬───┬───┬───┬───┬───┬───┬───┐<br>  long │   │   │   │   │   │   │   │   │<br>       └───┴───┴───┴───┴───┴───┴───┴───┘<br>       ┌───┬───┬───┬───┐<br> float │   │   │   │   │<br>       └───┴───┴───┴───┘<br>       ┌───┬───┬───┬───┬───┬───┬───┬───┐<br>double │   │   │   │   │   │   │   │   │<br>       └───┴───┴───┴───┴───┴───┴───┴───┘<br>       ┌───┬───┐<br>  char │   │   │<br>       └───┴───┘<br>  boolean型不确定，理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数<br></code></pre></td></tr></table></figure><p><code>byte</code>恰好就是一个字节，而<code>long</code>和<code>double</code>需要8个字节。</p><h3 id="整型">整型<a class="header-anchor" href="#整型">⁍</a></h3><p>对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下：</p><ul><li>byte：-128 ~ 127</li><li>short: -32768 ~ 32767</li><li>int: -2147483648 ~ 2147483647</li><li>long: -9223372036854775808 ~ 9223372036854775807</li></ul><h3 id="浮点型">浮点型<a class="header-anchor" href="#浮点型">⁍</a></h3><p>对于<code>float</code>类型，需要加上<code>f</code>后缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> f2 = <span class="hljs-number">3.14e38f</span>; <span class="hljs-comment">// 科学计数法表示的3.14x10^38</span><br></code></pre></td></tr></table></figure><p>浮点数可表示的范围非常大，<code>float</code>类型可最大表示3.4x1038，而<code>double</code>类型可最大表示1.79x10308。</p><h3 id="常量">常量<a class="header-anchor" href="#常量">⁍</a></h3><p>如果加上<code>final</code>修饰符，这个变量就变成了常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// PI是一个常量</span><br></code></pre></td></tr></table></figure><p>常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。</p><p>常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写<code>3.14</code>，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成<code>3.1416</code>，而不必在所有地方替换<code>3.14</code>。</p><h3 id="var关键字">var关键字<a class="header-anchor" href="#var关键字">⁍</a></h3><p>如果想省略变量类型，可以使用<code>var</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> StringBuilder();<br></code></pre></td></tr></table></figure><p>编译器会根据赋值语句自动推断出变量<code>sb</code>的类型是<code>StringBuilder</code>。</p><h2 id="整数运算">整数运算<a class="header-anchor" href="#整数运算">⁍</a></h2><h3 id="自增-自减">自增/自减<a class="header-anchor" href="#自增-自减">⁍</a></h3><p>注意<code>++</code>写在前面和后面计算结果是不同的，<code>++n</code>表示先加1再引用n，<code>n++</code>表示先引用n再加1。</p><p>（哪个在前面就是先做哪个）</p><h3 id="移位运算">移位运算<a class="header-anchor" href="#移位运算">⁍</a></h3><ul><li>左移1相当于*2，注意溢出</li><li>右移相当于/2，负数右移仍是负数</li></ul><p>还有一种无符号的右移运算，使用<code>&gt;&gt;&gt;</code>，它的特点是不管符号位，右移后高位总是补<code>0</code>，因此，对一个负数进行<code>&gt;&gt;&gt;</code>右移，它会变成正数，原因是最高位的<code>1</code>变成了<code>0</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = -<span class="hljs-number">536870912</span>;<br><span class="hljs-keyword">int</span> a = n &gt;&gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 01110000 00000000 00000000 00000000 = 1879048192</span><br><span class="hljs-keyword">int</span> b = n &gt;&gt;&gt; <span class="hljs-number">2</span>;  <span class="hljs-comment">// 00111000 00000000 00000000 00000000 = 939524096</span><br><span class="hljs-keyword">int</span> c = n &gt;&gt;&gt; <span class="hljs-number">29</span>; <span class="hljs-comment">// 00000000 00000000 00000000 00000111 = 7</span><br><span class="hljs-keyword">int</span> d = n &gt;&gt;&gt; <span class="hljs-number">31</span>; <span class="hljs-comment">// 00000000 00000000 00000000 00000001 = 1</span><br></code></pre></td></tr></table></figure><p>对<code>byte</code>和<code>short</code>类型进行移位时，会首先转换为<code>int</code>再进行位移。</p><h3 id="位运算">位运算<a class="header-anchor" href="#位运算">⁍</a></h3><h4 id="找到一个数二进制里其中最右边一个“1”所在的位置">找到一个数二进制里其中最右边一个“1”所在的位置<a class="header-anchor" href="#找到一个数二进制里其中最右边一个“1”所在的位置">⁍</a></h4><p>该位置标为<code>1</code>，其他位置为<code>0</code>。例如<code>14</code>(<code>1110</code>)，返回<code>0010</code>即<code>2</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> rightOne = n &amp; (~n+<span class="hljs-number">1</span>); <span class="hljs-comment">//n&amp;补码(n)</span><br></code></pre></td></tr></table></figure><h4 id="异或的妙用">异或的妙用<a class="header-anchor" href="#异或的妙用">⁍</a></h4><p><a href="https://www.bilibili.com/video/BV13g41157hK?p=2">参考</a></p><ol><li><p><code>swap(a,b)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a=a^b;<br>b=a^b;<br>a=a^b;<br></code></pre></td></tr></table></figure></li><li><p>一群数<code>int[] nums</code>中，只有一个数出现了奇数次，其他均出现偶数次，找到那个数<code>n</code></p><p><strong>把所有数相异或的结果就是n</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>    n ^= num;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一群数<code>int[] nums</code>中，只有两个数出现了奇数次，其他均出现偶数次，找到那两个数<code>a</code>和<code>b</code></p><p>所有数异或为<code>n</code>，则<code>n=a^b</code>。因为<code>a!=b</code>所以<code>num</code>的二进制上肯定有一位为1，用<code>n</code>上最右边一个1<code>rightOne</code>来区分<code>a</code>和<code>b</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>    n ^= num;<br>&#125;<br><br><span class="hljs-keyword">int</span> rightOne = n &amp; (~n+<span class="hljs-number">1</span>) ;<br><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">//a在rightOne那一位上为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>    <span class="hljs-keyword">if</span>((num&amp;rightOne)==<span class="hljs-number">0</span>)&#123;<br>        a ^= rightOne;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">int</span> b = n^a;<br></code></pre></td></tr></table></figure></li></ol><h3 id="运算优先级">运算优先级<a class="header-anchor" href="#运算优先级">⁍</a></h3><p>在Java的计算表达式中，运算优先级从高到低依次是：</p><ul><li><code>()</code></li><li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li></ul><p>关系运算符的优先级从高到低依次是：</p><ul><li><code>!</code></li><li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li><li><code>==</code>，<code>!=</code></li><li><code>&amp;&amp;</code></li><li><code>||</code></li></ul><h2 id="浮点数运算">浮点数运算<a class="header-anchor" href="#浮点数运算">⁍</a></h2><h3 id="浮点数表示问题">浮点数表示问题<a class="header-anchor" href="#浮点数表示问题">⁍</a></h3><p><strong>浮点数常常无法精确表示。</strong></p><p>浮点数<code>0.1</code>在计算机中就无法精确表示，**因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，**很显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。</p><p>但是，<code>0.5</code>这个浮点数又可以精确地表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> x = <span class="hljs-number">1.0</span> / <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">double</span> y = <span class="hljs-number">1</span> - <span class="hljs-number">9.0</span> / <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 观察x和y是否相等:</span><br>        System.out.println(x); <span class="hljs-comment">// 0.1</span><br>        System.out.println(y); <span class="hljs-comment">// 0.09999999999999998</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="强制转型">强制转型<a class="header-anchor" href="#强制转型">⁍</a></h3><p>可以将浮点数强制转型为整数。在转型时，<strong>浮点数的小数部分会被丢掉</strong>(<strong>即正数变小，负数变大</strong>)。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n1 = (<span class="hljs-keyword">int</span>) <span class="hljs-number">12.3</span>; <span class="hljs-comment">// 12</span><br><span class="hljs-keyword">int</span> n2 = (<span class="hljs-keyword">int</span>) <span class="hljs-number">12.7</span>; <span class="hljs-comment">// 12</span><br><span class="hljs-keyword">int</span> n2 = (<span class="hljs-keyword">int</span>) -<span class="hljs-number">12.7</span>; <span class="hljs-comment">// -12</span><br><span class="hljs-keyword">int</span> n3 = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">12.7</span> + <span class="hljs-number">0.5</span>); <span class="hljs-comment">// 13</span><br><span class="hljs-keyword">int</span> n4 = (<span class="hljs-keyword">int</span>) <span class="hljs-number">1.2e20</span>; <span class="hljs-comment">// 2147483647</span><br></code></pre></td></tr></table></figure><p>如果要进行四舍五入，可以对浮点数加上0.5再强制转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>) (d + <span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure><h2 id="布尔运算">布尔运算<a class="header-anchor" href="#布尔运算">⁍</a></h2><ul><li>短路运算</li><li>三元运算符（条件表达式） <code>表达式a?b:c</code></li></ul><h2 id="字符和字符串">字符和字符串<a class="header-anchor" href="#字符和字符串">⁍</a></h2><h3 id="unicode编码">Unicode编码<a class="header-anchor" href="#unicode编码">⁍</a></h3><p>要显示一个字符的Unicode编码，只需将<code>char</code>类型直接赋值给<code>int</code>类型即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n1 = <span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">// 字母“A”的Unicodde编码是65</span><br><span class="hljs-keyword">int</span> n2 = <span class="hljs-string">&#x27;中&#x27;</span>; <span class="hljs-comment">// 汉字“中”的Unicode编码是20013</span><br></code></pre></td></tr></table></figure><p>还可以直接用转义字符<code>\u</code>+Unicode编码来表示一个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意是十六进制:</span><br><span class="hljs-keyword">char</span> c3 = <span class="hljs-string">&#x27;\u0041&#x27;</span>; <span class="hljs-comment">// &#x27;A&#x27;，因为十六进制0041 = 十进制65</span><br><span class="hljs-keyword">char</span> c4 = <span class="hljs-string">&#x27;\u4e2d&#x27;</span>; <span class="hljs-comment">// &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_26565861/article/details/99686459">【Java基础篇】Unicode、进制转换_cc的博客-CSDN博客_java unicode转16进制</a></p><table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>Integer.toBinaryString(int i)</td><td>将十进制转换成二进制</td></tr><tr><td>Integer.toOctalString(int i)</td><td>将十进制转换成八进制</td></tr><tr><td>Integer.toHexString(int i)</td><td>将十进制转换成十六进制</td></tr><tr><td>Integer.toString(int i, int radix)</td><td>将十进制转换成指定的进制</td></tr></tbody></table><p>其他进制（字符串）转10进制<code>Integer.parseInt(String s, int radix)</code></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-comment">// 请将下面一组int值视为字符的Unicode码，把它们拼成一个字符串：</span><br>   <span class="hljs-keyword">int</span> a = <span class="hljs-number">72</span>;<br>   <span class="hljs-keyword">int</span> b = <span class="hljs-number">105</span>;<br>   <span class="hljs-keyword">int</span> c = <span class="hljs-number">65281</span>;<br><br>   String s = <span class="hljs-string">&quot;&quot;</span>+(<span class="hljs-keyword">char</span>)a+(<span class="hljs-keyword">char</span>)b+(<span class="hljs-keyword">char</span>)c; <span class="hljs-comment">//&quot;&quot;转换为字符串</span><br>   System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="多行字符串">多行字符串<a class="header-anchor" href="#多行字符串">⁍</a></h3><p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）</p><p>多行字符串前面共同的空格会被去掉（以最短的对齐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot; </span><br><span class="hljs-string">           SELECT * FROM</span><br><span class="hljs-string">             users</span><br><span class="hljs-string">           WHERE id &gt; 100</span><br><span class="hljs-string">           ORDER BY name DESC</span><br><span class="hljs-string">           &quot;</span><span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p>上述多行字符串实际上是5行，在最后一个DESC后面还有一个<code>\n</code>。</p><h2 id="数组">数组<a class="header-anchor" href="#数组">⁍</a></h2><h3 id="初始化">初始化<a class="header-anchor" href="#初始化">⁍</a></h3><p>Java的数组有几个特点：</p><ul><li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li><li>数组一旦创建后，大小就不可改变。</li></ul><p>几种初始化表示方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.</span><br><span class="hljs-keyword">int</span>[] ns = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<br>ns[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>ns[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>ns[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>ns[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>ns[<span class="hljs-number">4</span>] = <span class="hljs-number">8</span>;<br><span class="hljs-comment">//2.</span><br><span class="hljs-keyword">int</span>[] ns = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">68</span>, <span class="hljs-number">79</span>, <span class="hljs-number">91</span>, <span class="hljs-number">85</span>, <span class="hljs-number">62</span> &#125;;<br><span class="hljs-comment">//3.</span><br><span class="hljs-keyword">int</span>[] ns = &#123; <span class="hljs-number">68</span>, <span class="hljs-number">79</span>, <span class="hljs-number">91</span>, <span class="hljs-number">85</span>, <span class="hljs-number">62</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="输入输出">输入输出<a class="header-anchor" href="#输入输出">⁍</a></h2><h3 id="输出">输出<a class="header-anchor" href="#输出">⁍</a></h3><ul><li><p><code>println</code>是print line的缩写，表示输出并换行。</p></li><li><p><code>print</code>不换行</p></li><li><p><code>printf</code>格式化输出 JDK文档<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax">java.util.Formatter</a></p><table><thead><tr><th style="text-align:left">占位符</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">%d</td><td style="text-align:left">格式化输出整数</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">格式化输出十六进制整数</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">格式化输出浮点数</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">格式化输出科学计数法表示的浮点数</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">格式化字符串</td></tr></tbody></table><p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。</p></li></ul><h3 id="输入">输入<a class="header-anchor" href="#输入">⁍</a></h3><ul><li><p>需要<code>import java.util.Scanner</code></p></li><li><p>创建<code>Scanner</code>对象传入<code>System.in</code></p><ul><li>要读取用户输入的字符串，使用<code>scanner.nextLine()</code></li><li>要读取用户输入的整数，使用<code>scanner.nextInt()</code>。</li><li><code>Scanner</code>会自动转换数据类型，因此不必手动转换。<code>scanner.nextLine()</code> / <code>nextInt()</code> / <code>nextDouble()</code> / …</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in); <span class="hljs-comment">// 创建Scanner对象</span><br>        System.out.print(<span class="hljs-string">&quot;Input your name: &quot;</span>); <span class="hljs-comment">// 打印提示</span><br>        String name = scanner.nextLine(); <span class="hljs-comment">// 读取一行输入并获取字符串</span><br>        System.out.print(<span class="hljs-string">&quot;Input your age: &quot;</span>); <span class="hljs-comment">// 打印提示</span><br>        <span class="hljs-keyword">int</span> age = scanner.nextInt(); <span class="hljs-comment">// 读取一行输入并获取整数</span><br>        System.out.printf(<span class="hljs-string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="hljs-comment">// 格式化输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="条件选择">条件选择<a class="header-anchor" href="#条件选择">⁍</a></h2><h3 id="判断引用类型相等">判断引用类型相等<a class="header-anchor" href="#判断引用类型相等">⁍</a></h3><p>要判断引用类型的变量内容是否相等，必须使用<code>equals()</code>方法</p><p>注意：执行语句<code>s1.equals(s2)</code>时，如果变量<code>s1</code>为<code>null</code>，会报<code>NullPointerException</code></p><p>要避免<code>NullPointerException</code>错误，可以利用短路运算符<code>&amp;&amp;</code>，或者把一定不是<code>null</code>的对象<code>&quot;hello&quot;</code>放到前面：例如：<code>if (&quot;hello&quot;.equals(s)) &#123; ... &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (s1 != <span class="hljs-keyword">null</span> &amp;&amp; s1.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="switch表达式">switch表达式<a class="header-anchor" href="#switch表达式">⁍</a></h3><blockquote><p>普通用法跟c差不多</p></blockquote><p>使用<code>switch</code>时，如果遗漏了<code>break</code>，就会造成严重的逻辑错误，而且不易在源代码中发现错误。</p><p>从Java 12开始，<code>switch</code>语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要<code>break</code>语句。新语法使用<code>-&gt;</code>，如果有多条语句，需要用<code>&#123;&#125;</code>括起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String fruit = <span class="hljs-string">&quot;apple&quot;</span>;<br>        <span class="hljs-keyword">int</span> opt = <span class="hljs-keyword">switch</span> (fruit) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apple&quot;</span> -&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span> -&gt; <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">0</span>;<br>        &#125;; <span class="hljs-comment">// 注意赋值语句要以;结束</span><br>        System.out.println(<span class="hljs-string">&quot;opt = &quot;</span> + opt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String fruit = <span class="hljs-string">&quot;apple&quot;</span>;<br>        <span class="hljs-keyword">switch</span> (fruit) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="hljs-string">&quot;Selected apple&quot;</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="hljs-string">&quot;Selected pear&quot;</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mango&quot;</span> -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Selected mango&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;Good choice!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">default</span> -&gt; System.out.println(<span class="hljs-string">&quot;No fruit selected&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="yield">yield<a class="header-anchor" href="#yield">⁍</a></h3><p>大多数时候，在<code>switch</code>表达式内部，我们会返回简单的值。</p><p>但是，如果需要复杂的语句，我们也可以写很多语句，放到<code>&#123;...&#125;</code>里，然后，用<code>yield</code>返回一个值作为<code>switch</code>语句的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String fruit = <span class="hljs-string">&quot;orange&quot;</span>;<br>        <span class="hljs-keyword">int</span> opt = <span class="hljs-keyword">switch</span> (fruit) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apple&quot;</span> -&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span> -&gt; <span class="hljs-number">2</span>; <span class="hljs-comment">//这种两个条件在一起的写法只有新版可以</span><br>            <span class="hljs-keyword">default</span> -&gt; &#123;<br>                <span class="hljs-keyword">int</span> code = fruit.hashCode();<br>                yield code; <span class="hljs-comment">// switch语句返回值</span><br>            &#125;<br>        &#125;;<br>        System.out.println(<span class="hljs-string">&quot;opt = &quot;</span> + opt);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="for-each循环">for each循环<a class="header-anchor" href="#for-each循环">⁍</a></h2><p><code>for each</code>循环，它可以更简单地遍历数组等所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] ns = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span> &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : ns) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="快速打印数组内容">快速打印数组内容<a class="header-anchor" href="#快速打印数组内容">⁍</a></h2><p>Java标准库提供了<code>Arrays.toString()</code>，可以快速打印数组内容</p><h2 id="数组排序">数组排序<a class="header-anchor" href="#数组排序">⁍</a></h2><p>可以直接使用Java标准库提供的<code>Arrays.sort(数组)</code>进行排序，改变数组本身/引用</p><h2 id="多维数组">多维数组<a class="header-anchor" href="#多维数组">⁍</a></h2><h3 id="定义">定义<a class="header-anchor" href="#定义">⁍</a></h3><p>二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义<code>ns</code>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] ns = &#123;<br>    &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;,<br>    &#123; <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;,<br>    &#123; <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个二维数组在内存中的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                    ┌───┬───┬───┬───┐<br>         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │<br>ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘<br>         ├───┤      ┌───┬───┐<br>         │░░░│─────&gt;│ 5 │ 6 │<br>         ├───┤      └───┴───┘<br>         │░░░│──┐   ┌───┬───┬───┐<br>         └───┘  └──&gt;│ 7 │ 8 │ 9 │<br>                    └───┴───┴───┘<br></code></pre></td></tr></table></figure><h3 id="打印数组">打印数组<a class="header-anchor" href="#打印数组">⁍</a></h3><p>使用Java标准库的<code>Arrays.deepToString()</code></p><p>[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]</p><h2 id="命令行参数">命令行参数<a class="header-anchor" href="#命令行参数">⁍</a></h2><p>可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个<code>-version</code>参数，打印程序版本号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String arg : args) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-version&quot;</span>.equals(arg)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;v 1.0&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode|数组Arrays</title>
      <link href="/augu1sto/0d8a87a8eab4/"/>
      <url>/augu1sto/0d8a87a8eab4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>leetbook《数组和字符串》笔记<br>leetcode相关题思路整理（待整理）</p></blockquote><h2 id="豆知识">豆知识<a class="header-anchor" href="#豆知识">⁍</a></h2><h3 id="1-看到o-logn-就要去联想二分法">1. 看到O(logN)就要去联想二分法<a class="header-anchor" href="#1-看到o-logn-就要去联想二分法">⁍</a></h3><p><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分法</a>解题思路<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><ul><li><p>在[left,right]闭区间内找条件对应： left&lt;=right  left=mid+1  right=mid-1</p><ul><li>（左闭右开，则left&lt;right  left=mid+1  right=mid）</li></ul></li><li><p>防止溢出： <code>mid=left+((right-left)&gt;&gt;1))</code></p></li><li><p>避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (target &lt; nums[<span class="hljs-number">0</span>] || target &gt; nums[nums.length - <span class="hljs-number">1</span>]) &#123;<br>   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>相关题</p><p><a href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p><a href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE">35. 搜索插入位置</a></p><p>69.x 的平方根</p><p>367.有效的完全平方数</p><h3 id="2-java与c-在二维数组上寻址的区别">2. Java与C++在二维数组上寻址的区别<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><a class="header-anchor" href="#2-java与c-在二维数组上寻址的区别">⁍</a></h3><p>C++中二维数组在地址空间上是连续的。</p><p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况。</p><p>所以Java的二维数组可能是如下排列的方式：</p><p><img src="https://img-blog.csdnimg.cn/20201214111631844.png" alt="算法通关数组3"></p><h3 id="3-双指针法">3. 双指针法<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><a class="header-anchor" href="#3-双指针法">⁍</a></h3><ul><li><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">027.移除元素</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><ul><li>暴力解法时间复杂度：$O(n^2)$</li><li>双指针时间复杂度：$O(n)$</li></ul><p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。</p><p>相关题目：</p><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul><p>另一种双指针是一头一尾</p><h3 id="4-滑动窗口">4. 滑动窗口<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup><a class="header-anchor" href="#4-滑动窗口">⁍</a></h3><ul><li><a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">209.长度最小的子数组</a></li></ul><p>本题介绍了数组操作中的另一个重要思想：滑动窗口。</p><ul><li>暴力解法时间复杂度：$O(n^2)$</li><li>滑动窗口时间复杂度：$O(n)$</li></ul><p>本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。</p><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。</strong></p><p>如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。</p><p>相关题目：</p><ul><li><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76.最小覆盖子串</a></li></ul><h3 id="5-模拟行为">5. 模拟行为<sup class="footnote-ref"><a href="#fn3" id="fnref3:2">[3:2]</a></sup><a class="header-anchor" href="#5-模拟行为">⁍</a></h3><p>模拟过程，定义动作</p><ul><li><a href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii">059.螺旋矩阵II</a></li></ul><p>在这道题目中，我们再一次介绍到了<strong>循环不变量原则</strong>，其实这也是写程序中的重要原则。</p><blockquote><p>循环不变量：按固定的规则遍历，比如 左闭右闭，左闭右开 之类的，二分法里有。</p></blockquote><p>相关题目：</p><ul><li>54.螺旋矩阵</li><li>剑指Offer 29.顺时针打印矩阵</li></ul><h2 id="寻找数组的中心索引"><a href="https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/">寻找数组的中心索引</a><a class="header-anchor" href="#寻找数组的中心索引">⁍</a></h2><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><p>ag: 数组；前缀和</p><blockquote><p><strong>思路：</strong></p></blockquote><ol><li>先求得数组中所有元素之和sum；</li><li>遍历数组，取当前下标左边的元素之和left_sum，同时sum减去已遍历元素，比较二者是否相等，相等则返回当前下标；</li><li>遍历结束，代表没有中心索引，返回-1；</li></ol><p>作者：xiaoyi<br>链接：<a href="https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/?discussion=D6slGT">https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/?discussion=D6slGT</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">int</span> left_sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            sum -= nums[i];<br>            <span class="hljs-keyword">if</span>(left_sum == sum)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            left_sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对角线遍历"><a href="https://leetcode-cn.com/leetbook/read/array-and-string/cuxq3/">对角线遍历</a><a class="header-anchor" href="#对角线遍历">⁍</a></h2><p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt="img"></p><p>输入：mat = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,4,7,5,3,6,8,9]</p><blockquote><p><strong>思路：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] findDiagonalOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">//存放数组</span><br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];<br>        <span class="hljs-comment">//对角线方向次数</span><br>        <span class="hljs-keyword">int</span> count = n + m - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//定义初始化 行标记，列标记，存放数组索引</span><br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>, Index = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//开始对角线循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-comment">//判断对角线方向（因题目初始从右上（即i=0）开始）：偶数右上，奇数左下</span><br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//右上操作</span><br>                <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n) &#123;<br>                    <span class="hljs-comment">//将矩阵数存入存放数组</span><br>                    ans[Index] = matrix[row][col];<br>                    <span class="hljs-comment">//索引后移</span><br>                    Index++;<br>                    <span class="hljs-comment">//右上规律：行减一，列加一</span><br>                    row--;<br>                    col++;<br>                &#125;<br>                <span class="hljs-comment">//判断是否为越界情况：不越界正常行加一，越界行加二，列减一；</span><br>                <span class="hljs-comment">//（此处不理解的拿张草稿纸将循环中row和col的值遍历写一下对照矩阵图就明白了）</span><br>                <span class="hljs-keyword">if</span> (col &lt; n) &#123;<br>                    row++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    row += <span class="hljs-number">2</span>;<br>                    col--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//左下操作：按规律与右上相反即可</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span>) &#123;<br>                    ans[Index] = matrix[row][col];<br>                    Index++;<br>                    row++;<br>                    col--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (row &lt; m) &#123;<br>                    col++;<br><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    row--;<br>                    col += <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回存放数组</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>作者：bsyc<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/leetbook/read/array-and-string/cuxq3/?discussion=iKJs16</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="https://leetcode-cn.com/problems/next-permutation">31. 下一个排列</a><a class="header-anchor" href="#31-下一个排列">⁍</a></h2><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 修改，只允许使用额外常数空间。</p><blockquote><p><strong>思路：</strong></p><p>思考不存在更大排列的情况（即排列已经是最大了的情况），此时，数组肯定是倒序的。</p><p>所以我们只需要从后往前找到第一个不是倒序的数，再进行调整。</p></blockquote><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203092049857.gif" alt="fig1"></p><ol><li>找a[i-1]，从后往前数，它是第一个满足非降序即a[i-1]&lt;a[i]的</li><li>找a[j]，从后往前数，它是第一个大于a[i-1]的</li><li>交换a[i-1]和a[j]，并对a[i-1]后面的数升序排列（反转）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &gt;= nums[i]) &#123;<br>      i--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">while</span> (nums[j] &lt;= nums[i - <span class="hljs-number">1</span>]) &#123;<br>        j--; <span class="hljs-comment">//&amp;&amp;j&gt;=0?</span><br>      &#125;<br>      swap(nums, i - <span class="hljs-number">1</span>, j);<br>    &#125;<br>    reverse(nums, i, nums.length - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] num, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-comment">//反转num[i~j]之间的数组排列</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>      swap(num, i, j);<br>      i++;<br>      j--;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置</a><a class="header-anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置">⁍</a></h2><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><blockquote><p><strong>思路：</strong></p></blockquote><p>传统解法，需要设置标志位看从左侧找还是右侧找（官方题解）</p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/832757">解法二</a> 将问题转化为 找 <code>target-1</code>和<code>target</code>的最右侧值a和b，最后的区间是（a+1,b）。需要思考的是，此处的<code>target-1</code>代表的是仅次于<code>target</code>大小的数（也有可能是target-2之类的），<strong>故<code>binarySearch</code>寻找的是第一个大于<code>target</code>的数，接收完返回值只需<code>-1</code>即可</strong></p><p>注意细节（转化后的问题可以理解为<a href="https://leetcode-cn.com/problems/search-insert-position/description/">35. 搜索插入位置</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> a = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> b = -<span class="hljs-number">1</span>;<br><br>    a = binaryFind(nums, target - <span class="hljs-number">1</span>); <span class="hljs-comment">//target的左界=第一个大于target-1的数</span><br>    b = binaryFind(nums, target) - <span class="hljs-number">1</span>; <span class="hljs-comment">//target的右界=第一个大于target的数-1</span><br>    <span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; nums[b] == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; a, b &#125;;<br>    <span class="hljs-comment">// a&lt;b的情况，low&gt;high（空集）时，res直接返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binaryFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">//返回第一个大于target的数的下标</span><br>    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> high = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = nums.length; <span class="hljs-comment">//考虑到空集的情况，结果还要-1，故这里取nums.length</span><br><br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-keyword">int</span> mid = (high + low) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>        high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//不断向target逼近，若此时刚好跳出，则mid比target坐标刚好大1</span><br>        res = mid;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="https://leetcode-cn.com/problems/combination-sum/description/">39. 组合总和</a><a class="header-anchor" href="#39-组合总和">⁍</a></h2><p>见<a href="%22%3C!--swig%EF%BF%BC23--%3E#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%22">回溯</a>，下同</p><h2 id="40-组合总和-ii"><a href="https://leetcode-cn.com/problems/combination-sum-ii/description/">40. 组合总和 II</a><a class="header-anchor" href="#40-组合总和-ii">⁍</a></h2><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p>**注意：**解集不能包含重复的组合。</p><p>和39题的区别：<code>candidates</code>中的数有重复的（但不能有重复的组合）；<code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-comment">// int len = candidates.length;</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(candidates);<br>    <span class="hljs-comment">//dfs</span><br>    dfs_sum(candidates, <span class="hljs-number">0</span>, target, path, res);<br><br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs_sum</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span>[] candidates,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> begin_node_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> target_sum,</span></span><br><span class="hljs-params"><span class="hljs-function">    List&lt;Integer&gt; path,</span></span><br><span class="hljs-params"><span class="hljs-function">    List&lt;List&lt;Integer&gt;&gt; res</span></span><br><span class="hljs-params"><span class="hljs-function">  )</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin_node_idx; i &lt; candidates.length; i++) &#123;<br>      <span class="hljs-keyword">int</span> next_val = target_sum - candidates[i];<br>      <span class="hljs-keyword">if</span> (i &gt; begin_node_idx &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">//和39题的区别1</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (next_val == <span class="hljs-number">0</span>) &#123;<br>        path.add(candidates[i]);<br>        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(path)); <span class="hljs-comment">//path是引用变量，所以要新申请</span><br>        path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">//回溯</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_val &lt; <span class="hljs-number">0</span> || i == candidates.length - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//和39题的区别2</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        path.add(candidates[i]);<br>        dfs_sum(candidates, i + <span class="hljs-number">1</span>, next_val, path, res); <span class="hljs-comment">//和39题的区别3</span><br>        path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">//回溯</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="https://leetcode-cn.com/problems/trapping-rain-water/description/">42. 接雨水</a><a class="header-anchor" href="#42-接雨水">⁍</a></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203092156185.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><blockquote><p><strong>思路一：动态规划</strong> 1ms,81.65%,38.2MB</p></blockquote><p>对于下标$i$，下雨后水能到达的最大高度等于下标$i$两边的最大高度的最小值，下标处能$i$接的雨水量等于下标$ i$ 处的水能到达的最大高度减去$ height[i]$</p><ul><li>$leftMax[i]$：记录i左边的最大高度，实时更新；$leftMax[i]=max(leftMax[i-1], height[i])，1&lt;=i&lt;=n-1$</li><li>$rightMax[i]：$记录i右边的最大高度，实时更新；$rightMax[i]=max(rightMax[i+1],height[i]) 0&lt;=i&lt;=n-2$</li><li>包含自己，如果左右两边都是自己最大，就说明i处凸了出来</li><li>最终$i处的雨水量=min(leftMax[i],rightMax[i])-height[i]$</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = height.length;<br>    <span class="hljs-keyword">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>    rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>      leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>      rightMax[n - i - <span class="hljs-number">1</span>] =<br>        Math.max(rightMax[n - i - <span class="hljs-number">1</span> + <span class="hljs-number">1</span>], height[n - i - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      s += Math.min(leftMax[i], rightMax[i]) - height[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路二：单调栈 <a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/">接雨水 - 接雨水 - 力扣（LeetCode） (leetcode-cn.com)</a></strong></p></blockquote><blockquote><p><strong>思路三：双指针</strong> 只需要O(1)的空间复杂度</p></blockquote><p>维护两个指针 $\textit{left}$ 和 $\textit{right}$，以及两个变量 $\textit{leftMax}$ 和 $\textit{rightMax}$，</p><p>初始时 $\textit{left}=0,\textit{right}=n-1,\textit{leftMax}=0,\textit{rightMax}=0$。</p><p>指针 $\textit{left}$ 只会向右移动，指针 $\textit{right}$ 只会向左移动，在移动指针的过程中维护两个变量 $\textit{leftMax}$ 和 $\textit{rightMax}$ 的值。</p><p>当两个指针没有相遇时，进行如下操作：</p><p>使用 $\textit{height}[\textit{left}]$和 $\textit{height}[\textit{right}]$的值更新 $\textit{leftMax}$ 和 $\textit{rightMax}$ 的值；</p><ul><li><p>如果 $\textit{height}[\textit{left}]&lt;\textit{height}[\textit{right}]$，则必有 $\textit{leftMax}&lt;\textit{rightMax}$，</p><p>下标 $\textit{left}$ 处能接的雨水量等于 $\textit{leftMax}-\textit{height}[\textit{left}]$，</p><p>将下标 $\textit{left}$ 处能接的雨水量加到能接的雨水总量，然后将 $\textit{left}$ 加 1（即向右移动一位）；</p></li><li><p>如果 $\textit{height}[\textit{left}] \ge \textit{height}[\textit{right}]$，则必有 $\textit{leftMax} \ge \textit{rightMax}$，</p><p>下标 $\textit{right}$ 处能接的雨水量等于 $\textit{rightMax}-\textit{height}[\textit{right}]$，</p><p>将下标 $\textit{right}$ 处能接的雨水量加到能接的雨水总量，然后将 $\textit{right}$ 减 1（即向左移动一位）。</p></li></ul><p>当两个指针相遇时，即可得到能接的雨水总量。</p><h2 id="48-旋转图像"><a href="https://leetcode-cn.com/problems/rotate-image/description/">48. 旋转图像</a><a class="header-anchor" href="#48-旋转图像">⁍</a></h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路：</strong></p></blockquote><p>分两步：</p><ol><li>沿右斜对角线’\'翻转<ol><li>swap(M[i][j],M[j][i])</li></ol></li><li>沿垂直中轴线’|'翻转<ol><li>swap(M[i][j],M[i][n-1-j])</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        swap(matrix, i, j, j, i);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++) &#123;<br>        swap(matrix, i, j, i, n - <span class="hljs-number">1</span> - j);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = matrix[x0][y0];<br>    matrix[x0][y0] = matrix[x1][y1];<br>    matrix[x1][y1] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="https://leetcode-cn.com/problems/maximum-subarray/description/">53. 最大子数组和</a><a class="header-anchor" href="#53-最大子数组和">⁍</a></h2><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary></details><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary></details><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路一：动态规划</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> maxs = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; <span class="hljs-comment">//前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) &#123;<br>      s = Math.max(s + i, i); <span class="hljs-comment">//如果i更大就是i的值，相当于把下面的负数情况加了进去</span><br>      maxs = Math.max(s, maxs);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxs;<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>⭐思路二：分治</strong></p></blockquote><p>定义操作：<code>get(a,l,r)</code> 表示查询 a 序列 [l,r] 区间内的最大子段和</p><p>目标函数：<code>get(nums, 0, nums.length - 1)</code></p><p>对于一个区间 $[l,r]$，我们取 $m = \lfloor \frac{l + r}{2} \rfloor$，对区间 $[l,m]$ 和 $[m+1,r]$ 分治求解。</p><ul><li><p>对于一个区间 $[l,r]$，我们可以维护四个量：</p><p>$\textit{lSum}$ 表示 $[l,r]$ 内以 l 为左端点的最大子段和<br>$\textit{rSum}$ 表示 $[l,r]$ 内以 r 为右端点的最大子段和<br>$\textit{mSum}$ 表示 $[l,r]$ 内的最大子段和<br>$\textit{iSum}$ 表示 $[l,r]$ 的区间和</p></li><li><p>以下简称 $[l,m]$ 为 $[l,r]$ 的「左子区间」，$[m+1,r]$ 为 $[l,r]$ 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 $[l,r]$ 的信息）？</p></li><li><p>对于长度为 $1$ 的区间 $[i, i]$，四个量的值都和 $\textit{nums}[i]$ 相等。</p></li><li><p>对于长度大于 $1$ 的区间：首先最好维护的是 $\textit{iSum}$，区间 $[l,r]$ 的 $\textit{iSum}$ 就等于「左子区间」的 $\textit{iSum}$ 加上「右子区间」的 $\textit{iSum}$。</p><ul><li>对于 $[l,r]$ 的 $\textit{lSum}$，存在两种可能，它要么等于「左子区间」的 $\textit{lSum}$，要么等于「左子区间」的 $\textit{iSum}$ 加上「右子区间」的 $\textit{lSum}$，二者取大。</li><li>对于 $[l,r]$ 的 $\textit{rSum}$，同理，它要么等于「右子区间」的 $\textit{rSum}$，要么等于「右子区间」的 $\textit{iSum}$ 加上「左子区间」的 $\textit{rSum}$，二者取大。</li><li>当计算好上面的三个量之后，就很好计算 $[l,r]$ 的 $\textit{mSum}$ 了。我们可以考虑 $[l,r]$ 的 $\textit{mSum}$ 对应的区间是否跨越 $m$——它可能不跨越 $m$，也就是说 $[l,r]$ 的 $\textit{mSum}$ 可能是「左子区间」的 $\textit{mSum}$ 和 「右子区间」的 $\textit{mSum}$ 中的一个；它也可能跨越 $m$，可能是「左子区间」的 $\textit{rSum}$ 和 「右子区间」的 $\textit{lSum}$ 求和。三者取大。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span> </span>&#123; <span class="hljs-comment">// 维护四个量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> lSum, rSum, mSum, iSum;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Status</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lSum, <span class="hljs-keyword">int</span> rSum, <span class="hljs-keyword">int</span> mSum, <span class="hljs-keyword">int</span> iSum)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.lSum = lSum;<br>      <span class="hljs-keyword">this</span>.rSum = rSum;<br>      <span class="hljs-keyword">this</span>.mSum = mSum;<br>      <span class="hljs-keyword">this</span>.iSum = iSum;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getInfo(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>).mSum;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123; <span class="hljs-comment">//递归终止条件</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Status(a[l], a[l], a[l], a[l]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> m = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//右移1，相当于➗2</span><br>    Status lSub = getInfo(a, l, m);<br>    Status rSub = getInfo(a, m + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">return</span> pushUp(lSub, rSub); <span class="hljs-comment">// 更新两个的量</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">pushUp</span><span class="hljs-params">(Status l, Status r)</span> </span>&#123; <span class="hljs-comment">//维护这些量</span><br>    <span class="hljs-keyword">int</span> iSum = l.iSum + r.iSum;<br>    <span class="hljs-keyword">int</span> lSum = Math.max(l.lSum, l.iSum + r.lSum);<br>    <span class="hljs-keyword">int</span> rSum = Math.max(r.rSum, r.iSum + l.rSum);<br>    <span class="hljs-keyword">int</span> mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Status(lSum, rSum, mSum, iSum);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="https://leetcode-cn.com/problems/jump-game/description/">55. 跳跃游戏</a><a class="header-anchor" href="#55-跳跃游戏">⁍</a></h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><blockquote><p><strong>思路一</strong> <a href="/augu1sto/536722f65a35/" title="动态规划">动态规划</a></p></blockquote><p>很慢。。</p><blockquote><p><strong>思路二</strong> 贪心算法</p></blockquote><p>如果 <strong>最远可以到达的位置</strong> 大于等于数组中的最后一个位置，那就说明最后一个位置可达</p><ul><li>$maxF$：整个数组最远到的地方，随遍历更新<ul><li>初始为0</li></ul></li><li>$far$： 从下标$i$位置最远能到的地方<ul><li>先判断$i$是否可达，$maxF&gt;=i$</li><li>$far=nums[i]+i$</li></ul></li><li>终止：$maxF&gt;=nums.length-1$</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> MaxF = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (MaxF &gt;= i) &#123;<br>        <span class="hljs-keyword">int</span> far = nums[i] + i;<br>        MaxF = Math.max(MaxF, far);<br>        <span class="hljs-keyword">if</span> (MaxF &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="https://leetcode-cn.com/problems/merge-intervals/description/">56. 合并区间</a><a class="header-anchor" href="#56-合并区间">⁍</a></h2><p>主要是要熟悉java的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>    <span class="hljs-comment">// int n = intervals.length;</span><br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]); <span class="hljs-comment">//lamda表达式</span><br>    <span class="hljs-comment">//可变数组</span><br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>    <span class="hljs-comment">// res.add(intervals[0]);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<br>      <span class="hljs-keyword">int</span> left = intervals[i][<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">int</span> right = intervals[i][<span class="hljs-number">1</span>];<br>      <span class="hljs-comment">//因为排序了，所以left&gt;=INTV[0]</span><br>      <span class="hljs-keyword">if</span> (res.size() == <span class="hljs-number">0</span> || left &gt; res.get(res.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; left, right &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.get(res.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] =<br>          Math.max(res.get(res.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], right);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="59-螺旋矩阵-ii"><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a><a class="header-anchor" href="#59-螺旋矩阵-ii">⁍</a></h2><table><thead><tr><th style="text-align:center">Category</th><th style="text-align:center">Difficulty</th><th style="text-align:center">Likes</th><th style="text-align:center">Dislikes</th></tr></thead><tbody><tr><td style="text-align:center">algorithms</td><td style="text-align:center">Medium (78.30%)</td><td style="text-align:center">552</td><td style="text-align:center">-</td></tr></tbody></table><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary></details><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary></details><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><ul><li>定义→↓←↑的操作，注意每个操作的转折点</li><li>定义loop表示转了一圈，注意loop增加的地方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">int</span> loop = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[][] mat = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n * n; k++) &#123;<br>      <span class="hljs-keyword">if</span> (j == loop - <span class="hljs-number">1</span> &amp;&amp; i == loop) &#123;<br>        loop++;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (i == loop - <span class="hljs-number">1</span> &amp;&amp; j &lt; n - loop) &#123; <span class="hljs-comment">//向右</span><br>        mat[i][++j] = k + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n - loop &amp;&amp; i &lt; n - loop) &#123; <span class="hljs-comment">//向下</span><br>        mat[++i][j] = k + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == n - loop &amp;&amp; j &gt; loop - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//向左</span><br>        mat[i][--j] = k + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == loop - <span class="hljs-number">1</span> &amp;&amp; i &gt; loop) &#123; <span class="hljs-comment">//向上</span><br>        mat[--i][j] = k + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mat;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="79-单词搜索"><a href="https://leetcode-cn.com/problems/word-search/description/">79. 单词搜索</a><a class="header-anchor" href="#79-单词搜索">⁍</a></h2><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary></details><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary></details><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202203152349435.jpeg" alt="img"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>思路： 递归+剪枝</strong></p></blockquote><ul><li>如果 $\textit{board}[i][j] \neq s[k]$，当前字符不匹配，直接返回 $\texttt{false}$。</li><li>如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 $\texttt{true}$。否则，遍历当前位置的所有相邻位置。</li><li>如果从某个相邻位置出发，能够搜索到子串 $word[k+1…]$，则返回 $\texttt{true}$，否则返回 $\texttt{false}$。</li></ul><p>这样，我们对每一个位置 $(i,j)$ 都调用函数 $\text{check}(i, j, 0)$ 进行检查：只要有一处返回 $\texttt{true}$，就说明网格中能够找到相应的单词，否则说明不能找到</p><ul><li>额外维护一个与 $board$ 等大的 $visited$ 数组，来标记是否访问过（记得回溯时将$\texttt{false}$的部分重置回未访问过）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 四个方向</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-keyword">int</span> m,n;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">boolean</span> res = backtracking(board, word, i, j, <span class="hljs-number">0</span>, visited); <span class="hljs-comment">// 先找第一个</span><br>                <span class="hljs-keyword">if</span> (res) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">boolean</span>[][] visited)</span></span>&#123;<br>        <span class="hljs-comment">// i,j 代表网格坐标，k代表遍历到第几个字符</span><br><br>        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 终止条件1：字符串遍历到头</span><br>        <span class="hljs-keyword">if</span> (k &gt;= word.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 终止条件2：坐标不合法</span><br>        <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span>||i&gt;=m||j&lt;<span class="hljs-number">0</span>||j&gt;=n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 终止条件3：当前格子访问过</span><br>        <span class="hljs-keyword">if</span> (visited[i][j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 终止条件4：当前网格不满足题意</span><br>        <span class="hljs-keyword">if</span> (word.charAt(k) != board[i][j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            visited[i][j] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 已访问</span><br>            result = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历各个方向</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] direction:directions) &#123;<br>            <span class="hljs-keyword">int</span> new_i = i + direction[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> new_j = j + direction[<span class="hljs-number">1</span>];<br>            result = backtracking(board, word, new_i, new_j, k + <span class="hljs-number">1</span>, visited);<br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        visited[i][j] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形</a><a class="header-anchor" href="#84-柱状图中最大的矩形">⁍</a></h2><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary></details><details style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif, &quot;Microsoft Yahei UI&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary></details><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：heights = [2,1,5,6,2,3]<br>输出：10<br>解释：最大的矩形为图中红色区域，面积为 10<br></code></pre></td></tr></table></figure><blockquote><p><strong>思路</strong></p></blockquote><ul><li><p>对于元素$n[i]$，要找到$i$左边第一个&lt;=它的数和右边第一个&lt;=它的数</p><ul><li><p>维护$left[i]$和$right[i]$，分别是i左边第一个&lt;=它的数和右边第一个&lt;=它的数，则</p><p>$$area[i]=((right[i]-1)-(left[i]+1)+1)\times n[i]$$</p></li></ul></li><li><p>维护一个单调栈，栈底到栈顶的存的下标对应的元素单增，遍历数组，每次遇到n[i]时，就与n[top]比较</p><ul><li>循环，将&gt;=n[i]的top出栈，全pop完之后<ul><li>$left[i]=top$</li><li>特例：栈为空，则$left[i]=0-1=-1$</li><li>push(i)</li></ul></li><li>对于每个pop操作<ul><li>$right[top]=i$</li></ul></li><li>遍历到头之后，将栈内的所有元素都Pop出去，此时<ul><li>$right[top]=n$</li></ul></li></ul></li><li><p>最后计算最大面积</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = heights.length;<br>    <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i] &lt;= heights[stack.peekLast()]) &#123;<br>        <span class="hljs-comment">//执行一次Pop</span><br>        <span class="hljs-keyword">int</span> top = stack.pollLast();<br>        right[top] = i;<br>      &#125;<br>      left[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peekLast();<br>      stack.add(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>      <span class="hljs-keyword">int</span> top = stack.pollLast();<br>      right[top] = n;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      ans = Math.max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>left[i]: 左数最接近的一个&lt;=height[i]的数的下标，起始为-1</li><li>right[i]：右数最接近的一个&lt;=height[i]的数的下标，起始为n</li><li>则实际的长度为（right[i]+left[i]-1）</li><li>面积则为height[i]*（right[i]+left[i]-1）</li></ul><h2 id="581-最短无序连续子数组"><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/description/">581. 最短无序连续子数组</a><a class="header-anchor" href="#581-最短无序连续子数组">⁍</a></h2><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><blockquote><p><strong>思路</strong></p></blockquote><ol><li>从左往右找到第一个不满足单调增的数下标i+1；从右往左找到第一个不满足单调减的数下标j-1</li><li>则左边最大值就是nums[i]，右边的最大值就是nums[j]</li><li>在区间[i,j]中，遍历，更新最大Max和最小Min</li><li>找左边第一个比Min大的数和右边第一个比Max小的数即可</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findUnsortedSubarray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        i = <span class="hljs-number">0</span><br>        j = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i]&lt;=nums[i+<span class="hljs-number">1</span>]:<br>            i+=<span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 考虑特殊情况</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[j]&gt;=nums[j-<span class="hljs-number">1</span>]:<br>            j-=<span class="hljs-number">1</span><br>        <br>        Max = nums[i]<br>        Min = nums[j]<br><br>        <span class="hljs-comment"># 在i，j区间内找最大和最小值</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums[i:j]:<br>            Max = <span class="hljs-built_in">max</span>(num, Max)<br>            Min = <span class="hljs-built_in">min</span>(num, Min)<br><br><br>        <span class="hljs-comment"># 找到左边第一个比Min大的数</span><br>        left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> left &lt; i <span class="hljs-keyword">and</span> nums[left] &lt;= Min:<br>            left+=<span class="hljs-number">1</span><br>        <span class="hljs-comment"># 找到右边第一个比Max小的数</span><br>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> right &gt; j  <span class="hljs-keyword">and</span> nums[right] &gt;= Max:<br>            right-=<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> right-left+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="⭐560-和为-k-的子数组">⭐<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组</a><a class="header-anchor" href="#⭐560-和为-k-的子数组">⁍</a></h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p><blockquote><p><strong>思路</strong></p><p>区间和–》前缀和</p><ul><li>定义 prefixSum 数组，prefixSum[x]：第 0 项到 第 x 项 的和。<br>$$prefixSum[x] = nums[0] + nums[1] +…+nums[x]$$</li><li>nums 的某项 = 两个相邻前缀和的差：<br>$nums[x] = prefixSum[x] - prefixSum[x - 1]$</li><li>nums 的 第 i 到 j 项 的和，有：<br>$$nums[i] +…+nums[j]=prefixSum[j] - prefixSum[i - 1]$$</li></ul><p>当 i 为 0，此时 i-1 为 -1，我们故意让 prefixSum[-1] 为 0，使得通式在i=0时也成立：<br>$nums[0] +…+nums[j]=prefixSum[j]$</p></blockquote><p><strong>不用求出 prefixSum 数组</strong></p><p>其实我们不关心具体是哪两项的前缀和之差等于k，只关心 <strong>等于 k 的前缀和之差出现的次数c</strong> ，就知道了有c个子数组求和等于k。</p><ul><li><p>遍历 nums 之前，我们让 -1 对应的前缀和为 0，这样通式在边界情况也成立。即在遍历之前，map 初始放入 0:1 键值对（前缀和为0出现1次了）。</p></li><li><p>遍历 nums 数组，求每一项的前缀和，统计对应的出现次数，以键值对存入 map。</p></li><li><p>边存边查看 map，如果 map 中存在 key 为「当前前缀和 - $k$」，说明这个之前出现的前缀和，满足「当前前缀和 - 该前缀和 == $k$」，它出现的次数，累加给 count。</p></li></ul><p>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/">https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subarraySum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        cnt = <span class="hljs-number">0</span><br>        preSum = <span class="hljs-number">0</span><br>        myMap = &#123;&#125;<br>        myMap[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            preSum += num<br>            <span class="hljs-keyword">if</span> preSum - k <span class="hljs-keyword">in</span> myMap:<br>                cnt += myMap[preSum-k]<br>            <span class="hljs-keyword">if</span> preSum <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> myMap:<br>                myMap[preSum] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                myMap[preSum] += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">代码随想录-二分查找 (programmercarl.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录-数组理论基础 (programmercarl.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html">代码随想录-数组总结篇 (programmercarl.com)</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a> <a href="#fnref3:2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Leetcode学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文阅读】CanDID_Can-Do Decentralized Identify</title>
      <link href="/augu1sto/a706edaa2c9c/"/>
      <url>/augu1sto/a706edaa2c9c/</url>
      
        <content type="html"><![CDATA[<h2 id="论文基本信息">论文基本信息<a class="header-anchor" href="#论文基本信息">⁍</a></h2><ul><li><p>作者：张帆等（杜克大学）</p></li><li><p>年份：2021</p></li><li><p>会议/期刊：IEEE S&amp;P</p></li><li><p>相关下载</p><ul><li><a href="https://eprint.iacr.org/2020/934">原文</a></li><li><a href="https://mp.weixin.qq.com/s/b1SABGpvDqaGXaTcH7socw">slides</a></li></ul></li><li><p>阅读参考</p><ul><li>微信： <a href="https://mp.weixin.qq.com/s/b1SABGpvDqaGXaTcH7socw">【12月1日讲座回顾】 杜克大学助理教授张帆InForSec&amp;SUSTech学术讲座</a></li></ul></li><li><p>引用格式</p><p>D. Maram, H. Malvai, F. Zhang, N. Jean-Louis, A. Frolov, T. Kell, T. Lobban, C. Moy, A. Juels, and A. Miller. In <em>IEEE Symposium on Security &amp; Privacy (S&amp;P)</em>, 2021.</p></li><li><p>暂无开源信息</p></li></ul><hr><h2 id="问题分析">问题分析<a class="header-anchor" href="#问题分析">⁍</a></h2><p><strong>去中心化身份认证系统</strong>（依托oracle系统）</p><h3 id="传统身份认证场景问题">传统身份认证场景问题<a class="header-anchor" href="#传统身份认证场景问题">⁍</a></h3><ul><li><p><strong>场景：</strong> 审核人需要手持ID身份证明，通过视频方式进行验证身份。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112091806732.png" alt=""></p></li><li><p>问题</p><ul><li>1）传统的身份认证操作繁琐，用户体验不友好；</li><li>2）传统身份认证过程存在安全问题，比如攻击者可以在视频中通过AI技术伪造身份；（<strong>Deepfake</strong>）</li><li>3）传统身份认证系统如驾驶证与数字身份认证系统并不兼容；</li><li>4）传统身份认证系统需要<strong>中心化存储</strong>，存在较大的开销和被攻击风险。==&gt;去中心化</li></ul></li></ul><h3 id="目前去中心化身份认证系统的问题">目前去中心化身份认证系统的问题<a class="header-anchor" href="#目前去中心化身份认证系统的问题">⁍</a></h3><ol><li><strong>Bootstrap:</strong> 如何激励已有身份认证系统去加入并启动系统 ==&gt; <strong>DECO协议</strong>（基于TLS协议）[<a href="https://arxiv.org/pdf/1909.00938v3">DECO CCS’20</a>]</li><li><strong>Key Management:</strong> 如何安全地管理用户的密钥？ ==&gt; <strong>去中心化密钥管理系统</strong>（秘密分享技术）<ul><li>统计数据显示用户在管理和使用密钥上存在问题,比如因为硬盘损坏而造成密钥丢失</li></ul></li><li><strong>Sybil-resistance:</strong> 抗女巫攻击 ==&gt; <strong>模糊方法Fuzzy approach</strong><ul><li>攻击者创建多个身份证明去伪造不同的身份</li><li>为了抗女巫攻击，相关的机制可能需要验证用户的身份信息，因此<em>如何保护用户的的隐私</em>是一个新的挑战。</li></ul></li></ol><h2 id="系统架构">系统架构<a class="header-anchor" href="#系统架构">⁍</a></h2><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112092332079.png" alt="image-20211209233253945"></p><h3 id="identity-system-处理并管理证书">Identity system: 处理并管理证书<a class="header-anchor" href="#identity-system-处理并管理证书">⁍</a></h3><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112101030696.png" alt="image-20211210103018625"></p><ul><li><p>首要目标是<strong>将常用的遗留数据转换为应用程序准备的去中心化凭证</strong>。</p></li><li><p>从现有遗留的web服务中安全地传输身份和证书（利用DECO/Town Crier技术）</p><blockquote><p>目前，只有DECO[86]和Town Crier[85]两种oracle协议能够为用户数据提供隐私保护，并且与遗留兼容，即不需要修改数据源。DECO是证明者P、验证者V和TLS服务器S之间的三方协议。它允许P说服V【从S检索到的可能为P私有的一段数据】满足predicate Pred（谓词）。DECO依靠多方计算(Multi-Party Computation, MPC)来保护数据的私密性和真实性，依靠零知识证明(zero-knowledge proof, ZKPs)来证明满足predicate。</p></blockquote></li><li><p>without providers needing to explicitly create DID-compatible credentials or even be aware of CanDID （零知识）</p></li></ul><p>（相当于收集网络各个地方的数据形成凭证）</p><ul><li>创新功能：<ul><li>sybil-resistance：可基于唯一标识符（比如身份证号）进行去重，基于MPC保进行隐私保护（fuzzy matching）–&gt; 实现唯一性和不可转移性<ul><li>维护一个关于目标用户属性的秘密共享表</li><li>新加入的用户提供<strong>预凭证</strong>（pre-credential）（其中有各种属性，尚未进行重复数据删除）</li><li>commitee执行MPC重复数据删除协议（sec. VII），检查是否存在这些属性</li><li>只有用户的asserted attributes是唯一的时候，颁发<strong>主凭证</strong>（master-credential)，该凭证是sybil-resistant的</li></ul></li><li>accountability：可以筛选，把可疑用户加入黑名单，黑名单以外的用户信息对委员会不可见<ul><li>“黑名单”： 公开的撤销列表revocation list</li></ul></li><li>privacy：<ul><li>Can DID以秘密共享的形式存储目标属性，并通过保护隐私的字符串匹配方式进行搜索。</li><li>使用了一种新开发的基于MPC的模糊匹配技术，该技术可以以一种实用的方式进行扩展。</li></ul></li></ul></li></ul><h3 id="key-recovery-system">Key recovery system<a class="header-anchor" href="#key-recovery-system">⁍</a></h3><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112101138048.png" alt="image-20211210113801995"></p><ul><li><strong>目标：防止身份丢失</strong></li><li>用户在任意设备（比如手机）上存储私钥</li><li>通过秘密共享在CanDID committee中，可指定恢复账户和策略</li><li>隐私：CanDID数据库的使用允许用户证明她成功登录了一个预先选择的账户，但不会向委员会节点泄露账户信息，也不会向网络服务提供商泄露账户信息。</li></ul><h2 id="应用场景">应用场景<a class="header-anchor" href="#应用场景">⁍</a></h2><table><thead><tr><th>应用</th><th>现有方案//问题</th><th>CanDID</th></tr></thead><tbody><tr><td>验证金融投资者的资质</td><td>一组人员审查多种文件的副本来验证KYC、AML等身份属性，每年更新记录<br />//支出大、耗时长、认证过程中涉及的高度敏感信息会暴露给多个雇员和组织</td><td>利用生成的合适的上下文凭据（?相当于用其他地方的凭据）向经销商证明身份，用户可以定期提供经销商要求的新凭据。</td></tr><tr><td>B2B服务</td><td>公司A向公司R发送A的雇员名单和邮件地址，或者创建联合身份关系<br />//名单容易过期；通常需要合同和手工系统集成</td><td>利用生成的基于上下文的凭据作为资格证明，R只需要在本地维护一个CanDID类别的登记册</td></tr><tr><td>网上银行</td><td>依赖于通过照片或视频以数字方式呈现的实体身份证件<br />//伪造问题</td><td>用户可以以一种安全的方式以数字方式收集和呈现凭证，无需视觉交互</td></tr></tbody></table><h2 id="总结">总结<a class="header-anchor" href="#总结">⁍</a></h2><p>整篇文章好数据库啊，本人对数据库没有什么了解，许多东西的理解肯定有问题。<sub>不过导师布置的论文还是得看就是说</sub>┗( T﹏T )┛</p><p>主要大致看了一下文章到第4章为止的内容，后面更多的是一些形式化证明和实现。文章主要是基于数据库的安全迁移？传输？实现各个平台的身份凭证的共享，同时保护隐私，处理了一些安全问题。</p><h2 id="名词解释">名词解释<a class="header-anchor" href="#名词解释">⁍</a></h2><ol><li><p>legacy</p><p>遗留</p><blockquote><p>“遗留系统是一种旧的方法、技术、计算机系统或者应用程序，它意味着系统过时了或者需要被取代。”</p><p>这是维基百科上对于遗留系统的定义，对于“遗留”的含义有明确阐释，即过时或者需要被取代的系统。正因为如此，遗留系统通常具有一些类似的特征。</p><p><a href="https://www.infoq.cn/article/8QvoyyrmB0dgPNY9l0s5">从300万行到50万行代码，遗留系统的微服务改造-InfoQ</a></p></blockquote></li><li><p>PII</p><p>personal identifiable information</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 去中心化 </tag>
            
            <tag> 身份认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题调整|分割线颜色修改</title>
      <link href="/augu1sto/d0283fa070a8/"/>
      <url>/augu1sto/d0283fa070a8/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">问题<a class="header-anchor" href="#问题">⁍</a></h2><p>butterfly的颜色配置理应是在<code>_config.butterfly.yml</code>中进行，<code>hr_color</code>一项应当就是分割线的颜色，可是实际网页中的颜色却与配置的不一致。</p><h2 id="检查元素：这个颜色从哪里来？">检查元素：这个颜色从哪里来？<a class="header-anchor" href="#检查元素：这个颜色从哪里来？">⁍</a></h2><p>在分割线那里右击检查元素查看网页样式，发现<code>hr-border</code>的颜色为<code>#21ffeb</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112092233525.png" alt="image-20211209223331462"></p><p>在源码中查找这个颜色未果，换关键词搜索<code>hr-border</code></p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112092234693.png" alt="image-20211209223437648"></p><p>发现<code>--hr-border</code>的颜色定义为<code>lighten($theme-hr-color,50%)</code></p><h2 id="hsl-lighten-color-amount">HSL: lighten(color,amount)<a class="header-anchor" href="#hsl-lighten-color-amount">⁍</a></h2><p>检索可知，HSL中的<code>lighten()</code>函数作用如下：</p><ul><li><code>lighten(color,amount)</code>：通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li></ul><p>回到样式控制台，利用内置的颜色选择器将16进制颜色转换为HSLA</p><ul><li><p>我设置的<code>hr-color</code>：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112092242390.png" alt="image-20211209224252360"></p></li><li><p>网页中的<code>--hr-border</code>：</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112092244107.png" alt="image-20211209224402086"></p></li></ul><p>比较发现，两者的颜色确实只有亮度值<code>L</code>发生了变化，<em>但并没有达到50%，不清楚是怎么算出来的</em></p><blockquote><p>这部分可能需要继续看源码，说不定在其他地方也有调整</p><p>但是不追求精确的某一个颜色的话，可以大致进行调整了</p></blockquote><h2 id="修改方案">修改方案<a class="header-anchor" href="#修改方案">⁍</a></h2><h3 id="方案一：修改butterfly的source">方案一：修改Butterfly的source<a class="header-anchor" href="#方案一：修改butterfly的source">⁍</a></h3><p>修改文件 <code>yourBlog\themes\butterfly\source\css\_global\index.styl</code>中的<code>--hr-border</code>和<code>--hr-before-border</code>(<strong>不要忘记这个</strong>)，直接改为想要的颜色的值就可以了</p><ul><li>缺点：想换主题色的时候不能只改配置文件</li></ul><h3 id="方案二：修改hr-color的颜色值">方案二：修改<code>hr-color</code>的颜色值<a class="header-anchor" href="#方案二：修改hr-color的颜色值">⁍</a></h3><p>既然<code>--hr-border</code>会对<code>hr-color</code>做<code>lighten()</code>的操作，那么在定义<code>hr-color</code>的时候可以比预想的调高HSL里的亮度值<code>L</code>。</p><ul><li>我这里把63%降为了20%</li></ul><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112092301576.png" alt="image-20211209230100555"></p><ul><li>缺点：不知道<code>hr-color</code>在其他地方有没有发挥过作用，至少源文件里没有检索到。为什么不直接定义为<code>--hr-border-color</code>呢？</li></ul><blockquote><h2 id="后记">后记<a class="header-anchor" href="#后记">⁍</a></h2><p>在检索<code>hr-color</code>的时候，看到了有一项是<code>hr-icon</code>，可能就和分割线上的小剪刀图标有关系。</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112092259882.png" alt="image-20211209225904844"></p><p>发现在主题配置文件里直接可以改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">hr_icon:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">icon:</span> <span class="hljs-comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span><br>  <span class="hljs-attr">icon-top:</span><br></code></pre></td></tr></table></figure><p>可以去<a href="https://fontawesome.com/v5.15/icons?d=gallery&amp;p=2&amp;m=free">Free Icons | Font Awesome</a>找unicode</p></blockquote><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.cnblogs.com/alice-shan/p/4991365.html">Sass函数–颜色函数–HSL函数 - 薯条_9 - 博客园 (cnblogs.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Hexo建站与美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> butterfly主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手学深度学习】win11-pytorch+d2l环境安装</title>
      <link href="/augu1sto/c961f05e4965/"/>
      <url>/augu1sto/c961f05e4965/</url>
      
        <content type="html"><![CDATA[<p>课程<a href="https://www.bilibili.com/video/BV18p4y1h7Dr">03 安装【动手学深度学习v2】</a>是ubuntu+AWS云环境配置的，这里是win11本地，应该也适用于windows其他版本</p><blockquote><h3 id="本机环境">本机环境<a class="header-anchor" href="#本机环境">⁍</a></h3><p>已安装anaconda</p><p>win11环境+NVIDIA Geoforce RTX 3060Ti（不用安装cuda，可用<code>nvidia-smi</code>命令查看cuda环境）</p><p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202112052352562.png" alt="image-20211205235222530"></p><p>如果非NVIDIA独显需要下载CUDA<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><blockquote><p><strong>参考</strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><ol><li><p>如果没有独立显卡，已安装conda或miniconda后，通过如下命令安装pytorch：<br>conda install pytorch torchvision torchaudio cpuonly -c pytorch<br>（如果出现 CondaHTTPError ，先添加清华源 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 50</a>，然后去掉命令中的channel参数“ -c pytorch”，再重新安装即可）</p><p><a href="https://discuss.d2l.ai/uploads/default/original/2X/b/b550302af0afa274fd3282b20720c5a29847290d.png"><img src="https://discuss.d2l.ai/uploads/default/optimized/2X/b/b550302af0afa274fd3282b20720c5a29847290d_2_689x240.png" alt="image">image1293×451 36 KB</a></p></li><li><p>如果有NVIDIA独立显卡，用如下命令同时安装四个包（无需单独安装CUDA）：<code>conda install pytorch torchvision torchaudio cudatoolkit=11.1</code><br>安装后验证：<code>import torch</code><br><code>torch.cuda.is_available()</code><br>注：如果此前安装过无GPU版，需先移除 cpuonly 包</p></li><li><p>如果有AMD独立显卡，最新版pytorch 1.8支持AMD，但好像只在Linux下，具体可自行搜索</p></li></ol></blockquote></blockquote><h2 id="下载-d2l-notebook">下载 D2L Notebook<a class="header-anchor" href="#下载-d2l-notebook">⁍</a></h2><p>下载解压 <a href="https://zh-v2.d2l.ai/d2l-zh.zip">https://zh-v2.d2l.ai/d2l-zh.zip</a> 即可</p><h2 id="安装pytorch">安装pytorch<a class="header-anchor" href="#安装pytorch">⁍</a></h2><h3 id="创建pytorch虚拟环境">创建pytorch虚拟环境*<a class="header-anchor" href="#创建pytorch虚拟环境">⁍</a></h3><blockquote><p>*你也可以直接在base环境下装</p></blockquote><p>打开Anaconda Prompt，输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">conda create -n mypytorch python=3.8<br></code></pre></td></tr></table></figure><p>mypytorch是名字，3.8是python版本，都可以按自己需求改</p><p>切换环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">conda activate mytorch<br></code></pre></td></tr></table></figure><blockquote><p>切换为默认环境命令为<code>conda deactivate</code></p></blockquote><h3 id="更换镜像">更换镜像<a class="header-anchor" href="#更换镜像">⁍</a></h3><blockquote><p>当然网速够快可以不换</p></blockquote><p>直接更改C:\Users\用户文件夹.condarc文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ssl_verify: true<br>show_channels_urls: true<br><br>channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/mysys2/<br></code></pre></td></tr></table></figure><p>可以在当前虚拟环境下用<code>conda config --show-sources</code>验证</p><h3 id="安装pytorch-2">安装pytorch<a class="header-anchor" href="#安装pytorch-2">⁍</a></h3><p><a href="https://pytorch.org/get-started/locally/">Start Locally | PyTorch</a></p><p>官网查看最新版本对应的CUDA是11.3，与本机相符，就装了这个</p><p><code>conda install pytorch torchvision torchaudio cudatoolkit=11.3</code></p><blockquote><p>在运行安装命令时注意去掉后边的 <code>-c pytorch</code>（-c 的意思是去哪个地方下载安装文件，使用<code>-c pytorch</code>意思去pytorch官网下载好像，安装anaconda并换源之后，去掉这个可以下载的快一些 ）<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p></blockquote><p>十分钟左右就安装好了</p><h3 id="测试环境">测试环境<a class="header-anchor" href="#测试环境">⁍</a></h3><p>在当前虚拟环境下输入<code>python</code>回车进入python环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>torch.cuda.is_available()<br></code></pre></td></tr></table></figure><p>返回<code>True</code>，验证成功</p><h2 id="安装d2l软件包">安装D2L软件包<a class="header-anchor" href="#安装d2l软件包">⁍</a></h2><p>pip换源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># -U：将所有包升级到最新的可用版本<br>pip install -U d2l<br></code></pre></td></tr></table></figure><h2 id="打开课程学习的jupyterbook">打开课程学习的jupyterbook<a class="header-anchor" href="#打开课程学习的jupyterbook">⁍</a></h2><p>运行命令，打开浏览器网页 <a href="http://localhost:8888/tree">Home Page - Select or create a notebook</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">jupyter notebook<br></code></pre></td></tr></table></figure><hr><h2 id="reference">Reference<a class="header-anchor" href="#reference">⁍</a></h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.bilibili.com/video/BV18K411w7Vs/">李沐老师的视频教程||Windows 下安装 CUDA 和 Pytorch 跑深度学习 - 动手学深度学习v2_哔哩哔哩_bilibili</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://discuss.d2l.ai/t/topic/2083">安装 - 中文版 / pytorch - D2L Discussion</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://blog.csdn.net/qq_36944952/article/details/109460760">Pytorch-gpu版安装教程【注意：无需提前安装cuda和cudnn】_light-ink的博客-CSDN博客</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pytorch </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>