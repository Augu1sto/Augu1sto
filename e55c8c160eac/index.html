<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode|二叉树 | 若叶</title><meta name="keywords" content="二叉树,Leetcode"><meta name="author" content="Augu1sto"><meta name="copyright" content="Augu1sto"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础知识[1]⁍ 二叉树的定义⁍ 123456789101112public class TreeNode &amp;#123;    int val;  	TreeNode left;  	TreeNode right;  	TreeNode() &amp;#123;&amp;#125;  	TreeNode(int val) &amp;#123; this.val &#x3D; val; &amp;#125;  	TreeNode(int v">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode|二叉树">
<meta property="og:url" content="https://augu1sto.github.io/augu1sto/e55c8c160eac/index.html">
<meta property="og:site_name" content="若叶">
<meta property="og:description" content="基础知识[1]⁍ 二叉树的定义⁍ 123456789101112public class TreeNode &amp;#123;    int val;  	TreeNode left;  	TreeNode right;  	TreeNode() &amp;#123;&amp;#125;  	TreeNode(int val) &amp;#123; this.val &#x3D; val; &amp;#125;  	TreeNode(int v">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://augu1sto.github.io/augu1sto/img/cover04.jpg">
<meta property="article:published_time" content="2022-02-17T14:43:48.000Z">
<meta property="article:modified_time" content="2022-03-26T13:24:48.656Z">
<meta property="article:author" content="Augu1sto">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://augu1sto.github.io/augu1sto/img/cover04.jpg"><link rel="shortcut icon" href="/augu1sto/img/favicon.png"><link rel="canonical" href="https://augu1sto.github.io/augu1sto/e55c8c160eac/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-oEsTyOVPwJ"/><link rel="stylesheet" href="/augu1sto/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/augu1sto/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leetcode|二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-26 21:24:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="google-site-verification" content="a1IrzpkO5Jd9_eZl1_IwZSZ779M4c5LPUf7oSBp4G58" /><link rel="stylesheet" href="/self/material.css"><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/augu1sto/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/augu1sto/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/augu1sto/tags/"><div class="headline">标签</div><div class="length-num">58</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/augu1sto/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/augu1sto/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/projects/smartncc/doc/"><i class="fa-fw fas fa-arrow-up-right-from-square"></i><span> 我的项目</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/augu1sto/img/cover04.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/augu1sto/">若叶</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/augu1sto/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/augu1sto/projects/smartncc/doc/"><i class="fa-fw fas fa-arrow-up-right-from-square"></i><span> 我的项目</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Leetcode|二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-17T14:43:48.000Z" title="发表于 2022-02-17 22:43:48">2022-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-26T13:24:48.656Z" title="更新于 2022-03-26 21:24:48">2022-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/augu1sto/categories/Leetcode%E5%AD%A6%E4%B9%A0/">Leetcode学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Leetcode|二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基础知识">基础知识<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><a class="header-anchor" href="#基础知识">⁍</a></h2>
<h3 id="二叉树的定义">二叉树的定义<a class="header-anchor" href="#二叉树的定义">⁍</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>  	TreeNode left;<br>  	TreeNode right;<br>  	TreeNode() &#123;&#125;<br>  	TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>  	TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>    		<span class="hljs-keyword">this</span>.val = val;<br>    		<span class="hljs-keyword">this</span>.left = left;<br>    		<span class="hljs-keyword">this</span>.right = right;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树种类">二叉树种类<a class="header-anchor" href="#二叉树种类">⁍</a></h3>
<ul>
<li>
<p>满二叉树： 每一层都是满的，第k层有2<sup>k-1</sup>个节点</p>
</li>
<li>
<p>完全二叉树： 最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2<sup>h-1</sup>  个节点。</p>
<blockquote>
<p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p>
</blockquote>
</li>
<li>
<p>二叉搜索树： 有 <strong>数值</strong> ， <strong>二叉搜索树是一个有序树</strong> 。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p>下面这两棵树都是搜索树</p>
<p><img src="https://img-blog.csdnimg.cn/20200806190304693.png" alt="img"></p>
</li>
<li>
<p>平衡二叉搜索树（AVL（Adelson-Velsky and Landis）树）</p>
<ul>
<li>它是一棵 <strong>空树</strong> 或它的左右两个子树的 <strong>高度差</strong> 的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li>
<li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</li>
</ul>
</li>
</ul>
<h3 id="二叉树的存储方式">二叉树的存储方式<a class="header-anchor" href="#二叉树的存储方式">⁍</a></h3>
<p>二叉树可以链式存储，也可以顺序存储（用数组）。</p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<h3 id="二叉树的遍历方式">二叉树的遍历方式<a class="header-anchor" href="#二叉树的遍历方式">⁍</a></h3>
<ul>
<li>深度优先遍历
<ul>
<li>前序遍历（递归法，迭代法）：中左右</li>
<li>中序遍历（递归法，迭代法）：左中右</li>
<li>后序遍历（递归法，迭代法）：左右中</li>
</ul>
</li>
<li>广度优先遍历
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<h4 id="递归遍历">递归遍历<a class="header-anchor" href="#递归遍历">⁍</a></h4>
<blockquote>
<h5 id="递归算法三要素">递归算法三要素<a class="header-anchor" href="#递归算法三要素">⁍</a></h5>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
</blockquote>
<h5 id="144-二叉树的前序遍历"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a><a class="header-anchor" href="#144-二叉树的前序遍历">⁍</a></h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历·递归·LC144_二叉树的前序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function">ArrayList&lt;Integer&gt; <span class="hljs-title">preOrderReverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        preOrder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 确定递归函数的参数和返回值，传入ArrayList记录节点都数值</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">// 2. 终止条件，当前遍历的节点空了，那么本层递归就要要结束</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3. 确定单层递归的逻辑，三种遍历方法就这里不一样</span><br>        result.add(root.val);           <span class="hljs-comment">// 中</span><br>        preOrder(root.left, result);    <span class="hljs-comment">// 左</span><br>        preOrder(root.right, result);   <span class="hljs-comment">// 右</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="94-二叉树的中序遍历"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><a class="header-anchor" href="#94-二叉树的中序遍历">⁍</a></h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中序遍历·递归·LC94_二叉树的中序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        inorder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>        inorder(root.right, list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="145-二叉树的后序遍历"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/">145. 二叉树的后序遍历</a><a class="header-anchor" href="#145-二叉树的后序遍历">⁍</a></h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 后序遍历·递归·LC145_二叉树的后序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        postorder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left, list);<br>        postorder(root.right, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="迭代遍历">迭代遍历<a class="header-anchor" href="#迭代遍历">⁍</a></h4>
<p>用栈的方式实现</p>
<p><strong>前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p>
<h5 id="144-二叉树的前序遍历-2"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a><a class="header-anchor" href="#144-二叉树的前序遍历-2">⁍</a></h5>
<p>按顺序将节点入栈，入栈的同时输出到result，到空的时候出栈，找右节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        TreeNode node = root;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() || node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>                res.add(node.val);<br>                stack.push(node);<br>                node = node.left;<br>            &#125;<br>            node = stack.pop();<br>            node = node.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//作者：LeetCode-Solution</span><br><span class="hljs-comment">//链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/</span><br><br></code></pre></td></tr></table></figure>
<p><strong>改掉二重循环</strong></p>
<p>—— 出栈的时候把节点值加入result，要求中节点入栈后，先将右节点入栈，再将左节点入栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>            TreeNode node = stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                stack.push(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                stack.push(node.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="94-二叉树的中序遍历-2"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><a class="header-anchor" href="#94-二叉树的中序遍历-2">⁍</a></h5>
<p>按顺序将节点入栈，出栈的时候把值加入result</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        Deque&lt;TreeNode&gt; stk = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stk.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                stk.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stk.pop();<br>            res.add(root.val);<br>            <span class="hljs-comment">// 若有右节点，证明它也是这一层的“中”节点</span><br>            <span class="hljs-comment">// 若是最左的叶子节点，则返回Null，后面继续出栈</span><br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h5 id="145-二叉树的后序遍历-2"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a><a class="header-anchor" href="#145-二叉树的后序遍历-2">⁍</a></h5>
<p>与中序的不同之处在于：</p>
<ul>
<li>中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。</li>
<li>后序遍历中，从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。</li>
</ul>
<p>因此，我们在后序遍历中，引入了一个prev来记录历史访问记录。</p>
<ul>
<li>当访问完一棵子树的时候，我们用prev指向该节点。</li>
<li>这样，在回溯到父节点的时候，我们可以依据prev是指向左子节点，还是右子节点，来判断父节点的访问情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        TreeNode prev = <span class="hljs-keyword">null</span>;<br>        <br>        <span class="hljs-comment">//主要思想：</span><br>        <span class="hljs-comment">//由于在某颗子树访问完成以后，接着就要回溯到其父节点去</span><br>        <span class="hljs-comment">//因此可以用prev来记录访问历史，在回溯到父节点时，可以由此来判断，上一个访问的节点是否为右子树</span><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            <span class="hljs-comment">//从栈中弹出的元素，左子树一定是访问完了的</span><br>            root = stack.pop();<br>            <span class="hljs-comment">//现在需要确定的是是否有右子树，或者右子树是否访问过</span><br>            <span class="hljs-comment">//如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时</span><br>            <span class="hljs-comment">//说明可以访问当前节点</span><br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span> || root.right == prev) &#123;<br>                res.add(root.val);<br>                <span class="hljs-comment">//更新历史访问记录，这样回溯的时候父节点可以由此判断右子树是否访问完成</span><br>                prev = root;<br>                root = <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果右子树没有被访问，那么将当前节点压栈，访问右子树</span><br>                stack.push(root);<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="统一迭代法">统一迭代法<a class="header-anchor" href="#统一迭代法">⁍</a></h4>
<p><strong>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p>
<p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        Deque&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>                st.pop(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-keyword">null</span>) st.push(node.right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br>                <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-keyword">null</span>) st.push(node.left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                st.push(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.push(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br>                <br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.pop();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.peek();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.pop();<br>                result.add(node.val); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="⭐-广度优先：层序遍历">⭐ 广度优先：层序遍历<a class="header-anchor" href="#⭐-广度优先：层序遍历">⁍</a></h4>
<h5 id="102-二叉树的层序遍历"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a><a class="header-anchor" href="#102-二叉树的层序遍历">⁍</a></h5>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br></code></pre></td></tr></table></figure>
<p><mark>不要把输入当作数组，输入还是树结构！！</mark></p>
<p>方法一：递归，记录树深度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 102.二叉树的层序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        levelDFS(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelDFS</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(result.size()&lt;level+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 如果是新的一层，则加进结果</span><br>            List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            result.add(itemList);<br>        &#125;<br>        <span class="hljs-comment">// 将root节点加进相应层</span><br>        result.get(level).add(root.val);<br>        levelDFS(root.left, level+<span class="hljs-number">1</span>);<br>        levelDFS(root.right, level+<span class="hljs-number">1</span>);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法二：迭代，可借助队列实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 102.二叉树的层序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-comment">//创建队列存访二叉树节点（注意类型是TreeNode！）</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-comment">//先将第一个根节点加入队列</span><br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <span class="hljs-comment">//将队列中的元素都加入列表</span><br>            <span class="hljs-keyword">int</span> len = que.size();<br>            <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>                TreeNode curNode = que.poll();<br>                itemList.add(curNode.val);<br>                <span class="hljs-comment">//将左右节点入队</span><br>                <span class="hljs-keyword">if</span>(curNode.left!=<span class="hljs-keyword">null</span>) que.offer(curNode.left);<br>                <span class="hljs-keyword">if</span>(curNode.right!=<span class="hljs-keyword">null</span>) que.offer(curNode.right);<br>                len--;<br>            &#125;<br>            result.add(itemList);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>相关题：</strong></p>
<ul>
<li><a href="#102.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">102.二叉树的层序遍历</a></li>
<li>107.二叉树的层次遍历II</li>
<li>199.二叉树的右视图</li>
<li><a href="#637.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC">637.二叉树的层平均值</a></li>
<li>429.N叉树的层序遍历</li>
<li>515.在每个树行中找最大值</li>
<li>116.填充每个节点的下一个右侧节点指针</li>
<li>117.填充每个节点的下一个右侧节点指针II</li>
<li><a href="#104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">104.二叉树的最大深度</a></li>
<li>111.二叉树的最小深度</li>
</ul>
<h3 id="⭐-递归函数的返回值">⭐ 递归函数的返回值<a class="header-anchor" href="#⭐-递归函数的返回值">⁍</a></h3>
<p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且<u>不用处理</u>递归返回值，递归函数就不要返回值。（113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且<u>需要处理</u>递归返回值，递归函数就需要返回值。 （这种情况我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要搜索<u>其中一条符合条件的路径</u>，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112.路径总和 的情况）</li>
</ul>
<p>搜索一条边的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (递归函数(root-&gt;left)) return ;<br><br>if (递归函数(root-&gt;right)) return ;<br></code></pre></td></tr></table></figure>
<p>搜索整个树写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">left = 递归函数(root-&gt;left);<br>right = 递归函数(root-&gt;right);<br>left与right的逻辑处理;<br></code></pre></td></tr></table></figure>
<h3 id="⭐-递归与叶子节点">⭐ 递归与叶子节点<a class="header-anchor" href="#⭐-递归与叶子节点">⁍</a></h3>
<p>有些情况下，递归需要在叶子节点处终止，此时在递归左右子节点的时候判断是否为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">递归函数(root, ...)&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//终止逻辑</span><br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-keyword">null</span>) 递归函数(root.left, ...);<br>    <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-keyword">null</span>) 递归函数(root.right, ...);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先</a><a class="header-anchor" href="#236-二叉树的最近公共祖先">⁍</a></h2>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>// 输入和返回的类型都是TreeNode<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>思路</strong></p>
</blockquote>
<p>❌错解：</p>
<ul>
<li>
<p>分别记录先序遍历到p和q节点的路径，比对两个路径最后一个相同的节点</p>
</li>
<li>
<p>该节点可能是最近公共祖先，但也有可能是最近公共祖先的左子节点！</p>
<ul>
<li>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[3,5,1,6,2,0,8,null,null,7,4]<br>5<br>1<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>✔️正解<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<p><strong>遍历方式选择：</strong> 自底向上查找 --&gt; 二叉树回溯 --&gt; 后序遍历(最先处理的是叶子节点)</p>
<p>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</p>
<p><strong>递归三部曲：</strong></p>
<ul>
<li>
<p><strong>确定递归函数返回值及参数</strong></p>
<p>如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p>
</li>
<li>
<p><strong>确定终止条件</strong></p>
<p>如果找到了 节点p或者q，或者遇到空节点，就返回。</p>
</li>
<li>
<p><strong>确定单层递归逻辑</strong></p>
<ul>
<li>
<p>本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断</p>
</li>
<li>
<p>需要遍历整棵树，用left和right接住左子树和右子树的返回值，再处理left与right逻辑</p>
<ul>
<li>
<p>如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</p>
</li>
<li>
<p>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</p>
</li>
<li>
<p>如果left和right中有一个为空、一个不为空，就返回不为空的那个。</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件和返回值</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p|| root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 后序遍历</span><br>        TreeNode left = lowestCommonAncestor(root.left, p, q);<br>        TreeNode right = lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-comment">// 处理左右子树逻辑</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 两个都空，返回空</span><br>            <span class="hljs-keyword">return</span> left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left !=<span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-comment">// 两个都不为空，返回根节点</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left !=<span class="hljs-keyword">null</span> )&#123;   <span class="hljs-comment">// 只有一个节点不为空，返回不为空的节点</span><br>            <span class="hljs-keyword">return</span> left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="637-二叉树的层平均值"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值</a><a class="header-anchor" href="#637-二叉树的层平均值">⁍</a></h2>
<p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 10<sup>-5</sup> 以内的答案可以被接受。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>思路：</strong> 层序遍历</p>
</blockquote>
<p><strong>注意点：</strong></p>
<ul>
<li>
<p>将sum写作double型，计算平均值时可以自动进行类型转换</p>
</li>
<li>
<p>提前记录队列长度</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Double&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Double&gt;();<br>        <br>        <span class="hljs-comment">// 二叉树非空</span><br>        <span class="hljs-comment">// 创建队列 层序遍历</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-comment">// 根节点入队</span><br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意直接写为double类型</span><br>            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> lenq = que.size(); <span class="hljs-comment">//因为后面涉及到出队操作，所以提前记录que的长度</span><br><br>            <span class="hljs-keyword">while</span>(len &lt; lenq)&#123;<br>                <span class="hljs-comment">// 出队</span><br>                TreeNode curNode = que.poll();<br>                <span class="hljs-comment">// 加入当前节点</span><br>                sum += curNode.val;<br>                <span class="hljs-comment">// 左右节点入队</span><br>                <span class="hljs-keyword">if</span>(curNode.left!=<span class="hljs-keyword">null</span>) que.offer(curNode.left);<br>                <span class="hljs-keyword">if</span>(curNode.right!=<span class="hljs-keyword">null</span>) que.offer(curNode.right);<br>                len++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!que.isEmpty()) &#123;<br>                <br>            &#125;<br>            result.add(sum/lenq);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度</a><a class="header-anchor" href="#104-二叉树的最大深度">⁍</a></h2>
<p>给定一个二叉树，找出其最大深度。</p>
<p><strong>示例：</strong><br>
给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  3<br> / \<br>9  20<br>  /  \<br> 15   7<br></code></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<blockquote>
<p>⭐ <strong>思路一：</strong> 深度=自底而上–&gt;后序遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> deepl = maxDepth(root.left);<br>        <span class="hljs-keyword">int</span> deepr = maxDepth(root.right);<br>        <span class="hljs-comment">// 返回更大的深度</span><br>        <span class="hljs-keyword">return</span> deepl&gt;deepr?(deepl+<span class="hljs-number">1</span>):(deepr+<span class="hljs-number">1</span>);<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>思路二：</strong> 迭代法 层序遍历，记录深度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 迭代法，使用层序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        deque.offer(root);<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!deque.isempty()) &#123;<br>            <span class="hljs-keyword">int</span> size = deque.size();<br>            depth++;<span class="hljs-comment">//记录深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                treenode poll = deque.poll();<br>                <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-keyword">null</span>) &#123;<br>                    deque.offer(poll.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-keyword">null</span>) &#123;<br>                    deque.offer(poll.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="111-二叉树的最小深度"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度</a><a class="header-anchor" href="#111-二叉树的最小深度">⁍</a></h2>
<h3 id="方法一：-递归法">方法一： 递归法<a class="header-anchor" href="#方法一：-递归法">⁍</a></h3>
<p>后序遍历</p>
<p>❌误区：</p>
<p>不能仿照<a href="#104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树的最大深度</a>写如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int leftDepth = getDepth(node.left);<br>int rightDepth = getDepth(node.right);<br>return Math.min(leftDepth, rightDepth) + 1;<br></code></pre></td></tr></table></figure>
<p>这个代码就犯了此图中的误区：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度"></p>
<p>如果这么求的话，没有左孩子的分支会算为最短深度。</p>
<p>✔️正解</p>
<ul>
<li>左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。</li>
<li>右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1</li>
<li>左右子树都不为空，按上面的写法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> deepl = minDepth(root.left);<br>        <span class="hljs-keyword">int</span> deepr = minDepth(root.right);<br>        <span class="hljs-keyword">if</span> (root.left==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> deepr+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> deepl+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Math.min(deepl,deepr)+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二：迭代法">方法二：迭代法<a class="header-anchor" href="#方法二：迭代法">⁍</a></h3>
<p>判断如果是叶子节点，直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            deep++; <span class="hljs-comment">// 记录量</span><br>            <span class="hljs-keyword">int</span> len = que.size();<br>            <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>                TreeNode curNode = que.poll();<br>                <span class="hljs-keyword">if</span> (curNode.left==<span class="hljs-keyword">null</span>&amp;&amp;curNode.right==<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//是叶子节点</span><br>                    <span class="hljs-keyword">return</span> deep;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (curNode.left != <span class="hljs-keyword">null</span>) que.offer(curNode.left);<br>                <span class="hljs-keyword">if</span> (curNode.right != <span class="hljs-keyword">null</span>) que.offer(curNode.right);<br>                len--; <span class="hljs-comment">//千万不要忘！！！！！！！</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep; <span class="hljs-comment">//最终的返回值！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="559-n-叉树的最大深度"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/description/">559. N 叉树的最大深度</a><a class="header-anchor" href="#559-n-叉树的最大深度">⁍</a></h2>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>N 叉树输入按层序遍历序列化 <strong>表示</strong> ，每组子节点由空值分隔（请参见示例）。（表示方法而已！）</p>
<p>⭐N叉树表示方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; children;<span class="hljs-comment">//List</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _val)</span> </span>&#123;<br>        val = _val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;<br>        val = _val;<br>        children = _children;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>思路：</strong></p>
</blockquote>
<p>和<a href="#104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树的最大深度</a>类似，左右子节点变为遍历一个列表的孩子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxd = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node i: root.children) &#123;<br>            <span class="hljs-keyword">int</span> di = maxDepth(i);<br>            maxd = Math.max(maxd, di); <br>        &#125;<br>        <span class="hljs-keyword">return</span> maxd+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="543-二叉树的直径"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">543. 二叉树的直径</a><a class="header-anchor" href="#543-二叉树的直径">⁍</a></h2>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>
给定二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    1<br>   / \<br>  2   3<br> / \     <br>4   5    <br></code></pre></td></tr></table></figure>
<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<blockquote>
<p><strong>思路</strong></p>
</blockquote>
<p>长度 = 左子树深度 + 右子树深度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxL = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> deep = getDepth(root);<br>        <span class="hljs-keyword">return</span> maxL;    <br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> deepl = getDepth(node.left);<br>        <span class="hljs-keyword">int</span> deepr = getDepth(node.right);<br>        <span class="hljs-comment">// 记录最长距离</span><br>        maxL = Math.max(maxL, deepl + deepr);<br>        <span class="hljs-keyword">return</span> Math.max(deepl, deepr)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="222-完全二叉树的节点个数"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数</a><a class="header-anchor" href="#222-完全二叉树的节点个数">⁍</a></h2>
<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>
<blockquote>
<p><strong>思路：</strong> 利用完全二叉树的性质</p>
</blockquote>
<p>完全二叉树只有两种情况：</p>
<ul>
<li>
<p>满二叉树：可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1</p>
</li>
<li>
<p>最后一层叶子节点没有满。</p>
<ul>
<li>
<p>分别递归左孩子，和右孩子，递归到某一深度一定会有</p>
<ul>
<li>
<ol>
<li>左孩子为满二叉树</li>
<li>右孩子为满二叉树</li>
</ol>
<p>然后依然可以按照满二叉树来计算。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>完全二叉树获得深度只需要不断遍历左节点就行了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// root.left为空时，说明只有一个节点即root，情况被包含进去了</span><br>        <span class="hljs-keyword">int</span> depL = getDepth(root.left);<br>        <span class="hljs-keyword">int</span> depR = getDepth(root.right);<br>        <span class="hljs-keyword">if</span> (depL==depR) &#123;<span class="hljs-comment">//说明左子树是满二叉树</span><br>            <span class="hljs-comment">//左子树+右子树+根节点</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;depL)-<span class="hljs-number">1</span> + countNodes(root.right) + <span class="hljs-number">1</span>; <br>            <span class="hljs-comment">//1&lt;&lt;depL-1 = (int)Math.pow(2, depL)-1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 否则，左子树非满二叉树，右子树是满二叉树</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;depR)-<span class="hljs-number">1</span> + countNodes(root.left) + <span class="hljs-number">1</span> ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            root = root.left;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：$O(\log^2 n)$</p>
<h2 id="110-平衡二叉树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/description/">110. 平衡二叉树</a><a class="header-anchor" href="#110-平衡二叉树">⁍</a></h2>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<blockquote>
<p><strong>思路：</strong> 递归算深度，设置标志位-1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (getDepth(root)==-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> dL = getDepth(root.left);<br>        <span class="hljs-keyword">int</span> dR = getDepth(root.right);<br><br>        <span class="hljs-comment">// 如果已经不是平衡树了，直接返回-1</span><br>        <span class="hljs-keyword">if</span> (dL==-<span class="hljs-number">1</span> || dR==-<span class="hljs-number">1</span> || Math.abs(dL-dR)&gt;<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Math.max(dL, dR)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a><a class="header-anchor" href="#226-翻转二叉树">⁍</a></h2>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<blockquote>
<p><strong>思路：</strong></p>
</blockquote>
<p>先序遍历/后序遍历二叉树，交换左右节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">//后序遍历</span><br>    invertTree(root.left);<br>    invertTree(root.right);<br>    swapNode(root);<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapNode</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    TreeNode tmp = root.left;<br>    root.left = root.right;<br>    root.right = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a><a class="header-anchor" href="#101-对称二叉树">⁍</a></h2>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [1,2,2,3,4,4,3]<br>输出：true<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>思路</strong></p>
</blockquote>
<ul>
<li>相当于比较根节点的左子树和右子树</li>
<li>后序遍历：
<ul>
<li>左子树：左右中</li>
<li>右子树：右左中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//树中节点数目在范围 [1, 1000] 内</span><br>    <span class="hljs-keyword">return</span> biPostOrder(root.left, root.right);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">biPostOrder</span><span class="hljs-params">(TreeNode rootL, TreeNode rootR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((rootL == <span class="hljs-keyword">null</span> &amp;&amp; rootR != <span class="hljs-keyword">null</span>) || (rootL != <span class="hljs-keyword">null</span> &amp;&amp; rootR == <span class="hljs-keyword">null</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rootL == <span class="hljs-keyword">null</span> &amp;&amp; rootR == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rootL.val != rootR.val) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// if (rootL.val == rootR.val) &#123;</span><br>    <span class="hljs-comment">//   return true; 不可以直接判断！！要进底下递归</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> (<br>      biPostOrder(rootL.left, rootR.right) &amp;&amp;<br>      biPostOrder(rootL.right, rootR.left)<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="257-二叉树的所有路径"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a><a class="header-anchor" href="#257-二叉树的所有路径">⁍</a></h2>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<blockquote>
<p><strong>思路：</strong></p>
</blockquote>
<p>用先序遍历，在叶子节点处终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> List&lt;String&gt; paths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    findPath(root, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> paths;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPath</span><span class="hljs-params">(TreeNode root, String path)</span> </span>&#123;<br>    path = path + <span class="hljs-string">&quot;-&gt;&quot;</span> + String.valueOf(root.val);<br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>      paths.add(path.substring(<span class="hljs-number">2</span>)); <span class="hljs-comment">//去除开头的&quot;-&gt;&quot;</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) findPath(root.left, path);<br>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) findPath(root.right, path);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="700-二叉搜索树中的搜索"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a><a class="header-anchor" href="#700-二叉搜索树中的搜索">⁍</a></h2>
<p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<h3 id="递归法">递归法<a class="header-anchor" href="#递归法">⁍</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 递归，利用二叉搜索树特点，优化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.val == val) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val &lt; root.val) &#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="迭代法">迭代法<a class="header-anchor" href="#迭代法">⁍</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">//节点数在 [1, 5000] 范围内</span><br><br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (root.val == val) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (root.val &gt; val) &#123;<br>        root = root.left;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        root = root.right;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>清楚定义就行</p>
<h2 id="⭐-构造二叉树">⭐ 构造二叉树<a class="header-anchor" href="#⭐-构造二叉树">⁍</a></h2>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树</a><a class="header-anchor" href="#106-从中序与后序遍历序列构造二叉树">⁍</a></h3>
<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p>
<blockquote>
<p><strong>思路</strong></p>
</blockquote>
<p>后序遍历：左右中</p>
<p>中序遍历：左中右</p>
<p>通过后序遍历，从后往前，可以确定根节点</p>
<p>然后通过中序遍历，确定左子树的大小</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p>
<p>逻辑：</p>
<ul>
<li>
<p>后序找根root</p>
<ol>
<li>
<p>遍历中序到根，确定左子树长度<code>llen</code></p>
</li>
<li>
<p>后序中根据左子树长度，找到左子树的根</p>
<p><code>root_l = post_start+llen-1;</code></p>
</li>
<li>
<p>算出后序中右子树起始位置<br>
<code>post_start_r = post_start+llen;</code></p>
<p>左子树起始即原来的起始位置</p>
<p><code>post_start_l = post_start;</code></p>
</li>
<li>
<p>中序遍历再＋1得到右子树在中序遍历中的起始位置</p>
<p><code>in_start_r = in_start+llen+1;</code></p>
<p>左子树的起始位置即原来的起始位置</p>
<p><code>in_start_l = in_start;</code></p>
</li>
</ol>
</li>
<li>
<p>右子树的根就是后序遍历中的下一个</p>
<p><code>root_r = root-1;</code></p>
</li>
</ul>
<p>终止：</p>
<p>通过后序的长度来判断元素个数</p>
<ul>
<li>没有元素：返回Null</li>
<li>只剩一个元素（叶子节点），返回节点</li>
</ul>
<p><img src="https://gitee.com/Augu1sto/imageHost/raw/master/BlogImg/202202221846566.png" alt="image-20220222184650406"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> buildTree1(inorder, postorder, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, postorder.length-<span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> in_start, <span class="hljs-keyword">int</span> post_start, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">if</span> (root-post_start+<span class="hljs-number">1</span>&lt;<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//没有元素了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-post_start+<span class="hljs-number">1</span>==<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//只剩一个元素（无左右节点了）</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(postorder[root]);<br>        &#125;<br><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(postorder[root]); <span class="hljs-comment">// 倒序创建根节点</span><br>        <span class="hljs-keyword">int</span> llen = <span class="hljs-number">0</span>; <span class="hljs-comment">//左子树长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = in_start; i &lt; inorder.length ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i]==postorder[root]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            llen++;<br>        &#125;<br><br><br>        <span class="hljs-keyword">int</span> root_l = post_start+llen-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_r = root-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> post_start_l = post_start;<br>        <span class="hljs-keyword">int</span> post_start_r = post_start+llen;<br>        <span class="hljs-keyword">int</span> in_start_l = in_start;<br>        <span class="hljs-keyword">int</span> in_start_r = in_start+llen+<span class="hljs-number">1</span>;<br><br><br>        node.left = buildTree1(inorder, postorder, in_start_l,  post_start_l, root_l);<br>        node.right = buildTree1(inorder, postorder, in_start_r, post_start_r, root_r);<br>        <span class="hljs-keyword">return</span> node;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树</a><a class="header-anchor" href="#105-从前序与中序遍历序列构造二叉树">⁍</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> buildTree1(preorder, inorder, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, preorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> in_start, <span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> pre_end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root&gt;pre_end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(preorder[root]);<br><br>        <span class="hljs-keyword">if</span> (root==pre_end) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> llen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = in_start; i &lt; inorder.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i]==preorder[root]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            llen++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> in_start_l = in_start;<br>        <span class="hljs-keyword">int</span> in_start_r = in_start+llen+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_l = root+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_r = root+llen+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> pre_end_l = root+llen;<br>        <span class="hljs-keyword">int</span> pre_end_r = pre_end; <br><br>        node.left = buildTree1(preorder, inorder, in_start_l, root_l, pre_end_l);<br>        node.right = buildTree1(preorder, inorder, in_start_r, root_r, pre_end_r);<br>        <span class="hljs-keyword">return</span> node;<br><br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p>
<blockquote>
<p>另一个方法 ： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/99ljye/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<p>先遍历一遍中序的数组，以（值，下标）的形式存储到dict里，用的时候直接取出即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value:inorder) &#123;<br>            map.put(value,i);<br>            i++;<br>        &#125;<br>        TreeNode root = helper(preorder, <span class="hljs-number">0</span>, inorder, <span class="hljs-number">0</span>, preorder.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root &gt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(preorder[root]);<br><br>        <span class="hljs-keyword">int</span> p = map.get(preorder[root]); <span class="hljs-comment">// 中序遍历中根节点的位置，据此划分左子树和右子树</span><br>        <span class="hljs-keyword">int</span> leftLen = p - start;<br>        <span class="hljs-keyword">int</span> left = root+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right = left+leftLen;<br>        node.left = helper(preorder, left, inorder, start, right-<span class="hljs-number">1</span>);<br>        node.right = helper(preorder, right, inorder, start+leftLen+<span class="hljs-number">1</span>, end);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="108-将有序数组转换为二叉搜索树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树</a><a class="header-anchor" href="#108-将有序数组转换为二叉搜索树">⁍</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, nums.length);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">//左闭右开</span><br>    <span class="hljs-keyword">if</span> (left &gt; right - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left == right - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(nums[left]);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br>    root.left = buildTree(nums, left, mid);<br>    root.right = buildTree(nums, mid + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类似： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></p>
<h3 id="⭐-109-有序链表转换二叉搜索树">⭐ <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a><a class="header-anchor" href="#⭐-109-有序链表转换二叉搜索树">⁍</a></h3>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<blockquote>
<p><strong>思路：</strong></p>
</blockquote>
<p>链表–&gt;数组–&gt;二叉树？————额外的空间 ❌（也不是完全不行啦）</p>
<p>✔ 快慢指针找中间的节点</p>
<p>快指针一次移动2，慢指针一次移动1</p>
<p>最后快指针到达右端点或快指针的下一个节点是右端点时，慢指针就可以指向中间节点。</p>
<p>同时，没有必要“先”找到中间节点：我们可以使用 <strong>中序遍历</strong> 先构建了左子树，建立结束后，指针自然指向中间结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> ListNode helpHead;<span class="hljs-comment">//重要！！不能直接放进去递归</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    helpHead = head;<br>    <span class="hljs-keyword">int</span> len = getListLength(head);<br>    <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>, len);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getListLength</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>      head = head.next;<br>      cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode();<br>    root.left = helper(left, mid);<br>    root.val = helpHead.val;<br>    helpHead = helpHead.next;<br>    root.right = helper(mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="⭐-701-二叉搜索树中的插入操作">⭐ <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a><a class="header-anchor" href="#⭐-701-二叉搜索树中的插入操作">⁍</a></h2>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<blockquote>
<p><strong>思路：</strong></p>
</blockquote>
<p>不需要改变二叉树结构</p>
<p>只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);<br>            <br>        <span class="hljs-keyword">if</span> (root.val &lt; val)&#123;<br>            root.right = insertIntoBST(root.right, val); <span class="hljs-comment">// 递归创建右子树</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; val)&#123;<br>            root.left = insertIntoBST(root.left, val); <span class="hljs-comment">// 递归创建左子树</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="450-删除二叉搜索树中的节点"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a><a class="header-anchor" href="#450-删除二叉搜索树中的节点">⁍</a></h2>
<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [5,3,6,2,4,null,7], key = 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>思路</strong></p>
</blockquote>
<ul>
<li>假如要删除的节点为叶节点，直接删除</li>
<li>假如要删除的节点左节点不为空但右节点为空，则直接用左节点替换当前节点</li>
<li>假如要删除的节点右节点不为空但左节点为空，则直接用右节点替换当前节点</li>
<li>最后要删除的节点左右均不为空，寻找右子树中最左节点，用这个最左节点（就是后继节点）替换当前节点，并且将最左节点从原位置删除。 代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> helper(root, key);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>      root.left = helper(root.left, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>      root.right = helper(root.right, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//找到了，删除</span><br>      <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right; <span class="hljs-comment">//左孩子空，直接补上右节点</span><br>      <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br>      <span class="hljs-comment">//删除右子树的最左节点</span><br>      TreeNode tmp = root.right;<br>      <span class="hljs-keyword">while</span> (tmp.left != <span class="hljs-keyword">null</span>) &#123;<br>        tmp = tmp.left; <span class="hljs-comment">//找到最左节点</span><br>      &#125;<br>      root.val = tmp.val; <span class="hljs-comment">//赋值</span><br>      root.right = helper(root.right, tmp.val); <span class="hljs-comment">//删除右子树最左节点的值</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="449-序列化和反序列化二叉搜索树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/description/">449. 序列化和反序列化二叉搜索树</a><a class="header-anchor" href="#449-序列化和反序列化二叉搜索树">⁍</a></h2>
<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>
<p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>
<p><strong>编码的字符串应尽可能紧凑。</strong></p>
<blockquote>
<p><strong>思路</strong></p>
</blockquote>
<ul>
<li>序列化：后序遍历</li>
<li>反序列化：最后一个节点是root，从后往前搜索第一个小于根节点的就是左子树的根</li>
<li>编码：用4位十六进制编码会缩短空间
<ul>
<li>十六进制转换为十进制： Integer.parseInt(String s, 16)</li>
<li>十进制转换为4位十六进制（十六进制格式化）
<ul>
<li>String.format(“%04x”, num)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(); <span class="hljs-comment">//用StringBuilder拼接字符串更高效</span><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        postorder(root);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left);<br>        postorder(root.right);<br>        sb.append(encode(root.val));<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        <span class="hljs-comment">//先将data转换为十进制数据</span><br>        <span class="hljs-keyword">int</span> len = data.length()/<span class="hljs-number">4</span>;<span class="hljs-comment">//节点个数</span><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<span class="hljs-comment">//节点值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            nums[i] = decode(data.substring(<span class="hljs-number">4</span>*i, <span class="hljs-number">4</span>*(i+<span class="hljs-number">1</span>)));<br>        &#125;<br>        <span class="hljs-comment">//通过nums构造二叉树</span><br>        <span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>        <span class="hljs-comment">//root代表根在nums中的下标</span><br>        <span class="hljs-comment">//start标示树开始的下标</span><br>        <span class="hljs-keyword">if</span> (root&lt;start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(nums[root]);<br><br>        <span class="hljs-keyword">if</span> (root==start) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> root_r = root-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> root_l = start-<span class="hljs-number">1</span>;<span class="hljs-comment">//如果该树不存在，则会root_l&lt;start_l，会返回null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = root-<span class="hljs-number">1</span>; i &gt;= start; i--) &#123;<br>            <span class="hljs-comment">//倒序查找第一个&lt;nums[root]的值</span><br>            <span class="hljs-keyword">if</span> (nums[i]&lt;=nums[root]) &#123;<br>                root_l=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> start_l = start;<br>        <span class="hljs-keyword">int</span> start_r = root_l+<span class="hljs-number">1</span>;<br>        node.left = buildTree(nums, start_l, root_l);<br>        node.right = buildTree(nums, start_r, root_r);<br>        <span class="hljs-keyword">return</span> node;<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%04x&quot;</span>, val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(String val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(val,<span class="hljs-number">16</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>python简单编码版</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.st = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        self.postOrder(root)<br>        <span class="hljs-keyword">return</span> self.st<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span><br>        self.postOrder(root.left)<br>        self.postOrder(root.right)<br>        self.st += self.encode(root.val)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span>(<span class="hljs-params">self, i: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;#&#x27;</span><br>        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type data: str</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">return</span> []<br>        nodes = self.decode(data)<br>        <span class="hljs-comment"># 根节点在最后</span><br>        root_index = <span class="hljs-built_in">len</span>(nodes) - <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(nodes)<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span>(<span class="hljs-params">root_index, start_index</span>):</span><br>            <span class="hljs-keyword">if</span> root_index &lt; start_index:<br>                <span class="hljs-keyword">return</span><br>            <br>            node = TreeNode(nodes[root_index])<br><br>            left_start = start_index <span class="hljs-comment"># 左子树的起始就是根的起始</span><br>            right_root = root_index - <span class="hljs-number">1</span> <span class="hljs-comment"># 右子树的根就是根左边一个</span><br>            <span class="hljs-comment"># 左子树的根是倒序查找第一个小于根节点的数的下标</span><br>            left_root = root_index - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> left_root &gt;= start_index <span class="hljs-keyword">and</span> nodes[left_root] &gt; nodes[root_index]:<br>                left_root-=<span class="hljs-number">1</span><br>            right_start = left_root + <span class="hljs-number">1</span><br>            node.left = buildTree(left_root, left_start)<br>            node.right = buildTree(right_root, right_start)<br><br>            <span class="hljs-keyword">return</span> node<br>        <span class="hljs-keyword">return</span> buildTree(root_index, <span class="hljs-number">0</span>)<br><br><br>        <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span>(<span class="hljs-params">self, data</span>):</span><br>        li = data.split(<span class="hljs-string">&#x27;#&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">int</span>(e) <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> li]<br></code></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/">617. 合并二叉树</a><a class="header-anchor" href="#617-合并二叉树">⁍</a></h2>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<blockquote>
<p><strong>思路：递归</strong></p>
</blockquote>
<p>因为不知道两棵树的深度，所以一定是先序遍历，从根节点开始</p>
<ul>
<li>都不为空，相加，返回</li>
<li>一个为空，一个不为空，返回一个</li>
<li>两个都为空，返回null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root1==<span class="hljs-keyword">null</span>&amp;&amp;root2==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root1==<span class="hljs-keyword">null</span>&amp;&amp;root2!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root2==<span class="hljs-keyword">null</span>&amp;&amp;root1!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(root1.val+root2.val);<br>        node.left = mergeTrees(root1.left, root2.left);<br>        node.right = mergeTrees(root1.right, root2.right);<br><br>        <span class="hljs-keyword">return</span> node;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 (programmercarl.com)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#java">0236.二叉树的最近公共祖先-代码随想录 (programmercarl.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Augu1sto</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://augu1sto.github.io/augu1sto/e55c8c160eac/">https://augu1sto.github.io/augu1sto/e55c8c160eac/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://augu1sto.github.io/augu1sto" target="_blank">若叶</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/augu1sto/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><a class="post-meta__tags" href="/augu1sto/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="social-share" data-image="/augu1sto/img/cover04.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/augu1sto/9ded63ac5cb5/"><img class="prev-cover" src="/augu1sto/img/cover02.jpg" onerror="onerror=null;src='/augu1sto/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JAVA学习（十三）| 多线程</div></div></a></div><div class="next-post pull-right"><a href="/augu1sto/378b031eea17/"><img class="next-cover" src="/augu1sto/img/cover05.jpg" onerror="onerror=null;src='/augu1sto/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVA学习（十二）| 加密与安全</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/augu1sto/2b4514c3bfcc/" title="Leetcode|位运算"><img class="cover" src="/augu1sto/img/cover04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-24</div><div class="title">Leetcode|位运算</div></div></a></div><div><a href="/augu1sto/536722f65a35/" title="Leetcode|动态规划"><img class="cover" src="/augu1sto/img/cover05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-19</div><div class="title">Leetcode|动态规划</div></div></a></div><div><a href="/augu1sto/44694074b950/" title="Leetcode|单调栈"><img class="cover" src="/augu1sto/img/cover01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-10</div><div class="title">Leetcode|单调栈</div></div></a></div><div><a href="/augu1sto/d0b5bb44a690/" title="Leetcode|字符串"><img class="cover" src="/augu1sto/img/cover03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-19</div><div class="title">Leetcode|字符串</div></div></a></div><div><a href="/augu1sto/78b6fa9cea22/" title="Leetcode|回溯算法"><img class="cover" src="/augu1sto/img/cover05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">Leetcode|回溯算法</div></div></a></div><div><a href="/augu1sto/f9cf7ed28499/" title="Leetcode|排序"><img class="cover" src="/augu1sto/img/cover01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Leetcode|排序</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/augu1sto/img/avatar.png" onerror="this.onerror=null;this.src='/augu1sto/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Augu1sto</div><div class="author-info__description">Articles | Notes | Ideas</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/augu1sto/archives/"><div class="headline">文章</div><div class="length-num">79</div></a></div><div class="card-info-data-item is-center"><a href="/augu1sto/tags/"><div class="headline">标签</div><div class="length-num">58</div></a></div><div class="card-info-data-item is-center"><a href="/augu1sto/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/augu1sto"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/augu1sto" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yingu081@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://codepen.io/augu1sto" target="_blank" title="CodePen"><i class="fab fa-codepen"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">【缓慢重新建站中】https://github.com/augu1sto/e31c317e1400/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识[1]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">二叉树的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">二叉树的遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">递归算法三要素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">145. 二叉树的后序遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">145. 二叉树的后序遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">统一迭代法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%9A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">⭐ 广度优先：层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">102. 二叉树的层序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.</span> <span class="toc-text">⭐ 递归函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90-%E9%80%92%E5%BD%92%E4%B8%8E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">⭐ 递归与叶子节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.</span> <span class="toc-text">236. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">3.</span> <span class="toc-text">637. 二叉树的层平均值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">111. 二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A-%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">方法一： 递归法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">方法二：迭代法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#559-n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">6.</span> <span class="toc-text">559. N 叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">7.</span> <span class="toc-text">543. 二叉树的直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">222. 完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">110. 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">226. 翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.</span> <span class="toc-text">101. 对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">12.</span> <span class="toc-text">257. 二叉树的所有路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">13.</span> <span class="toc-text">700. 二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">递归法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">迭代法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">14.</span> <span class="toc-text">⭐ 构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">14.1.</span> <span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">14.2.</span> <span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">14.3.</span> <span class="toc-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90-109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">14.4.</span> <span class="toc-text">⭐ 109. 有序链表转换二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">15.</span> <span class="toc-text">⭐ 701. 二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">16.</span> <span class="toc-text">450. 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#449-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">17.</span> <span class="toc-text">449. 序列化和反序列化二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">18.</span> <span class="toc-text">617. 合并二叉树</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/augu1sto/eb3eaf548f9c/" title="test"><img src="/augu1sto/img/cover01.jpg" onerror="this.onerror=null;this.src='/augu1sto/img/404.jpg'" alt="test"/></a><div class="content"><a class="title" href="/augu1sto/eb3eaf548f9c/" title="test">test</a><time datetime="2022-12-11T17:32:20.000Z" title="发表于 2022-12-12 01:32:20">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/augu1sto/aba77dc25685/" title="test-12"><img src="/augu1sto/img/cover02.jpg" onerror="this.onerror=null;this.src='/augu1sto/img/404.jpg'" alt="test-12"/></a><div class="content"><a class="title" href="/augu1sto/aba77dc25685/" title="test-12">test-12</a><time datetime="2022-12-11T15:15:35.000Z" title="发表于 2022-12-11 23:15:35">2022-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/augu1sto/e31c317e1400/" title="【公告】重新建站ING..."><img src="/augu1sto/img/cover01.jpg" onerror="this.onerror=null;this.src='/augu1sto/img/404.jpg'" alt="【公告】重新建站ING..."/></a><div class="content"><a class="title" href="/augu1sto/e31c317e1400/" title="【公告】重新建站ING...">【公告】重新建站ING...</a><time datetime="2022-11-30T13:52:27.000Z" title="发表于 2022-11-30 21:52:27">2022-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/augu1sto/45f675fda3f8/" title="Array.prototype.unshift方法详解"><img src="/augu1sto/img/cover03.jpg" onerror="this.onerror=null;this.src='/augu1sto/img/404.jpg'" alt="Array.prototype.unshift方法详解"/></a><div class="content"><a class="title" href="/augu1sto/45f675fda3f8/" title="Array.prototype.unshift方法详解">Array.prototype.unshift方法详解</a><time datetime="2022-09-05T11:56:53.000Z" title="发表于 2022-09-05 19:56:53">2022-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/augu1sto/4cf012bad379/" title="深拷贝"><img src="/augu1sto/img/cover01.jpg" onerror="this.onerror=null;this.src='/augu1sto/img/404.jpg'" alt="深拷贝"/></a><div class="content"><a class="title" href="/augu1sto/4cf012bad379/" title="深拷贝">深拷贝</a><time datetime="2022-09-03T12:28:50.000Z" title="发表于 2022-09-03 20:28:50">2022-09-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Augu1sto</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/augu1sto/js/utils.js"></script><script src="/augu1sto/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/augu1sto/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="6990698783" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/augu1sto/live2dw/lib/L2Dwidget.min.js?b0f017d930c51acc4f4f9e757bdd83e9"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/augu1sto/live2dw/assets/kasumi_event128.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"right","hOffset":30,"vOffset":0},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":true,"text":["kira kira doki doki","大家我全都喜欢","poppipa pippopa"]},"log":false});</script></body></html>